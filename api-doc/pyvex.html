

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pyvex — Binary Translator &mdash; angr 7.8.2.21 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="angr 7.8.2.21 documentation" href="index.html"/>
        <link rel="next" title="archinfo — Arch Information Repository" href="archinfo.html"/>
        <link rel="prev" title="cle — Binary Loader" href="cle.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> angr
          

          
          </a>

          
            
            
              <div class="version">
                7.8.2.21
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="angr.html"><code class="docutils literal notranslate"><span class="pre">angr</span></code> — Analysis and Coordination</a></li>
<li class="toctree-l1"><a class="reference internal" href="claripy.html"><code class="docutils literal notranslate"><span class="pre">claripy</span></code> — Solver Engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="cle.html"><code class="docutils literal notranslate"><span class="pre">cle</span></code> — Binary Loader</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#"><code class="docutils literal notranslate"><span class="pre">pyvex</span></code> — Binary Translator</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-pyvex.block">Translation Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-pyvex.stmt">IR Components</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-pyvex.lift">Lifting System</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-pyvex.errors">Errors</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="archinfo.html"><code class="docutils literal notranslate"><span class="pre">archinfo</span></code> — Arch Information Repository</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">angr</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li><code class="docutils literal notranslate"><span class="pre">pyvex</span></code> — Binary Translator</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/pyvex.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-pyvex">
<span id="pyvex-binary-translator"></span><h1><a class="reference internal" href="#module-pyvex" title="pyvex"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pyvex</span></code></a> — Binary Translator<a class="headerlink" href="#module-pyvex" title="Permalink to this headline">¶</a></h1>
<p>PyVEX provides an interface that translates binary code into the VEX intermediate represenation (IR).
For an introduction to VEX, take a look here: <a class="reference external" href="https://docs.angr.io/docs/ir.html">https://docs.angr.io/docs/ir.html</a></p>
<div class="section" id="module-pyvex.block">
<span id="translation-interface"></span><h2>Translation Interface<a class="headerlink" href="#module-pyvex.block" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyvex.block.IRSB">
<em class="property">class </em><code class="descclassname">pyvex.block.</code><code class="descname">IRSB</code><span class="sig-paren">(</span><em>data</em>, <em>mem_addr</em>, <em>arch</em>, <em>max_inst=None</em>, <em>max_bytes=None</em>, <em>bytes_offset=0</em>, <em>traceflags=0</em>, <em>opt_level=1</em>, <em>num_inst=None</em>, <em>num_bytes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.block.IRSB" title="Permalink to this definition">¶</a></dt>
<dd><p>The IRSB is the primary interface to pyvex. Constructing one of these will make a call into LibVEX to perform a
translation.</p>
<p>IRSB stands for <em>Intermediate Representation Super-Block</em>. An IRSB in VEX is a single-entry, multiple-exit code
block.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first simple">
<li><strong>arch</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">archinfo.Arch</span></code>) – The architecture this block is lifted under</li>
<li><strong>statements</strong> (list of <code class="xref py py-class docutils literal notranslate"><span class="pre">IRStmt</span></code>) – The statements in this block</li>
<li><strong>next</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">IRExpr</span></code>) – The expression for the default exit target of this block</li>
<li><strong>offsIP</strong> (<em>int</em>) – The offset of the instruction pointer in the VEX guest state</li>
<li><strong>stmts_used</strong> (<em>int</em>) – The number of statements in this IRSB</li>
<li><strong>jumpkind</strong> (<em>str</em>) – The type of this block’s default jump (call, boring, syscall, etc) as a VEX enum string</li>
<li><strong>direct_next</strong> (<em>bool</em>) – Whether this block ends with a direct (not indirect) jump or branch</li>
<li><strong>size</strong> (<em>int</em>) – The size of this block in bytes</li>
<li><strong>addr</strong> (<em>int</em>) – The address of this basic block, i.e. the address in the first IMark</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data</strong> (<em>str</em><em> or </em><em>bytes</em><em> or </em><em>cffi.FFI.CData</em><em> or </em><em>None</em>) – The bytes to lift. Can be either a string of bytes or a cffi buffer object.
You may also pass None to initialize an empty IRSB.</li>
<li><strong>mem_addr</strong> (<em>int</em>) – The address to lift the data at.</li>
<li><strong>arch</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">archinfo.Arch</span></code>) – The architecture to lift the data as.</li>
<li><strong>max_inst</strong> – The maximum number of instructions to lift. (See note below)</li>
<li><strong>max_bytes</strong> – The maximum number of bytes to use.</li>
<li><strong>num_inst</strong> – Replaces max_inst if max_inst is None. If set to None as well, no instruction limit is used.</li>
<li><strong>num_bytes</strong> – Replaces max_bytes if max_bytes is None. If set to None as well, no  byte limit is used.</li>
<li><strong>bytes_offset</strong> – The offset into <cite>data</cite> to start lifting at.</li>
<li><strong>traceflags</strong> – The libVEX traceflags, controlling VEX debug prints.</li>
<li><strong>opt_level</strong> – The level of optimization to apply to the IR, 0-2. 2 is highest, 0 is no optimization.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Explicitly specifying the number of instructions to lift (<cite>max_inst</cite>) may not always work
exactly as expected. For example, on MIPS, it is meaningless to lift a branch or jump
instruction without its delay slot. VEX attempts to Do The Right Thing by possibly decoding
fewer instructions than requested. Specifically, this means that lifting a branch or jump
on MIPS as a single instruction (<cite>max_inst=1</cite>) will result in an empty IRSB, and subsequent
attempts to run this block will raise <cite>SimIRSBError(‘Empty IRSB passed to SimIRSB.’)</cite>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If no instruction and byte limit is used, pyvex will continue lifting the block until the block
ends properly or until it runs out of data to lift.</p>
</div>
<dl class="method">
<dt id="pyvex.block.IRSB.extend">
<code class="descname">extend</code><span class="sig-paren">(</span><em>extendwith</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.block.IRSB.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Appends an irsb to the current irsb. The irsb that is appended is invalidated. The appended irsb’s jumpkind and
default exit are used.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>extendwith</strong> – The IRSB to append to this IRSB</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyvex.block.IRSB.pp">
<code class="descname">pp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.block.IRSB.pp" title="Permalink to this definition">¶</a></dt>
<dd><p>Pretty-print the IRSB to stdout.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyvex.block.IRSB.expressions">
<code class="descname">expressions</code><a class="headerlink" href="#pyvex.block.IRSB.expressions" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of all expressions contained in the IRSB.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyvex.block.IRSB.instructions">
<code class="descname">instructions</code><a class="headerlink" href="#pyvex.block.IRSB.instructions" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of instructions in this block</p>
</dd></dl>

<dl class="attribute">
<dt id="pyvex.block.IRSB.size">
<code class="descname">size</code><a class="headerlink" href="#pyvex.block.IRSB.size" title="Permalink to this definition">¶</a></dt>
<dd><p>The size of this block, in bytes</p>
</dd></dl>

<dl class="attribute">
<dt id="pyvex.block.IRSB.operations">
<code class="descname">operations</code><a class="headerlink" href="#pyvex.block.IRSB.operations" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of all operations done by the IRSB, as libVEX enum names</p>
</dd></dl>

<dl class="attribute">
<dt id="pyvex.block.IRSB.all_constants">
<code class="descname">all_constants</code><a class="headerlink" href="#pyvex.block.IRSB.all_constants" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns all constants in the block (including incrementing of the program counter) as <a class="reference internal" href="#pyvex.const.IRConst" title="pyvex.const.IRConst"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyvex.const.IRConst</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyvex.block.IRSB.constants">
<code class="descname">constants</code><a class="headerlink" href="#pyvex.block.IRSB.constants" title="Permalink to this definition">¶</a></dt>
<dd><p>The constants (excluding updates of the program counter) in the IRSB as <a class="reference internal" href="#pyvex.const.IRConst" title="pyvex.const.IRConst"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyvex.const.IRConst</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyvex.block.IRSB.constant_jump_targets">
<code class="descname">constant_jump_targets</code><a class="headerlink" href="#pyvex.block.IRSB.constant_jump_targets" title="Permalink to this definition">¶</a></dt>
<dd><p>A set of the static jump targets of the basic block.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyvex.block.IRSB.constant_jump_targets_and_jumpkinds">
<code class="descname">constant_jump_targets_and_jumpkinds</code><a class="headerlink" href="#pyvex.block.IRSB.constant_jump_targets_and_jumpkinds" title="Permalink to this definition">¶</a></dt>
<dd><p>A dict of the static jump targets of the basic block to their jumpkind.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyvex.block.IRTypeEnv">
<em class="property">class </em><code class="descclassname">pyvex.block.</code><code class="descname">IRTypeEnv</code><span class="sig-paren">(</span><em>arch</em>, <em>types=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.block.IRTypeEnv" title="Permalink to this definition">¶</a></dt>
<dd><p>An IR type environment.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><strong>types</strong> (<em>list of str</em>) – A list of the types of all the temporaries in this block as VEX enum strings.
<cite>types[3]</cite> is the type of t3.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pyvex.block.IRTypeEnv.lookup">
<code class="descname">lookup</code><span class="sig-paren">(</span><em>tmp</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.block.IRTypeEnv.lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the type of temporary variable <cite>tmp</cite> as an enum string</p>
</dd></dl>

<dl class="method">
<dt id="pyvex.block.IRTypeEnv.add">
<code class="descname">add</code><span class="sig-paren">(</span><em>ty</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.block.IRTypeEnv.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a new tmp of type <cite>ty</cite> to the environment. Returns the number of the new tmp.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyvex.stmt">
<span id="ir-components"></span><h2>IR Components<a class="headerlink" href="#module-pyvex.stmt" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyvex.stmt.IRStmt">
<em class="property">class </em><code class="descclassname">pyvex.stmt.</code><code class="descname">IRStmt</code><a class="headerlink" href="#pyvex.stmt.IRStmt" title="Permalink to this definition">¶</a></dt>
<dd><p>IR statements in VEX represents operations with side-effects.</p>
</dd></dl>

<dl class="class">
<dt id="pyvex.stmt.NoOp">
<em class="property">class </em><code class="descclassname">pyvex.stmt.</code><code class="descname">NoOp</code><a class="headerlink" href="#pyvex.stmt.NoOp" title="Permalink to this definition">¶</a></dt>
<dd><p>A no-operation statement. It is usually the result of an IR optimization.</p>
</dd></dl>

<dl class="class">
<dt id="pyvex.stmt.IMark">
<em class="property">class </em><code class="descclassname">pyvex.stmt.</code><code class="descname">IMark</code><span class="sig-paren">(</span><em>addr</em>, <em>length</em>, <em>delta</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.stmt.IMark" title="Permalink to this definition">¶</a></dt>
<dd><p>An instruction mark. It marks the start of the statements that represent a single machine instruction (the end of
those statements is marked by the next IMark or the end of the IRSB).  Contains the address and length of the
instruction.</p>
</dd></dl>

<dl class="class">
<dt id="pyvex.stmt.AbiHint">
<em class="property">class </em><code class="descclassname">pyvex.stmt.</code><code class="descname">AbiHint</code><span class="sig-paren">(</span><em>base</em>, <em>length</em>, <em>nia</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.stmt.AbiHint" title="Permalink to this definition">¶</a></dt>
<dd><p>An ABI hint, provides specific information about this platform’s ABI.</p>
</dd></dl>

<dl class="class">
<dt id="pyvex.stmt.Put">
<em class="property">class </em><code class="descclassname">pyvex.stmt.</code><code class="descname">Put</code><span class="sig-paren">(</span><em>data</em>, <em>offset</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.stmt.Put" title="Permalink to this definition">¶</a></dt>
<dd><p>Write to a guest register, at a fixed offset in the guest state.</p>
</dd></dl>

<dl class="class">
<dt id="pyvex.stmt.PutI">
<em class="property">class </em><code class="descclassname">pyvex.stmt.</code><code class="descname">PutI</code><span class="sig-paren">(</span><em>descr</em>, <em>ix</em>, <em>data</em>, <em>bias</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.stmt.PutI" title="Permalink to this definition">¶</a></dt>
<dd><p>Write to a guest register, at a non-fixed offset in the guest state.</p>
</dd></dl>

<dl class="class">
<dt id="pyvex.stmt.WrTmp">
<em class="property">class </em><code class="descclassname">pyvex.stmt.</code><code class="descname">WrTmp</code><span class="sig-paren">(</span><em>tmp</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.stmt.WrTmp" title="Permalink to this definition">¶</a></dt>
<dd><p>Assign a value to a temporary.  Note that SSA rules require each tmp is only assigned to once.  IR sanity checking
will reject any block containing a temporary which is not assigned to exactly once.</p>
</dd></dl>

<dl class="class">
<dt id="pyvex.stmt.Store">
<em class="property">class </em><code class="descclassname">pyvex.stmt.</code><code class="descname">Store</code><span class="sig-paren">(</span><em>addr</em>, <em>data</em>, <em>end</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.stmt.Store" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a value to memory..</p>
</dd></dl>

<dl class="class">
<dt id="pyvex.stmt.CAS">
<em class="property">class </em><code class="descclassname">pyvex.stmt.</code><code class="descname">CAS</code><span class="sig-paren">(</span><em>addr</em>, <em>dataLo</em>, <em>dataHi</em>, <em>expdLo</em>, <em>expdHi</em>, <em>oldLo</em>, <em>oldHi</em>, <em>end</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.stmt.CAS" title="Permalink to this definition">¶</a></dt>
<dd><p>an atomic compare-and-swap operation.</p>
</dd></dl>

<dl class="class">
<dt id="pyvex.stmt.LLSC">
<em class="property">class </em><code class="descclassname">pyvex.stmt.</code><code class="descname">LLSC</code><span class="sig-paren">(</span><em>addr</em>, <em>storedata</em>, <em>result</em>, <em>end</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.stmt.LLSC" title="Permalink to this definition">¶</a></dt>
<dd><p>Either Load-Linked or Store-Conditional, depending on STOREDATA. If STOREDATA is NULL then this is a Load-Linked,
else it is a Store-Conditional.</p>
</dd></dl>

<dl class="class">
<dt id="pyvex.stmt.MBE">
<em class="property">class </em><code class="descclassname">pyvex.stmt.</code><code class="descname">MBE</code><span class="sig-paren">(</span><em>event</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.stmt.MBE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="pyvex.stmt.Dirty">
<em class="property">class </em><code class="descclassname">pyvex.stmt.</code><code class="descname">Dirty</code><span class="sig-paren">(</span><em>cee</em>, <em>guard</em>, <em>args</em>, <em>tmp</em>, <em>mFx</em>, <em>mAddr</em>, <em>mSize</em>, <em>nFxState</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.stmt.Dirty" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="pyvex.stmt.Exit">
<em class="property">class </em><code class="descclassname">pyvex.stmt.</code><code class="descname">Exit</code><span class="sig-paren">(</span><em>guard</em>, <em>dst</em>, <em>jk</em>, <em>offsIP</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.stmt.Exit" title="Permalink to this definition">¶</a></dt>
<dd><p>A conditional exit from the middle of an IRSB.</p>
</dd></dl>

<dl class="class">
<dt id="pyvex.stmt.LoadG">
<em class="property">class </em><code class="descclassname">pyvex.stmt.</code><code class="descname">LoadG</code><span class="sig-paren">(</span><em>end</em>, <em>cvt</em>, <em>dst</em>, <em>addr</em>, <em>alt</em>, <em>guard</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.stmt.LoadG" title="Permalink to this definition">¶</a></dt>
<dd><p>A guarded load.</p>
</dd></dl>

<dl class="class">
<dt id="pyvex.stmt.StoreG">
<em class="property">class </em><code class="descclassname">pyvex.stmt.</code><code class="descname">StoreG</code><span class="sig-paren">(</span><em>end</em>, <em>addr</em>, <em>data</em>, <em>guard</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.stmt.StoreG" title="Permalink to this definition">¶</a></dt>
<dd><p>A guarded store.</p>
</dd></dl>

<span class="target" id="module-pyvex.expr"></span><dl class="class">
<dt id="pyvex.expr.IRExpr">
<em class="property">class </em><code class="descclassname">pyvex.expr.</code><code class="descname">IRExpr</code><a class="headerlink" href="#pyvex.expr.IRExpr" title="Permalink to this definition">¶</a></dt>
<dd><p>IR expressions in VEX represent operations without side effects.</p>
<dl class="attribute">
<dt id="pyvex.expr.IRExpr.child_expressions">
<code class="descname">child_expressions</code><a class="headerlink" href="#pyvex.expr.IRExpr.child_expressions" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of all of the expressions that this expression ends up evaluating.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyvex.expr.IRExpr.constants">
<code class="descname">constants</code><a class="headerlink" href="#pyvex.expr.IRExpr.constants" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of all of the constants that this expression ends up using.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyvex.expr.Binder">
<em class="property">class </em><code class="descclassname">pyvex.expr.</code><code class="descname">Binder</code><span class="sig-paren">(</span><em>binder</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.expr.Binder" title="Permalink to this definition">¶</a></dt>
<dd><p>Used only in pattern matching within Vex. Should not be seen outside of Vex.</p>
</dd></dl>

<dl class="class">
<dt id="pyvex.expr.VECRET">
<em class="property">class </em><code class="descclassname">pyvex.expr.</code><code class="descname">VECRET</code><a class="headerlink" href="#pyvex.expr.VECRET" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="pyvex.expr.GSPTR">
<em class="property">class </em><code class="descclassname">pyvex.expr.</code><code class="descname">GSPTR</code><a class="headerlink" href="#pyvex.expr.GSPTR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="pyvex.expr.GetI">
<em class="property">class </em><code class="descclassname">pyvex.expr.</code><code class="descname">GetI</code><span class="sig-paren">(</span><em>descr</em>, <em>ix</em>, <em>bias</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.expr.GetI" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a guest register at a non-fixed offset in the guest state.</p>
</dd></dl>

<dl class="class">
<dt id="pyvex.expr.RdTmp">
<em class="property">class </em><code class="descclassname">pyvex.expr.</code><code class="descname">RdTmp</code><span class="sig-paren">(</span><em>tmp</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.expr.RdTmp" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the value held by a temporary.</p>
</dd></dl>

<dl class="class">
<dt id="pyvex.expr.Get">
<em class="property">class </em><code class="descclassname">pyvex.expr.</code><code class="descname">Get</code><span class="sig-paren">(</span><em>offset</em>, <em>ty</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.expr.Get" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a guest register, at a fixed offset in the guest state.</p>
</dd></dl>

<dl class="class">
<dt id="pyvex.expr.Qop">
<em class="property">class </em><code class="descclassname">pyvex.expr.</code><code class="descname">Qop</code><span class="sig-paren">(</span><em>op</em>, <em>args</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.expr.Qop" title="Permalink to this definition">¶</a></dt>
<dd><p>A quaternary operation (4 arguments).</p>
</dd></dl>

<dl class="class">
<dt id="pyvex.expr.Triop">
<em class="property">class </em><code class="descclassname">pyvex.expr.</code><code class="descname">Triop</code><span class="sig-paren">(</span><em>op</em>, <em>args</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.expr.Triop" title="Permalink to this definition">¶</a></dt>
<dd><p>A ternary operation (3 arguments)</p>
</dd></dl>

<dl class="class">
<dt id="pyvex.expr.Binop">
<em class="property">class </em><code class="descclassname">pyvex.expr.</code><code class="descname">Binop</code><span class="sig-paren">(</span><em>op</em>, <em>args</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.expr.Binop" title="Permalink to this definition">¶</a></dt>
<dd><p>A binary operation (2 arguments).</p>
</dd></dl>

<dl class="class">
<dt id="pyvex.expr.Unop">
<em class="property">class </em><code class="descclassname">pyvex.expr.</code><code class="descname">Unop</code><span class="sig-paren">(</span><em>op</em>, <em>args</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.expr.Unop" title="Permalink to this definition">¶</a></dt>
<dd><p>A unary operation (1 argument).</p>
</dd></dl>

<dl class="class">
<dt id="pyvex.expr.Load">
<em class="property">class </em><code class="descclassname">pyvex.expr.</code><code class="descname">Load</code><span class="sig-paren">(</span><em>end</em>, <em>ty</em>, <em>addr</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.expr.Load" title="Permalink to this definition">¶</a></dt>
<dd><p>A load from memory.</p>
</dd></dl>

<dl class="class">
<dt id="pyvex.expr.Const">
<em class="property">class </em><code class="descclassname">pyvex.expr.</code><code class="descname">Const</code><span class="sig-paren">(</span><em>con</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.expr.Const" title="Permalink to this definition">¶</a></dt>
<dd><p>A constant expression.</p>
</dd></dl>

<dl class="class">
<dt id="pyvex.expr.ITE">
<em class="property">class </em><code class="descclassname">pyvex.expr.</code><code class="descname">ITE</code><span class="sig-paren">(</span><em>cond</em>, <em>iffalse</em>, <em>iftrue</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.expr.ITE" title="Permalink to this definition">¶</a></dt>
<dd><p>An if-then-else expression.</p>
</dd></dl>

<dl class="class">
<dt id="pyvex.expr.CCall">
<em class="property">class </em><code class="descclassname">pyvex.expr.</code><code class="descname">CCall</code><span class="sig-paren">(</span><em>retty</em>, <em>cee</em>, <em>args</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.expr.CCall" title="Permalink to this definition">¶</a></dt>
<dd><p>A call to a pure (no side-effects) helper C function.</p>
</dd></dl>

<dl class="exception">
<dt id="pyvex.expr.PyvexOpMatchException">
<em class="property">exception </em><code class="descclassname">pyvex.expr.</code><code class="descname">PyvexOpMatchException</code><a class="headerlink" href="#pyvex.expr.PyvexOpMatchException" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="exception">
<dt id="pyvex.expr.PyvexTypeErrorException">
<em class="property">exception </em><code class="descclassname">pyvex.expr.</code><code class="descname">PyvexTypeErrorException</code><a class="headerlink" href="#pyvex.expr.PyvexTypeErrorException" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<span class="target" id="module-pyvex.const"></span><dl class="class">
<dt id="pyvex.const.IRConst">
<em class="property">class </em><code class="descclassname">pyvex.const.</code><code class="descname">IRConst</code><a class="headerlink" href="#pyvex.const.IRConst" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="pyvex.const.U1">
<em class="property">class </em><code class="descclassname">pyvex.const.</code><code class="descname">U1</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.const.U1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="pyvex.const.U8">
<em class="property">class </em><code class="descclassname">pyvex.const.</code><code class="descname">U8</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.const.U8" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="pyvex.const.U16">
<em class="property">class </em><code class="descclassname">pyvex.const.</code><code class="descname">U16</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.const.U16" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="pyvex.const.U32">
<em class="property">class </em><code class="descclassname">pyvex.const.</code><code class="descname">U32</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.const.U32" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="pyvex.const.U64">
<em class="property">class </em><code class="descclassname">pyvex.const.</code><code class="descname">U64</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.const.U64" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="pyvex.const.F32">
<em class="property">class </em><code class="descclassname">pyvex.const.</code><code class="descname">F32</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.const.F32" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="pyvex.const.F32i">
<em class="property">class </em><code class="descclassname">pyvex.const.</code><code class="descname">F32i</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.const.F32i" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="pyvex.const.F64">
<em class="property">class </em><code class="descclassname">pyvex.const.</code><code class="descname">F64</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.const.F64" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="pyvex.const.F64i">
<em class="property">class </em><code class="descclassname">pyvex.const.</code><code class="descname">F64i</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.const.F64i" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="pyvex.const.V128">
<em class="property">class </em><code class="descclassname">pyvex.const.</code><code class="descname">V128</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.const.V128" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="pyvex.const.V256">
<em class="property">class </em><code class="descclassname">pyvex.const.</code><code class="descname">V256</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.const.V256" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pyvex.const.get_type_size">
<code class="descclassname">pyvex.const.</code><code class="descname">get_type_size</code><span class="sig-paren">(</span><em>ty</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.const.get_type_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the size, in BITS, of a VEX type specifier
e.g., Ity_I16 -&gt; 16</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>ty</strong> – </td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyvex.const.get_type_spec_size">
<code class="descclassname">pyvex.const.</code><code class="descname">get_type_spec_size</code><span class="sig-paren">(</span><em>ty</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.const.get_type_spec_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the width of a “type specifier”
like I16U
or F16
or just 16
(Yes, this really just takes the int out.  If we must special-case, do it here.
:param tyspec:
:return:</p>
</dd></dl>

<span class="target" id="module-pyvex.enums"></span><dl class="class">
<dt id="pyvex.enums.VEXObject">
<em class="property">class </em><code class="descclassname">pyvex.enums.</code><code class="descname">VEXObject</code><a class="headerlink" href="#pyvex.enums.VEXObject" title="Permalink to this definition">¶</a></dt>
<dd><p>The base class for Vex types.</p>
</dd></dl>

<dl class="class">
<dt id="pyvex.enums.IRCallee">
<em class="property">class </em><code class="descclassname">pyvex.enums.</code><code class="descname">IRCallee</code><span class="sig-paren">(</span><em>regparms</em>, <em>name</em>, <em>addr</em>, <em>mcx_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.enums.IRCallee" title="Permalink to this definition">¶</a></dt>
<dd><p>Describes a helper function to call.</p>
</dd></dl>

<dl class="class">
<dt id="pyvex.enums.IRRegArray">
<em class="property">class </em><code class="descclassname">pyvex.enums.</code><code class="descname">IRRegArray</code><span class="sig-paren">(</span><em>base</em>, <em>elemTy</em>, <em>nElems</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.enums.IRRegArray" title="Permalink to this definition">¶</a></dt>
<dd><p>A section of the guest state that we want te be able to index at run time, so as to be able to describe indexed or
rotating register files on the guest.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>base</strong> (<em>int</em>) – The offset into the state that this array starts</li>
<li><strong>elemTy</strong> (<em>str</em>) – The types of the elements in this array, as VEX enum strings</li>
<li><strong>nElems</strong> (<em>int</em>) – The number of elements in this array</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-pyvex.lift">
<span id="lifting-system"></span><h2>Lifting System<a class="headerlink" href="#module-pyvex.lift" title="Permalink to this headline">¶</a></h2>
<dl class="exception">
<dt id="pyvex.lift.LiftingException">
<em class="property">exception </em><code class="descclassname">pyvex.lift.</code><code class="descname">LiftingException</code><a class="headerlink" href="#pyvex.lift.LiftingException" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="pyvex.lift.Lifter">
<em class="property">class </em><code class="descclassname">pyvex.lift.</code><code class="descname">Lifter</code><span class="sig-paren">(</span><em>arch</em>, <em>addr</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.lift.Lifter" title="Permalink to this definition">¶</a></dt>
<dd><p>A lifter is a class of methods for processing a block.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>data</strong> – The bytes to lift as either a python string of bytes or a cffi buffer object.</li>
<li><strong>bytes_offset</strong> – The offset into <cite>data</cite> to start lifting at.</li>
<li><strong>max_bytes</strong> – The maximum number of bytes to lift. If set to None, no byte limit is used.</li>
<li><strong>max_inst</strong> – The maximum number of instructions to lift. If set to None, no instruction limit is used.</li>
<li><strong>opt_level</strong> – The level of optimization to apply to the IR, 0-2. Most likely will be ignored in any lifter
other then LibVEX.</li>
<li><strong>traceflags</strong> – The libVEX traceflags, controlling VEX debug prints. Most likely will be ignored in any lifter
other than LibVEX.</li>
<li><strong>allow_lookback</strong> – Should the LibVEX arm-thumb lifter be allowed to look before the current instruction pointer.
Most likely will be ignored in any lifter other than LibVEX.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pyvex.lift.Lifter.lift">
<code class="descname">lift</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.lift.Lifter.lift" title="Permalink to this definition">¶</a></dt>
<dd><p>Lifts the data using the information passed into _lift. Should be overridden in child classes.</p>
<p>Should set the lifted IRSB to self.irsb.
If a lifter raises a LiftingException on the data, this signals that the lifter cannot lift this data and arch
and the lifter is skipped.
If a lifter can lift any amount of data, it should lift it and return the lifted block with a jumpkind of
Ijk_NoDecode, signalling to pyvex that other lifters should be used on the undecodable data.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyvex.lift.lift">
<code class="descclassname">pyvex.lift.</code><code class="descname">lift</code><span class="sig-paren">(</span><em>irsb</em>, <em>arch</em>, <em>addr</em>, <em>data</em>, <em>max_bytes=None</em>, <em>max_inst=None</em>, <em>bytes_offset=None</em>, <em>opt_level=1</em>, <em>traceflags=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.lift.lift" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively lifts blocks using the registered lifters and postprocessors. Tries each lifter in the order in
which they are registered on the data to lift.</p>
<p>If a lifter raises a LiftingException on the data, it is skipped.
If it succeeds and returns a block with a jumpkind of Ijk_NoDecode, all of the lifters are tried on the rest
of the data and if they work, their output is appended to the first block.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>irsb</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">IRSB</span></code>) – The IRSB to set to the lifted block (overriden by the lifted block)</li>
<li><strong>arch</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">archinfo.Arch</span></code>) – The arch to lift the data as.</li>
<li><strong>addr</strong> – The starting address of the block. Effects the IMarks.</li>
<li><strong>data</strong> – The bytes to lift as either a python string of bytes or a cffi buffer object.</li>
<li><strong>max_bytes</strong> – The maximum number of bytes to lift. If set to None, no byte limit is used.</li>
<li><strong>max_inst</strong> – The maximum number of instructions to lift. If set to None, no instruction limit is used.</li>
<li><strong>bytes_offset</strong> – The offset into <cite>data</cite> to start lifting at.</li>
<li><strong>opt_level</strong> – The level of optimization to apply to the IR, 0-2. 2 is maximum optimization, 0 is no optimization.</li>
<li><strong>traceflags</strong> – The libVEX traceflags, controlling VEX debug prints.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Explicitly specifying the number of instructions to lift (<cite>max_inst</cite>) may not always work
exactly as expected. For example, on MIPS, it is meaningless to lift a branch or jump
instruction without its delay slot. VEX attempts to Do The Right Thing by possibly decoding
fewer instructions than requested. Specifically, this means that lifting a branch or jump
on MIPS as a single instruction (<cite>max_inst=1</cite>) will result in an empty IRSB, and subsequent
attempts to run this block will raise <cite>SimIRSBError(‘Empty IRSB passed to SimIRSB.’)</cite>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If no instruction and byte limit is used, pyvex will continue lifting the block until the block
ends properly or until it runs out of data to lift.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="pyvex.lift.register">
<code class="descclassname">pyvex.lift.</code><code class="descname">register</code><span class="sig-paren">(</span><em>lifter</em>, <em>arch_name</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.lift.register" title="Permalink to this definition">¶</a></dt>
<dd><p>Registers a Lifter or Postprocessor to be used by pyvex. Lifters are are given priority based on the order
in which they are registered. Postprocessors will be run in registration order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>lifter</strong> – The Lifter or Postprocessor to register</td>
</tr>
</tbody>
</table>
</dd></dl>

<span class="target" id="module-pyvex.lift.libvex"></span><dl class="class">
<dt id="pyvex.lift.libvex.LibVEXLifter">
<em class="property">class </em><code class="descclassname">pyvex.lift.libvex.</code><code class="descname">LibVEXLifter</code><span class="sig-paren">(</span><em>arch</em>, <em>addr</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.lift.libvex.LibVEXLifter" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pyvex.lift.libvex.LibVEXLifter.lift">
<code class="descname">lift</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.lift.libvex.LibVEXLifter.lift" title="Permalink to this definition">¶</a></dt>
<dd><p>Lifts the data using the information passed into _lift. Should be overridden in child classes.</p>
<p>Should set the lifted IRSB to self.irsb.
If a lifter raises a LiftingException on the data, this signals that the lifter cannot lift this data and arch
and the lifter is skipped.
If a lifter can lift any amount of data, it should lift it and return the lifted block with a jumpkind of
Ijk_NoDecode, signalling to pyvex that other lifters should be used on the undecodable data.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-pyvex.lift.fixes"></span><span class="target" id="module-pyvex.lift.util.irsb_postprocess"></span><dl class="function">
<dt id="pyvex.lift.util.irsb_postprocess.irsb_postproc_flatten">
<code class="descclassname">pyvex.lift.util.irsb_postprocess.</code><code class="descname">irsb_postproc_flatten</code><span class="sig-paren">(</span><em>irsb_old</em>, <em>irsb_new=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.lift.util.irsb_postprocess.irsb_postproc_flatten" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>irsb_old</strong> (<a class="reference internal" href="#pyvex.block.IRSB" title="pyvex.block.IRSB"><em>IRSB</em></a>) – The IRSB to be flattened</li>
<li><strong>irsb_new</strong> (<a class="reference internal" href="#pyvex.block.IRSB" title="pyvex.block.IRSB"><em>IRSB</em></a>) – the IRSB to rewrite the instructions of irsb_old to. If it is None a new empty IRSB will be created</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">the flattened IRSB</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pyvex.block.IRSB" title="pyvex.block.IRSB">IRSB</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<span class="target" id="module-pyvex.lift.util.syntax_wrapper"></span><span class="target" id="module-pyvex.lift.util"></span><span class="target" id="module-pyvex.lift.util.vex_helper"></span><dl class="function">
<dt id="pyvex.lift.util.vex_helper.make_format_op_generator">
<code class="descclassname">pyvex.lift.util.vex_helper.</code><code class="descname">make_format_op_generator</code><span class="sig-paren">(</span><em>fmt_string</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.lift.util.vex_helper.make_format_op_generator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a function which generates an op format (just a string of the vex instruction)</p>
<p>Functions by formatting the fmt_string with the types of the arguments</p>
</dd></dl>

<span class="target" id="module-pyvex.lift.util.lifter_helper"></span><dl class="exception">
<dt id="pyvex.lift.util.lifter_helper.ParseError">
<em class="property">exception </em><code class="descclassname">pyvex.lift.util.lifter_helper.</code><code class="descname">ParseError</code><a class="headerlink" href="#pyvex.lift.util.lifter_helper.ParseError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="pyvex.lift.util.lifter_helper.GymratLifter">
<em class="property">class </em><code class="descclassname">pyvex.lift.util.lifter_helper.</code><code class="descname">GymratLifter</code><span class="sig-paren">(</span><em>arch</em>, <em>addr</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.lift.util.lifter_helper.GymratLifter" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a base class for lifters that use Gymrat.
For most architectures, all you need to do is subclass this, and set the property “instructions”
to be a list of classes that define each instruction.
By default, a lifter will decode instructions by attempting to instantiate every class until one works.
This will use an IRSBCustomizer, which will, if it succeeds, add the appropriate VEX instructions to a pyvex IRSB.
pyvex, when lifting a block of code for this architecture, will call the method “lift”, which will produce the IRSB
of the lifted code.</p>
<dl class="method">
<dt id="pyvex.lift.util.lifter_helper.GymratLifter.lift">
<code class="descname">lift</code><span class="sig-paren">(</span><em>disassemble=False</em>, <em>dump_irsb=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.lift.util.lifter_helper.GymratLifter.lift" title="Permalink to this definition">¶</a></dt>
<dd><p>Lifts the data using the information passed into _lift. Should be overridden in child classes.</p>
<p>Should set the lifted IRSB to self.irsb.
If a lifter raises a LiftingException on the data, this signals that the lifter cannot lift this data and arch
and the lifter is skipped.
If a lifter can lift any amount of data, it should lift it and return the lifted block with a jumpkind of
Ijk_NoDecode, signalling to pyvex that other lifters should be used on the undecodable data.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-pyvex.lift.util.instr_helper"></span><dl class="class">
<dt id="pyvex.lift.util.instr_helper.Instruction">
<em class="property">class </em><code class="descclassname">pyvex.lift.util.instr_helper.</code><code class="descname">Instruction</code><span class="sig-paren">(</span><em>bitstrm</em>, <em>arch</em>, <em>addr</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.lift.util.instr_helper.Instruction" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for an Instruction.
You should make a subclass of this for each instruction you want to lift.
These classes will contain the “semantics” of the instruction, that is, what it _does_, in terms of the VEX IR.</p>
<p>You may want to subclass this for your architecture, and add arch-specific handling
for parsing, argument resolution, etc, and have instructions subclass that instead.</p>
<p>The core parsing functionality is done via a “bit format”.  Each instruction should be a subclass of Instruction,
and will be parsed by comparing bits in the provided bitstream to symbols in the bit_format member of the class.
Bit formats are strings of symbols, like those you’d find in an ISA document, such as “0010rrrrddddffmm”
0 or 1 specify hard-coded bits that must match for an instruction to match.
Any letters specify arguments, grouped by letter, which will be parsed and provided as bitstrings in the “data”
member of the class as a dictionary.
So, in our example, the bits 0010110101101001, applied to format string 0010rrrrddddffmm
will result in the following in self.data:
{‘r’: ‘1101’,</p>
<blockquote>
<div>‘d’: ‘0110’,
‘f’: ‘10’,
‘m’: ‘01’}</div></blockquote>
<dl class="docutils">
<dt>Implement compute_result to provide the “meat” of what your instruction does.</dt>
<dd>You can also implement it in your arch-specific subclass of Instruction, to handle things common to all
instructions, and provide instruction implementations elsewhere..</dd>
</dl>
<p>We provide the VexValue syntax wrapper to make expressing instruction semantics easy.
You first convert the bitstring arguments into VexValues using the provided convenience methods (self.get/put/load)
store/etc. This loads the register from the actual registers into a temporary value we can work with.
You can then write it back to a register when you’re done.
For example, if you have the register in ‘r’, as above, you can make a VexValue like this:
r_vv = self.get(int(self.data[‘r’], 2), Type.int_32)
If you then had an instruction to increment r, you could simply:
return r_vv += 1
You could then write it back to the register like this:
self.put(r_vv, int(self.data[‘r’, 2))</p>
<p>Note that most architectures have special flags that get set differently for each instruction, make sure to
implement those as well. (override set_flags() )</p>
<p>Override parse() to extend parsing; for example, in MSP430, this allows us to grab extra words from the bitstream
when extra immediate words are present.</p>
<p>All architectures are different enough that there’s no magic recipe for how to write a lifter;
See the examples provided by gymrat for ideas of how to use this to build your own lifters quickly and easily.</p>
<p>Create an instance of the instruction
:param irsb_c: The IRSBCustomizer to put VEX instructions into
:param bitstrm: The bitstream to decode instructions from
:param addr: The address of the instruction to be lifted, used only for jumps and branches</p>
<dl class="method">
<dt id="pyvex.lift.util.instr_helper.Instruction.fetch_operands">
<code class="descname">fetch_operands</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.lift.util.instr_helper.Instruction.fetch_operands" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the operands out of memory or registers
Return a tuple of operands for the instruction
:return:</p>
</dd></dl>

<dl class="method">
<dt id="pyvex.lift.util.instr_helper.Instruction.lift">
<code class="descname">lift</code><span class="sig-paren">(</span><em>irsb_c</em>, <em>past_instructions</em>, <em>future_instructions</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.lift.util.instr_helper.Instruction.lift" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the main body of the “lifting” for the instruction.
This can/should be overriden to provide the general flow of how instructions in your arch work.
For example, in MSP430, this is:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Figure out what your operands are by parsing the addressing, and load them into temporary registers</li>
<li>Do the actual operation, and commit the result, if needed.</li>
<li>Compute the flags</li>
</ol>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyvex.lift.util.instr_helper.Instruction.commit_result">
<code class="descname">commit_result</code><span class="sig-paren">(</span><em>res</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.lift.util.instr_helper.Instruction.commit_result" title="Permalink to this definition">¶</a></dt>
<dd><p>This where the result of the operation is written to a destination.
This happens only if compute_result does not return None, and happens before compute_flags is called.
Override this to specify how to write out the result.
The results of fetch_operands can be used to resolve various addressing modes for the write outward.
A common pattern is to return a function from fetch_operands which will be called here to perform the write.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>args</strong> – A tuple of the results of fetch_operands and compute_result</td>
</tr>
</tbody>
</table>
<p>:return n/a</p>
</dd></dl>

<dl class="method">
<dt id="pyvex.lift.util.instr_helper.Instruction.compute_result">
<code class="descname">compute_result</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.lift.util.instr_helper.Instruction.compute_result" title="Permalink to this definition">¶</a></dt>
<dd><p>This is where the actual operation performed by your instruction, excluding the calculation of flags, should be
performed.  Return the VexValue of the “result” of the instruction, which may
be used to calculate the flags later.
For example, for a simple add, with arguments src and dst, you can simply write:</p>
<blockquote>
<div>return src + dst:</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>args</strong> – </td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A VexValue containing the “result” of the operation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyvex.lift.util.instr_helper.Instruction.compute_flags">
<code class="descname">compute_flags</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.lift.util.instr_helper.Instruction.compute_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>Most CPU architectures have “flags” that should be computed for many instructions.
Override this to specify how that happens.  One common pattern is to define this method to call specifi methods
to update each flag, which can then be overriden in the actual classes for each instruction.
:return: n/a</p>
</dd></dl>

<dl class="method">
<dt id="pyvex.lift.util.instr_helper.Instruction.match_instruction">
<code class="descname">match_instruction</code><span class="sig-paren">(</span><em>data</em>, <em>bitstrm</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.lift.util.instr_helper.Instruction.match_instruction" title="Permalink to this definition">¶</a></dt>
<dd><p>Override this to extend the parsing functionality.
This is great for if your arch has instruction “formats” that have an opcode that has to match.
:param data:
:param bitstrm:
:return: data</p>
</dd></dl>

<dl class="method">
<dt id="pyvex.lift.util.instr_helper.Instruction.disassemble">
<code class="descname">disassemble</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.lift.util.instr_helper.Instruction.disassemble" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the disassembly of this instruction, as a string.
Override this in subclasses.
:return: The address (self.addr), the instruction’s name, and a list of its operands, as strings</p>
</dd></dl>

<dl class="method">
<dt id="pyvex.lift.util.instr_helper.Instruction.load">
<code class="descname">load</code><span class="sig-paren">(</span><em>addr</em>, <em>ty</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.lift.util.instr_helper.Instruction.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a value from memory into a VEX temporary register.
:param addr: The VexValue containing the addr to load from.
:param ty: The Type of the resulting data
:return: a VexValue</p>
</dd></dl>

<dl class="method">
<dt id="pyvex.lift.util.instr_helper.Instruction.constant">
<code class="descname">constant</code><span class="sig-paren">(</span><em>val</em>, <em>ty</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.lift.util.instr_helper.Instruction.constant" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a constant as a VexValue
:param val: The value, as an integer
:param ty: The type of the resulting VexValue
:return: a VexValue</p>
</dd></dl>

<dl class="method">
<dt id="pyvex.lift.util.instr_helper.Instruction.get">
<code class="descname">get</code><span class="sig-paren">(</span><em>reg</em>, <em>ty</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.lift.util.instr_helper.Instruction.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a value from a machine register into a VEX temporary register.
All values must be loaded out of registers before they can be used with operations, etc
and stored back into them when the instruction is over.  See Put().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>reg</strong> – Register number as an integer, or register string name</li>
<li><strong>ty</strong> – The Type to use.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A VexValue of the gotten value.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyvex.lift.util.instr_helper.Instruction.put">
<code class="descname">put</code><span class="sig-paren">(</span><em>val</em>, <em>reg</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.lift.util.instr_helper.Instruction.put" title="Permalink to this definition">¶</a></dt>
<dd><p>Puts a value from a VEX temporary register into a machine register.
This is how the results of operations done to registers get committed to the machine’s state.
:param val: The VexValue to store (Want to store a constant? See Constant() first)
:param reg: The integer register number to store into, or register name
:return: None</p>
</dd></dl>

<dl class="method">
<dt id="pyvex.lift.util.instr_helper.Instruction.store">
<code class="descname">store</code><span class="sig-paren">(</span><em>val</em>, <em>addr</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.lift.util.instr_helper.Instruction.store" title="Permalink to this definition">¶</a></dt>
<dd><p>Store a VexValue in memory at the specified loaction.
:param val: The VexValue of the value to store
:param addr: The VexValue of the address to store into
:return: None</p>
</dd></dl>

<dl class="method">
<dt id="pyvex.lift.util.instr_helper.Instruction.jump">
<code class="descname">jump</code><span class="sig-paren">(</span><em>condition</em>, <em>to_addr</em>, <em>jumpkind='Ijk_Boring'</em>, <em>ip_offset=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.lift.util.instr_helper.Instruction.jump" title="Permalink to this definition">¶</a></dt>
<dd><p>Jump to a specified destination, under the specified condition.
Used for branches, jumps, calls, returns, etc.
:param condition: The VexValue representing the expression for the guard, or None for an unconditional jump
:param to_addr: The address to jump to.
:param jumpkind: The JumpKind to use.  See the VEX docs for what these are; you only need them for things
aren’t normal jumps (e.g., calls, interrupts, program exits, etc etc)
:return: None</p>
</dd></dl>

<dl class="method">
<dt id="pyvex.lift.util.instr_helper.Instruction.ccall">
<code class="descname">ccall</code><span class="sig-paren">(</span><em>ret_type</em>, <em>func_obj</em>, <em>args</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvex.lift.util.instr_helper.Instruction.ccall" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a CCall operation.
A CCall is a procedure that calculates a value at <em>runtime</em>, not at lift-time.
You can use these for flags, unresolvable jump targets, etc.
We caution you to avoid using them when at all possible though.</p>
<p>For an example of how to write and use a CCall, see gymrat/bf/lift_bf.py
:param ret_type: The return type of the CCall
:param func_obj: The function object to eventually call.
:param args: List of arguments to the function
:return: A VexValue of the result.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyvex.errors">
<span id="errors"></span><h2>Errors<a class="headerlink" href="#module-pyvex.errors" title="Permalink to this headline">¶</a></h2>
<dl class="exception">
<dt id="pyvex.errors.PyVEXError">
<em class="property">exception </em><code class="descclassname">pyvex.errors.</code><code class="descname">PyVEXError</code><a class="headerlink" href="#pyvex.errors.PyVEXError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="archinfo.html" class="btn btn-neutral float-right" title="archinfo — Arch Information Repository" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="cle.html" class="btn btn-neutral" title="cle — Binary Loader" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, The angr project.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'7.8.2.21',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>