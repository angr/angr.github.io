

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>angr — Analysis and Coordination &mdash; angr 6.7.3.26 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="angr 6.7.3.26 documentation" href="index.html"/>
        <link rel="next" title="simuvex — Program State and Emulation" href="simuvex.html"/>
        <link rel="prev" title="angr API documentation" href="index.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> angr
          

          
          </a>

          
            
            
              <div class="version">
                6.7.3.26
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#"><code class="docutils literal"><span class="pre">angr</span></code> &#8212; Analysis and Coordination</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-angr.project">Project</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-angr.factory">Factory</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-angr.path">Paths &amp; Path Groups</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-angr.knowledge_base">Knowledge Base</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-angr.analysis">Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-angr.simos">SimOS</a></li>
<li class="toctree-l2"><a class="reference internal" href="#surveyors">Surveyors</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="simuvex.html"><code class="docutils literal"><span class="pre">simuvex</span></code> &#8212; Program State and Emulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="claripy.html"><code class="docutils literal"><span class="pre">claripy</span></code> &#8212; Solver Engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="cle.html"><code class="docutils literal"><span class="pre">cle</span></code> &#8212; Binary Loader</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyvex.html"><code class="docutils literal"><span class="pre">pyvex</span></code> &#8212; Binary Translator</a></li>
<li class="toctree-l1"><a class="reference internal" href="archinfo.html"><code class="docutils literal"><span class="pre">archinfo</span></code> &#8212; Arch Information Repository</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">angr</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li><code class="docutils literal"><span class="pre">angr</span></code> &#8212; Analysis and Coordination</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/angr.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="angr-analysis-and-coordination">
<h1><code class="xref py py-mod docutils literal"><span class="pre">angr</span></code> &#8212; Analysis and Coordination<a class="headerlink" href="#angr-analysis-and-coordination" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-angr.project">
<span id="project"></span><h2>Project<a class="headerlink" href="#module-angr.project" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="angr.project.register_default_engine">
<code class="descclassname">angr.project.</code><code class="descname">register_default_engine</code><span class="sig-paren">(</span><em>loader_backend</em>, <em>engine</em>, <em>arch='any'</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.project.register_default_engine" title="Permalink to this definition">¶</a></dt>
<dd><p>Register the default SimuVEX engine to be used with a given CLE backend.
Usually this is the SimEngineVEX, but if you&#8217;re operating on something that isn&#8217;t
going to be lifted to VEX, you&#8217;ll need to make sure the desired engine is registered here.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>loader_backend</strong> &#8211; The loader backend (a type)</li>
<li><strong>type</strong> (<a class="reference internal" href="simuvex.html#module-simuvex.engines.engine" title="simuvex.engines.engine"><em>engine</em></a>) &#8211; The engine to use for the loader backend (a type)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="angr.project.get_default_engine">
<code class="descclassname">angr.project.</code><code class="descname">get_default_engine</code><span class="sig-paren">(</span><em>loader_backend</em>, <em>arch='any'</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.project.get_default_engine" title="Permalink to this definition">¶</a></dt>
<dd><p>Get some sort of sane default for a given loader and/or arch.
Can be set with register_default_engine()
:param loader_backend:
:param arch:
:return:</p>
</dd></dl>

<dl class="class">
<dt id="angr.project.Project">
<em class="property">class </em><code class="descclassname">angr.project.</code><code class="descname">Project</code><span class="sig-paren">(</span><em>thing</em>, <em>default_analysis_mode=None</em>, <em>ignore_functions=None</em>, <em>use_sim_procedures=True</em>, <em>exclude_sim_procedures_func=None</em>, <em>exclude_sim_procedures_list=()</em>, <em>arch=None</em>, <em>simos=None</em>, <em>load_options=None</em>, <em>translation_cache=True</em>, <em>support_selfmodifying_code=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.project.Project" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the main class of the angr module. It is meant to contain a set of binaries and the relationships between
them, and perform analyses on them.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first simple">
<li><a class="reference internal" href="#module-angr.analyses" title="angr.analyses"><strong>analyses</strong></a> &#8211; The available analyses.</li>
<li><a class="reference internal" href="#angr.analyses.forward_analysis.EntryInfo.entry" title="angr.analyses.forward_analysis.EntryInfo.entry"><strong>entry</strong></a> &#8211; The program entrypoint.</li>
<li><a class="reference internal" href="#module-angr.factory" title="angr.factory"><strong>factory</strong></a> &#8211; Provides access to important analysis elements such as path groups and symbolic execution results.</li>
<li><strong>filename</strong> &#8211; The filename of the executable.</li>
<li><a class="reference internal" href="cle.html#module-cle.loader" title="cle.loader"><strong>loader</strong></a> &#8211; The program loader.</li>
<li><a class="reference internal" href="#module-angr.surveyor" title="angr.surveyor"><strong>surveyor</strong></a> &#8211; The available surveyors.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first last"><strong>thing</strong> &#8211; The path to the main executable object to analyze, or a CLE Loader object.</p>
</td>
</tr>
</tbody>
</table>
<p>The following parameters are optional.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>default_analysis_mode</strong> &#8211; The mode of analysis to use by default. Defaults to &#8216;symbolic&#8217;.</li>
<li><strong>ignore_functions</strong> &#8211; A list of function names that, when imported from shared libraries, should
never be stepped into in analysis (calls will return an unconstrained value).</li>
<li><strong>use_sim_procedure</strong> &#8211; Whether to replace resolved dependencies for which simprocedures are
available with said simprocedures.</li>
<li><strong>exclude_sim_procedures_func</strong> &#8211; A function that, when passed a function name, returns whether or not to wrap
it with a simprocedure.</li>
<li><strong>exclude_sim_procedures_list</strong> &#8211; A list of functions to <em>not</em> wrap with simprocedures.</li>
<li><strong>arch</strong> &#8211; The target architecture (auto-detected otherwise).</li>
<li><strong>simos</strong> &#8211; a SimOS class to use for this project.</li>
<li><strong>load_options</strong> &#8211; a dict of keyword arguments to the CLE loader. See CLE&#8217;s docs.</li>
<li><strong>translation_cache</strong> &#8211; If True, cache translated basic blocks rather than re-translating them.</li>
<li><strong>support_selfmodifying_code</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; Whether we support self-modifying code. When enabled, Project.sim_block()
will try to read code from the current state instead of the original memory
regions.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>A sample <cite>load_options</cite> value could be:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="s1">&#39;auto_load_libs&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
  <span class="s1">&#39;skip_libs&#39;</span><span class="p">:</span> <span class="s1">&#39;ld.so.2&#39;</span><span class="p">,</span>
  <span class="s1">&#39;lib_opts&#39;</span><span class="p">:</span> <span class="p">{</span>
    <span class="s1">&#39;libc.so.6&#39;</span><span class="p">:</span> <span class="p">{</span>
    <span class="s1">&#39;custom_base_addr&#39;</span><span class="p">:</span> <span class="mh">0x55555400</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="method">
<dt id="angr.project.Project.hook">
<code class="descname">hook</code><span class="sig-paren">(</span><em>addr</em>, <em>hook</em>, <em>length=0</em>, <em>kwargs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.project.Project.hook" title="Permalink to this definition">¶</a></dt>
<dd><p>Hook a section of code with a custom function. This is used internally to provide symbolic
summaries of library functions, and can be used to instrument execution or to modify
control flow.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>addr</strong> &#8211; The address to hook.</li>
<li><strong>hook</strong> &#8211; A <a class="reference internal" href="#angr.project.Hook" title="angr.project.Hook"><code class="xref py py-class docutils literal"><span class="pre">angr.project.Hook</span></code></a> describing a procedure to run at the
given address. You may also pass in a SimProcedure class or a function
directly and it will be wrapped in a Hook object for you.</li>
<li><strong>length</strong> &#8211; If you provide a function for the hook, this is the number of bytes
that will be skipped by executing the hook by default.</li>
<li><strong>kwargs</strong> &#8211; If you provide a SimProcedure for the hook, these are the keyword
arguments that will be passed to the procedure&#8217;s <cite>run</cite> method
eventually.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.project.Project.is_hooked">
<code class="descname">is_hooked</code><span class="sig-paren">(</span><em>addr</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.project.Project.is_hooked" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if <cite>addr</cite> is hooked.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>addr</strong> &#8211; An address.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if addr is hooked, False otherwise.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.project.Project.is_symbol_hooked">
<code class="descname">is_symbol_hooked</code><span class="sig-paren">(</span><em>symbol_name</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.project.Project.is_symbol_hooked" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if a symbol is already hooked.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>symbol_name</strong> (<em>str</em>) &#8211; Name of the symbol.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if the symbol can be resolved and is hooked, False otherwise.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool">bool</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.project.Project.hooked_symbol_addr">
<code class="descname">hooked_symbol_addr</code><span class="sig-paren">(</span><em>symbol_name</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.project.Project.hooked_symbol_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if a symbol is hooked or not, and if it is hooked, return the address of the symbol.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>symbol_name</strong> (<em>str</em>) &#8211; Name of the symbol.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Address of the symbol if it is hooked, None otherwise.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">int or None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.project.Project.unhook">
<code class="descname">unhook</code><span class="sig-paren">(</span><em>addr</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.project.Project.unhook" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a hook.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>addr</strong> &#8211; The address of the hook.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.project.Project.hooked_by">
<code class="descname">hooked_by</code><span class="sig-paren">(</span><em>addr</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.project.Project.hooked_by" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the current hook for <cite>addr</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>addr</strong> &#8211; An address.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">None if the address is not hooked.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.project.Project.hook_symbol">
<code class="descname">hook_symbol</code><span class="sig-paren">(</span><em>symbol_name</em>, <em>obj</em>, <em>kwargs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.project.Project.hook_symbol" title="Permalink to this definition">¶</a></dt>
<dd><p>Resolve a dependency in a binary. Uses the &#8220;externs object&#8221; (project._extern_obj) to
allocate an address for a new symbol in the binary, and then tells the loader to reperform
the relocation process, taking into account the new symbol.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>symbol_name</strong> &#8211; The name of the dependency to resolve.</li>
<li><strong>obj</strong> &#8211; The thing with which to satisfy the dependency. May be a python integer
or anything that may be passed to <cite>project.hook()</cite>.</li>
<li><strong>length</strong> &#8211; If you provide a function for the hook, this is the number of bytes
that will be skipped by executing the hook by default.</li>
<li><strong>kwargs</strong> &#8211; If you provide a SimProcedure for the hook, these are the keyword
arguments that will be passed to the procedure&#8217;s <cite>run</cite> method
eventually.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The address of the new symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int">int</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.project.Project.hook_symbol_batch">
<code class="descname">hook_symbol_batch</code><span class="sig-paren">(</span><em>hooks</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.project.Project.hook_symbol_batch" title="Permalink to this definition">¶</a></dt>
<dd><p>Hook many symbols at once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>provisions</strong> (<em>dict</em>) &#8211; A mapping from symbol name to hook</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="angr.project.Hook">
<em class="property">class </em><code class="descclassname">angr.project.</code><code class="descname">Hook</code><span class="sig-paren">(</span><em>procedure</em>, <em>cc=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.project.Hook" title="Permalink to this definition">¶</a></dt>
<dd><p>An object describing an action to be taken at a given address instead of executing binary code.
An instance of this class may be passed to <cite>angr.Project.hook</cite> along with the address at which
to hook.</p>
<p>More specifically, a hook is a wrapper for a SimProcedure, a simuvex object that contains a lot
of logic for how to mutate a state in common ways. The SimProcedure base class is subclassed
to produce a SimProcedure that may be used for hooking. If the SimProcedure class is too heavy
for your use case, there is a class method <cite>wrap</cite> on this class that can be used to wrap a
simple function into a SimProcedure, and then further into a <cite>Hook</cite> directly.</p>
<p>This class is a bit of a hack to deal with the fact that SimProcedures need to hold state but
having them do so makes them not thread-safe.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>procedure</strong> &#8211; The class of the procedure to use</li>
<li><strong>cc</strong> &#8211; The calling convention to use</li>
<li><strong>kwargs</strong> &#8211; Any additional keyword arguments will be eventually passed to the
<cite>run</cite> method of the procedure on its execution, via the <cite>sim_kwargs</cite>
SimProcedure constructor parameter.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="angr.project.Hook.instantiate">
<code class="descname">instantiate</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.project.Hook.instantiate" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>arch</strong> &#8211; The architecture to use for this procedure</td>
</tr>
</tbody>
</table>
<p>The following parameters are optional:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>symbolic_return</strong> &#8211; Whether the procedure&#8217;s return value should be stubbed into a
single symbolic variable constratined to the real return value</li>
<li><strong>returns</strong> &#8211; Whether the procedure should return to its caller afterwards</li>
<li><strong>is_syscall</strong> &#8211; Whether this procedure is a syscall</li>
<li><strong>num_args</strong> &#8211; The number of arguments this procedure should extract</li>
<li><strong>display_name</strong> &#8211; The name to use when displaying this procedure</li>
<li><strong>convention</strong> &#8211; The SimCC to use for this procedure</li>
<li><strong>sim_kwargs</strong> &#8211; Additional keyword arguments to be passed to run()</li>
<li><strong>is_function</strong> &#8211; Whether this procedure emulates a function</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="angr.project.Hook.wrap">
<em class="property">classmethod </em><code class="descname">wrap</code><span class="sig-paren">(</span><em>length=0</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.project.Hook.wrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Call this function to return a decorator you can use to turn a function into a Hook. This
specific kind of hook is called a &#8220;User Hook&#8221;.</p>
<p>For example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@Hook</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">length</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">set_rax</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">state</span><span class="o">.</span><span class="n">regs</span><span class="o">.</span><span class="n">rax</span> <span class="o">=</span> <span class="mi">1</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">project</span><span class="o">.</span><span class="n">hook</span><span class="p">(</span><span class="mh">0x1234</span><span class="p">,</span> <span class="n">set_rax</span><span class="p">)</span>
</pre></div>
</div>
<p>The function may modify the state in any way it sees fit. In order to produce successors
from a user hook, you have two options.</p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">Return nothing. In this case, execution will resume at <cite>length</cite> bytes after the hook
address.</p>
</li>
<li><p class="first">Return a list of successor states. Each of the states should have the following
attributes set:</p>
<blockquote>
<div><ul class="simple">
<li><cite>state.scratch.guard</cite>: a symbolic boolean describing the condition necessary for
this successor to be taken. A shortcut to the symbolic <cite>True</cite> value is
<cite>state.se.true</cite>.</li>
<li><cite>state.scratch.jumpkind</cite>: The type of the jump to be taken, as a VEX enum string.
This will usually be <cite>Ijk_Boring</cite>, which signifies an ordinary jump or branch.</li>
</ul>
</div></blockquote>
</li>
</ol>
</div></blockquote>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-angr.factory">
<span id="factory"></span><h2>Factory<a class="headerlink" href="#module-angr.factory" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="angr.factory.AngrObjectFactory">
<em class="property">class </em><code class="descclassname">angr.factory.</code><code class="descname">AngrObjectFactory</code><span class="sig-paren">(</span><em>project</em>, <em>default_engine</em>, <em>procedure_engine</em>, <em>engines</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.factory.AngrObjectFactory" title="Permalink to this definition">¶</a></dt>
<dd><p>This factory provides access to important analysis elements.</p>
<dl class="method">
<dt id="angr.factory.AngrObjectFactory.successors">
<code class="descname">successors</code><span class="sig-paren">(</span><em>state</em>, <em>addr=None</em>, <em>jumpkind=None</em>, <em>inline=False</em>, <em>default_engine=False</em>, <em>engines=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.factory.AngrObjectFactory.successors" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform execution using any applicable engine. Enumerate the current engines and use the
first one that works. Return a SimSuccessors object classifying the results of the run.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>state</strong> &#8211; The state to analyze</li>
<li><strong>addr</strong> &#8211; optional, an address to execute at instead of the state&#8217;s ip</li>
<li><strong>jumpkind</strong> &#8211; optional, the jumpkind of the previous exit</li>
<li><strong>inline</strong> &#8211; This is an inline execution. Do not bother copying the state.</li>
<li><strong>default_engine</strong> &#8211; Whether we should only attempt to use the default engine (usually VEX)</li>
<li><strong>engines</strong> &#8211; A list of engines to try to use, instead of the default.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Additional keyword arguments will be passed directly into each engine&#8217;s process method.</p>
</dd></dl>

<dl class="method">
<dt id="angr.factory.AngrObjectFactory.blank_state">
<code class="descname">blank_state</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.factory.AngrObjectFactory.blank_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a mostly-uninitialized state object. All parameters are optional.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>addr</strong> &#8211; The address the state should start at instead of the entry point.</li>
<li><strong>initial_prefix</strong> &#8211; If this is provided, all symbolic registers will hold symbolic values with names
prefixed by this string.</li>
<li><strong>fs</strong> &#8211; A dictionary of file names with associated preset SimFile objects.</li>
<li><strong>concrete_fs</strong> &#8211; bool describing whether the host filesystem should be consulted when opening files.</li>
<li><strong>chroot</strong> &#8211; A path to use as a fake root directory, Behaves similarly to a real chroot. Used only
when concrete_fs is set to True.</li>
<li><strong>kwargs</strong> &#8211; Any additional keyword args will be passed to the SimState constructor.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The blank state.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="simuvex.html#simuvex.s_state.SimState" title="simuvex.s_state.SimState">simuvex.s_state.SimState</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.factory.AngrObjectFactory.entry_state">
<code class="descname">entry_state</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.factory.AngrObjectFactory.entry_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a state object representing the program at its entry point. All parameters are optional.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>addr</strong> &#8211; The address the state should start at instead of the entry point.</li>
<li><strong>initial_prefix</strong> &#8211; If this is provided, all symbolic registers will hold symbolic values with names
prefixed by this string.</li>
<li><strong>fs</strong> &#8211; a dictionary of file names with associated preset SimFile objects.</li>
<li><strong>concrete_fs</strong> &#8211; boolean describing whether the host filesystem should be consulted when opening files.</li>
<li><strong>chroot</strong> &#8211; a path to use as a fake root directory, behaves similar to a real chroot. used only when
concrete_fs is set to True.</li>
<li><strong>argc</strong> &#8211; a custom value to use for the program&#8217;s argc. May be either an int or a bitvector. If
not provided, defaults to the length of args.</li>
<li><strong>args</strong> &#8211; a list of values to use as the program&#8217;s argv. May be mixed strings and bitvectors.</li>
<li><strong>env</strong> &#8211; a dictionary to use as the environment for the program. Both keys and values may be
mixed strings and bitvectors.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The entry state.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="simuvex.html#simuvex.s_state.SimState" title="simuvex.s_state.SimState">simuvex.s_state.SimState</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.factory.AngrObjectFactory.full_init_state">
<code class="descname">full_init_state</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.factory.AngrObjectFactory.full_init_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Very much like <a class="reference internal" href="#angr.factory.AngrObjectFactory.entry_state" title="angr.factory.AngrObjectFactory.entry_state"><code class="xref py py-meth docutils literal"><span class="pre">entry_state()</span></code></a>, except that instead of starting execution at the program entry point,
execution begins at a special SimProcedure that plays the role of the dynamic loader, calling each of the
initializer functions that should be called before execution reaches the entry point.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>addr</strong> &#8211; The address the state should start at instead of the entry point.</li>
<li><strong>initial_prefix</strong> &#8211; If this is provided, all symbolic registers will hold symbolic values with names
prefixed by this string.</li>
<li><strong>fs</strong> &#8211; a dictionary of file names with associated preset SimFile objects.</li>
<li><strong>concrete_fs</strong> &#8211; boolean describing whether the host filesystem should be consulted when opening files.</li>
<li><strong>chroot</strong> &#8211; a path to use as a fake root directory, behaves similar to a real chroot. used only when
concrete_fs is set to True.</li>
<li><strong>argc</strong> &#8211; a custom value to use for the program&#8217;s argc. May be either an int or a bitvector. If
not provided, defaults to the length of args.</li>
<li><strong>args</strong> &#8211; a list of values to use as arguments to the program. May be mixed strings and bitvectors.</li>
<li><strong>env</strong> &#8211; a dictionary to use as the environment for the program. Both keys and values may be
mixed strings and bitvectors.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The fully initialized state.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="simuvex.html#simuvex.s_state.SimState" title="simuvex.s_state.SimState">simuvex.s_state.SimState</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.factory.AngrObjectFactory.call_state">
<code class="descname">call_state</code><span class="sig-paren">(</span><em>addr</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.factory.AngrObjectFactory.call_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a state object initialized to the start of a given function, as if it were called with given parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>addr</strong> &#8211; The address the state should start at instead of the entry point.</li>
<li><strong>args</strong> &#8211; Any additional positional arguments will be used as arguments to the function call.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The following parametrs are optional.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>base_state</strong> &#8211; Use this SimState as the base for the new state instead of a blank state.</li>
<li><strong>cc</strong> &#8211; Optionally provide a SimCC object to use a specific calling convention.</li>
<li><strong>ret_addr</strong> &#8211; Use this address as the function&#8217;s return target.</li>
<li><strong>stack_base</strong> &#8211; An optional pointer to use as the top of the stack, circa the function entry point</li>
<li><strong>alloc_base</strong> &#8211; An optional pointer to use as the place to put excess argument data</li>
<li><strong>grow_like_stack</strong> &#8211; When allocating data at alloc_base, whether to allocate at decreasing addresses</li>
<li><strong>toc</strong> &#8211; The address of the table of contents for ppc64</li>
<li><strong>initial_prefix</strong> &#8211; If this is provided, all symbolic registers will hold symbolic values with names
prefixed by this string.</li>
<li><strong>fs</strong> &#8211; A dictionary of file names with associated preset SimFile objects.</li>
<li><strong>concrete_fs</strong> &#8211; bool describing whether the host filesystem should be consulted when opening files.</li>
<li><strong>chroot</strong> &#8211; A path to use as a fake root directory, Behaves similarly to a real chroot. Used only
when concrete_fs is set to True.</li>
<li><strong>kwargs</strong> &#8211; Any additional keyword args will be passed to the SimState constructor.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The state at the beginning of the function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="simuvex.html#simuvex.s_state.SimState" title="simuvex.s_state.SimState">simuvex.s_state.SimState</a></p>
</td>
</tr>
</tbody>
</table>
<p>The idea here is that you can provide almost any kind of python type in <cite>args</cite> and it&#8217;ll be translated to a
binary format to be placed into simulated memory. Lists (representing arrays) must be entirely elements of the
same type and size, while tuples (representing structs) can be elements of any type and size.
If you&#8217;d like there to be a pointer to a given value, wrap the value in a <cite>SimCC.PointerWrapper</cite>. Any value
that can&#8217;t fit in a register will be automatically put in a
PointerWrapper.</p>
<p>If stack_base is not provided, the current stack pointer will be used, and it will be updated.
If alloc_base is not provided, the current stack pointer will be used, and it will be updated.
You might not like the results if you provide stack_base but not alloc_base.</p>
<p>grow_like_stack controls the behavior of allocating data at alloc_base. When data from args needs to be wrapped
in a pointer, the pointer needs to point somewhere, so that data is dumped into memory at alloc_base. If you
set alloc_base to point to somewhere other than the stack, set grow_like_stack to False so that sequencial
allocations happen at increasing addresses.</p>
</dd></dl>

<dl class="method">
<dt id="angr.factory.AngrObjectFactory.path">
<code class="descname">path</code><span class="sig-paren">(</span><em>state=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.factory.AngrObjectFactory.path" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a new path.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>state</strong> &#8211; Optional - The state to start the new path at. If not provided, an
<a class="reference internal" href="#angr.factory.AngrObjectFactory.entry_state" title="angr.factory.AngrObjectFactory.entry_state"><code class="xref py py-meth docutils literal"><span class="pre">entry_state()</span></code></a> will be constructed using any additional keyword arguments
provided.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The new path.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#angr.path.Path" title="angr.path.Path">angr.path.Path</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.factory.AngrObjectFactory.path_group">
<code class="descname">path_group</code><span class="sig-paren">(</span><em>thing=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.factory.AngrObjectFactory.path_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a new path group.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>thing</strong> &#8211; Optional - What to put in the new path group&#8217;s active stash.</li>
<li><strong>kwargs</strong> &#8211; Any additional keyword arguments will be passed to the PathGroup constructor</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The new path group</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#angr.path_group.PathGroup" title="angr.path_group.PathGroup">angr.path_group.PathGroup</a></p>
</td>
</tr>
</tbody>
</table>
<p>Many different types can be passed to this method:</p>
<ul class="simple">
<li>If nothing is passed in, the path group is seeded with a path containing a state initialized for the program
entry point, i.e. <a class="reference internal" href="#angr.factory.AngrObjectFactory.entry_state" title="angr.factory.AngrObjectFactory.entry_state"><code class="xref py py-meth docutils literal"><span class="pre">entry_state()</span></code></a>.</li>
<li>If a <a class="reference internal" href="simuvex.html#simuvex.s_state.SimState" title="simuvex.s_state.SimState"><code class="xref py py-class docutils literal"><span class="pre">simuvex.s_state.SimState</span></code></a> is passed in, the path group is seeded with a path wrapping that state.</li>
<li>If a <a class="reference internal" href="#angr.path.Path" title="angr.path.Path"><code class="xref py py-class docutils literal"><span class="pre">angr.path.Path</span></code></a> is passed in, the path group is seeded with that path.</li>
<li>If a list is passed in, the list must contain only SimStates and Paths, each SimState will be wrapped in a
Path, and the whole list will be used to seed the path group.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="angr.factory.AngrObjectFactory.callable">
<code class="descname">callable</code><span class="sig-paren">(</span><em>addr</em>, <em>concrete_only=False</em>, <em>perform_merge=True</em>, <em>base_state=None</em>, <em>toc=None</em>, <em>cc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.factory.AngrObjectFactory.callable" title="Permalink to this definition">¶</a></dt>
<dd><p>A Callable is a representation of a function in the binary that can be interacted with like a native python
function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>addr</strong> &#8211; The address of the function to use</li>
<li><strong>concrete_only</strong> &#8211; Throw an exception if the execution splits into multiple paths</li>
<li><strong>perform_merge</strong> &#8211; Merge all result states into one at the end (only relevant if concrete_only=False)</li>
<li><strong>base_state</strong> &#8211; The state from which to do these runs</li>
<li><strong>toc</strong> &#8211; The address of the table of contents for ppc64</li>
<li><strong>cc</strong> &#8211; The SimCC to use for a calling convention</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A Callable object that can be used as a interface for executing guest code like a
python function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#angr.surveyors.caller.Callable" title="angr.surveyors.caller.Callable">angr.surveyors.caller.Callable</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.factory.AngrObjectFactory.cc">
<code class="descname">cc</code><span class="sig-paren">(</span><em>args=None</em>, <em>ret_val=None</em>, <em>sp_delta=None</em>, <em>func_ty=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.factory.AngrObjectFactory.cc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a SimCC (calling convention) parametrized for this project and, optionally, a given function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>args</strong> &#8211; A list of argument storage locations, as SimFunctionArguments.</li>
<li><strong>ret_val</strong> &#8211; The return value storage location, as a SimFunctionArgument.</li>
<li><strong>sp_delta</strong> &#8211; Does this even matter??</li>
<li><strong>func_ty</strong> &#8211; The protoype for the given function, as a SimType.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Relevant subclasses of SimFunctionArgument are SimRegArg and SimStackArg, and shortcuts to them can be found on
this <cite>cc</cite> object.</p>
<p>For stack arguments, offsets are relative to the stack pointer on function entry.</p>
</dd></dl>

<dl class="method">
<dt id="angr.factory.AngrObjectFactory.cc_from_arg_kinds">
<code class="descname">cc_from_arg_kinds</code><span class="sig-paren">(</span><em>fp_args</em>, <em>ret_fp=None</em>, <em>sizes=None</em>, <em>sp_delta=None</em>, <em>func_ty=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.factory.AngrObjectFactory.cc_from_arg_kinds" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a SimCC (calling convention) that will extract floating-point/integral args correctly.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>arch</strong> &#8211; The Archinfo arch for this CC</li>
<li><strong>fp_args</strong> &#8211; A list, with one entry for each argument the function can take. True if the argument is fp,
false if it is integral.</li>
<li><strong>ret_fp</strong> &#8211; True if the return value for the function is fp.</li>
<li><strong>sizes</strong> &#8211; Optional: A list, with one entry for each argument the function can take. Each entry is the
size of the corresponding argument in bytes.</li>
<li><strong>sp_delta</strong> &#8211; The amount the stack pointer changes over the course of this function - CURRENTLY UNUSED</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parmm func_ty:</th><td class="field-body"><p class="first last">A SimType for the function itself</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-angr.path">
<span id="paths-path-groups"></span><h2>Paths &amp; Path Groups<a class="headerlink" href="#module-angr.path" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="angr.path.Path">
<em class="property">class </em><code class="descclassname">angr.path.</code><code class="descname">Path</code><span class="sig-paren">(</span><em>project</em>, <em>state</em>, <em>path=None</em>, <em>strong_reference=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.path.Path" title="Permalink to this definition">¶</a></dt>
<dd><p>A Path represents a sequence of basic blocks for an execution of the program.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><a class="reference internal" href="claripy.html#claripy.backends.Backend.name" title="claripy.backends.Backend.name"><strong>name</strong></a> &#8211; A string to identify the path.</li>
<li><strong>state</strong> &#8211; The state of the program.</li>
<li><strong>strong_reference</strong> &#8211; Whether or not to keep a strong reference to the previous state in path_history</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:</p>
<dl class="method">
<dt id="angr.path.Path.step">
<code class="descname">step</code><span class="sig-paren">(</span><em>throw=None</em>, <em>**run_args</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.path.Path.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Step a path forward. Optionally takes any argument applicable to project.factory.successors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>jumpkind</strong> &#8211; the jumpkind of the previous exit.</li>
<li><strong>address</strong> (<em>addr</em>) &#8211; to execute at instead of the state&#8217;s ip.</li>
<li><strong>whitelist</strong> &#8211; a list of stmt indexes to which to confine execution.</li>
<li><strong>last_stmt</strong> &#8211; a statement index at which to stop execution.</li>
<li><strong>thumb</strong> &#8211; whether the block should be lifted in ARM&#8217;s THUMB mode.</li>
<li><strong>backup_state</strong> &#8211; a state to read bytes from instead of using project memory.</li>
<li><strong>opt_level</strong> &#8211; the VEX optimization level to use.</li>
<li><strong>insn_bytes</strong> &#8211; a string of bytes to use for the block instead of #the project.</li>
<li><strong>size</strong> &#8211; the maximum size of the block, in bytes.</li>
<li><strong>num_inst</strong> &#8211; the maximum number of instructions.</li>
<li><strong>traceflags</strong> &#8211; traceflags to be passed to VEX. Default: 0</li>
<li><strong>whether or not to keep a strong reference to the previous state. Default</strong> (<em>strong_reference</em>) &#8211; False</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An array of paths for the possible successors.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.path.Path.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.path.Path.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>This function clear the execution status.</p>
<p>After calling this if you call <a class="reference internal" href="#angr.path.Path.step" title="angr.path.Path.step"><code class="xref py py-func docutils literal"><span class="pre">step()</span></code></a>, successors will be recomputed. If you changed something into path
state you probably want to call this method.</p>
</dd></dl>

<dl class="method">
<dt id="angr.path.Path.branch_causes">
<code class="descname">branch_causes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.path.Path.branch_causes" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the variables that have caused this path to branch.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A list of tuples of (basic block address, jmp instruction address, set(variables))</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.path.Path.divergence_addr">
<code class="descname">divergence_addr</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.path.Path.divergence_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the basic block at which the paths diverged.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> &#8211; The other Path.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The address of the basic block.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.path.Path.detect_loops">
<code class="descname">detect_loops</code><span class="sig-paren">(</span><em>n=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.path.Path.detect_loops" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the current loop iteration that a path is on.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>n</strong> &#8211; The minimum number of iterations to check for.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The number of the loop iteration it&#8217;s in.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.path.Path.merge">
<code class="descname">merge</code><span class="sig-paren">(</span><em>*all_paths</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.path.Path.merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a merger of this path with all the paths provided as varargs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>all_paths</strong> &#8211; the paths to merge (variadic positional args)</li>
<li><strong>common_history</strong> &#8211; a PathHistory node shared by all the paths. When this is provided, the
merging becomes more efficient, and actions and such are merged.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">the merged Path</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#angr.path.Path" title="angr.path.Path">Path</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.path.Path.filter_actions">
<code class="descname">filter_actions</code><span class="sig-paren">(</span><em>block_addr=None</em>, <em>block_stmt=None</em>, <em>insn_addr=None</em>, <em>read_from=None</em>, <em>write_to=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.path.Path.filter_actions" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter self.actions based on some common parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>block_addr</strong> &#8211; Only return actions generated in blocks starting at this address.</li>
<li><strong>block_stmt</strong> &#8211; Only return actions generated in the nth statement of each block.</li>
<li><strong>insn_addr</strong> &#8211; Only return actions generated in the assembly instruction at this address.</li>
<li><strong>read_from</strong> &#8211; Only return actions that perform a read from the specified location.</li>
<li><strong>write_to</strong> &#8211; Only return actions that perform a write to the specified location.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Notes:
If IR optimization is turned on, reads and writes may not occur in the instruction
they originally came from. Most commonly, If a register is read from twice in the same
block, the second read will not happen, instead reusing the temp the value is already
stored in.</p>
<p>Valid values for read_from and write_to are the string literals &#8216;reg&#8217; or &#8216;mem&#8217; (matching
any read or write to registers or memory, respectively), any string (representing a read
or write to the named register), and any integer (representing a read or write to the
memory at this address).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="angr.path.ErroredPath">
<em class="property">class </em><code class="descclassname">angr.path.</code><code class="descname">ErroredPath</code><span class="sig-paren">(</span><em>error</em>, <em>traceback</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.path.ErroredPath" title="Permalink to this definition">¶</a></dt>
<dd><p>ErroredPath is used for paths that have encountered and error in their symbolic execution. This kind of path cannot
be stepped further.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><strong>error</strong> &#8211; The error that was encountered.</td>
</tr>
</tbody>
</table>
</dd></dl>

<span class="target" id="module-angr.path_group"></span><dl class="class">
<dt id="angr.path_group.PathGroup">
<em class="property">class </em><code class="descclassname">angr.path_group.</code><code class="descname">PathGroup</code><span class="sig-paren">(</span><em>project</em>, <em>active_paths=None</em>, <em>stashes=None</em>, <em>hierarchy=None</em>, <em>veritesting=None</em>, <em>veritesting_options=None</em>, <em>immutable=None</em>, <em>resilience=None</em>, <em>save_unconstrained=None</em>, <em>save_unsat=None</em>, <em>threads=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.path_group.PathGroup" title="Permalink to this definition">¶</a></dt>
<dd><p>Path groups are the future.</p>
<p>Path groups allow you to wrangle multiple paths in a slick way. Paths are organized into &#8220;stashes&#8221;, which you can
step forward, filter, merge, and move around as you wish. This allows you to, for example, step two different
stashes of paths at different rates, then merge them together.</p>
<p>Stashes can be accessed as attributes (i.e. pg.active). A mulpyplexed stash can be retrieved by prepending the name
with <cite>mp_</cite> (e.g., <cite>pg.mp_active</cite>).</p>
<p>Note that you shouldn&#8217;t usually be constructing path groups directly - there is a convenient shortcuts for
creating path groups in <code class="docutils literal"><span class="pre">Project.factory</span></code>: see <a class="reference internal" href="#angr.factory.AngrObjectFactory" title="angr.factory.AngrObjectFactory"><code class="xref py py-class docutils literal"><span class="pre">angr.factory.AngrObjectFactory</span></code></a>.</p>
<p>Multithreading your search can be useful in constraint-solving-intensive paths. Indeed, Python cannot multithread
due to its GIL, but z3, written in C, can.</p>
<p>The most important methods you should look at are <code class="docutils literal"><span class="pre">step</span></code>, <code class="docutils literal"><span class="pre">explore</span></code>, and <code class="docutils literal"><span class="pre">use_tech</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>project</strong> (<a class="reference internal" href="#angr.project.Project" title="angr.project.Project"><em>angr.project.Project</em></a>) &#8211; A Project instance.</td>
</tr>
</tbody>
</table>
<p>The following parameters are optional.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>active_paths</strong> &#8211; Active paths to seed the &#8220;active&#8221; stash with.</li>
<li><strong>stashes</strong> &#8211; A dictionary to use as the stash store.</li>
<li><strong>hierarchy</strong> &#8211; A PathHierarchy object to use to track path reachability.</li>
<li><strong>immutable</strong> &#8211; If True, all operations will return a new PathGroup. Otherwise (default), all operations
will modify the PathGroup (and return it, for consistency and chaining).</li>
<li><strong>threads</strong> &#8211; the number of worker threads to concurrently analyze states (useful in z3-intensive paths).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="angr.path_group.PathGroup.mulpyplex">
<code class="descname">mulpyplex</code><span class="sig-paren">(</span><em>*stashes</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.path_group.PathGroup.mulpyplex" title="Permalink to this definition">¶</a></dt>
<dd><p>Mulpyplex across several stashes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>stashes</strong> &#8211; the stashes to mulpyplex</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a mulpyplexed list of paths from the stashes in question, in the specified order</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.path_group.PathGroup.apply">
<code class="descname">apply</code><span class="sig-paren">(</span><em>path_func=None</em>, <em>stash_func=None</em>, <em>stash=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.path_group.PathGroup.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies a given function to a given stash.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>path_func</strong> &#8211; A function to apply to every path. Should take a path and return a path. The returned path
will take the place of the old path. If the function <em>doesn&#8217;t</em> return a path, the old
path will be used. If the function returns a list of paths, they will replace the original
paths.</li>
<li><strong>stash_func</strong> &#8211; <p>A function to apply to the whole stash. Should take a list of paths and return a list of
paths. The resulting list will replace the stash.</p>
<p>If both path_func and stash_func are provided path_func is applied first, then stash_func
is applied on the results.</p>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The resulting PathGroup.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#angr.path_group.PathGroup" title="angr.path_group.PathGroup">PathGroup</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.path_group.PathGroup.split">
<code class="descname">split</code><span class="sig-paren">(</span><em>stash_splitter=None</em>, <em>stash_ranker=None</em>, <em>path_ranker=None</em>, <em>limit=None</em>, <em>from_stash=None</em>, <em>to_stash=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.path_group.PathGroup.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Split a stash of paths. The stash from_stash will be split into two stashes depending on the other options
passed in. If to_stash is provided, the second stash will be written there.</p>
<p>stash_splitter overrides stash_ranker, which in turn overrides path_ranker. If no functions are provided, the
paths are simply split according to the limit.</p>
<p>The sort done with path_ranker is ascending.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>stash_splitter</strong> &#8211; A function that should take a list of paths and return a tuple of two lists (the two
resulting stashes).</li>
<li><strong>stash_ranker</strong> &#8211; A function that should take a list of paths and return a sorted list of paths. This list
will then be split according to &#8220;limit&#8221;.</li>
<li><strong>path_ranker</strong> &#8211; An alternative to stash_splitter. Paths will be sorted with outputs of this function.
used as a key. The first &#8220;limit&#8221; of them will be kept, the rest split off.</li>
<li><strong>limit</strong> &#8211; For use with path_ranker. The number of paths to keep. Default: 8</li>
<li><strong>from_stash</strong> &#8211; The stash to split (default: &#8216;active&#8217;)</li>
<li><strong>to_stash</strong> &#8211; The stash to write to (default: &#8216;stashed&#8217;)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The resulting PathGroup.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#angr.path_group.PathGroup" title="angr.path_group.PathGroup">PathGroup</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.path_group.PathGroup.step">
<code class="descname">step</code><span class="sig-paren">(</span><em>n=None</em>, <em>selector_func=None</em>, <em>step_func=None</em>, <em>stash=None</em>, <em>successor_func=None</em>, <em>until=None</em>, <em>check_func=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.path_group.PathGroup.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Step a stash of paths forward, i.e. run <a class="reference internal" href="#angr.path.Path.step" title="angr.path.Path.step"><code class="xref py py-meth docutils literal"><span class="pre">angr.path.Path.step()</span></code></a> on each of the individual paths in a stash
and categorize the successors appropriately.</p>
<p>The parameters to this function allow you to control everything about the stepping and categorization process.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>stash</strong> &#8211; The name of the stash to step (default: &#8216;active&#8217;)</li>
<li><strong>n</strong> &#8211; The number of times to step (default: 1 if &#8220;until&#8221; is not provided)</li>
<li><strong>selector_func</strong> &#8211; If provided, should be a function that takes a Path and returns a boolean. If True, the
path will be stepped. Otherwise, it will be kept as-is.</li>
<li><strong>step_func</strong> &#8211; If provided, should be a function that takes a PathGroup and returns a PathGroup. Will
be called with the PathGroup at every step. Note that this function should not actually
perform any stepping - it is meant to be a maintenance function called after each step.</li>
<li><strong>successor_func</strong> &#8211; If provided, should be a function that takes a path and return its successors.
Otherwise, Path.successors will be used.</li>
<li><strong>until</strong> &#8211; If provided, should be a function that takes a PathGroup and returns True or False.
Stepping will terminate when it is True.</li>
<li><strong>check_func</strong> &#8211; If provided, this function will be called to decide whether the current path is errored
or not. Otherwise, Path.errored will be used.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Additionally, you can pass in any of the following keyword args for project.factory.sim_run:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>jumpkind</strong> &#8211; The jumpkind of the previous exit</li>
<li><strong>addr</strong> &#8211; An address to execute at instead of the state&#8217;s ip.</li>
<li><strong>stmt_whitelist</strong> &#8211; A list of stmt indexes to which to confine execution.</li>
<li><strong>last_stmt</strong> &#8211; A statement index at which to stop execution.</li>
<li><strong>thumb</strong> &#8211; Whether the block should be lifted in ARM&#8217;s THUMB mode.</li>
<li><strong>backup_state</strong> &#8211; A state to read bytes from instead of using project memory.</li>
<li><strong>opt_level</strong> &#8211; The VEX optimization level to use.</li>
<li><strong>insn_bytes</strong> &#8211; A string of bytes to use for the block instead of the project.</li>
<li><strong>size</strong> &#8211; The maximum size of the block, in bytes.</li>
<li><strong>num_inst</strong> &#8211; The maximum number of instructions.</li>
<li><strong>traceflags</strong> &#8211; traceflags to be passed to VEX. Default: 0</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The resulting PathGroup.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#angr.path_group.PathGroup" title="angr.path_group.PathGroup">PathGroup</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.path_group.PathGroup.prune">
<code class="descname">prune</code><span class="sig-paren">(</span><em>filter_func=None</em>, <em>from_stash=None</em>, <em>to_stash=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.path_group.PathGroup.prune" title="Permalink to this definition">¶</a></dt>
<dd><p>Prune unsatisfiable paths from a stash.
This function will move all unsatisfiable or errored paths in the given stash into a different stash.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filter_func</strong> &#8211; Only prune paths that match this filter.</li>
<li><strong>from_stash</strong> &#8211; Prune paths from this stash. (default: &#8216;active&#8217;)</li>
<li><strong>to_stash</strong> &#8211; Put pruned paths in this stash. (default: &#8216;pruned&#8217;)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The resulting PathGroup.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#angr.path_group.PathGroup" title="angr.path_group.PathGroup">PathGroup</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.path_group.PathGroup.move">
<code class="descname">move</code><span class="sig-paren">(</span><em>from_stash</em>, <em>to_stash</em>, <em>filter_func=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.path_group.PathGroup.move" title="Permalink to this definition">¶</a></dt>
<dd><p>Move paths from one stash to another.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>from_stash</strong> &#8211; Take matching paths from this stash.</li>
<li><strong>to_stash</strong> &#8211; Put matching paths into this stash.</li>
<li><strong>filter_func</strong> &#8211; Stash paths that match this filter. Should be a function that takes a path and returns
True or False. Default: stash all paths</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The resulting PathGroup.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#angr.path_group.PathGroup" title="angr.path_group.PathGroup">PathGroup</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.path_group.PathGroup.stash">
<code class="descname">stash</code><span class="sig-paren">(</span><em>filter_func=None</em>, <em>from_stash=None</em>, <em>to_stash=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.path_group.PathGroup.stash" title="Permalink to this definition">¶</a></dt>
<dd><p>Stash some paths. This is an alias for move(), with defaults for the stashes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filter_func</strong> &#8211; Stash paths that match this filter. Should be a function. that takes a path and returns True
or False. (default: stash all paths)</li>
<li><strong>from_stash</strong> &#8211; Take matching paths from this stash. (default: &#8216;active&#8217;)</li>
<li><strong>to_stash</strong> &#8211; Put matching paths into this stash. (default: &#8216;stashed&#8217;)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The resulting PathGroup</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#angr.path_group.PathGroup" title="angr.path_group.PathGroup">PathGroup</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.path_group.PathGroup.drop">
<code class="descname">drop</code><span class="sig-paren">(</span><em>filter_func=None</em>, <em>stash=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.path_group.PathGroup.drop" title="Permalink to this definition">¶</a></dt>
<dd><p>Drops paths from a stash. This is an alias for move(), with defaults for the stashes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filter_func</strong> &#8211; Drop paths that match this filter. Should be a function that takes a path and returns True
or False. (default: drop all paths)</li>
<li><strong>stash</strong> &#8211; Drop matching paths from this stash. (default: &#8216;active&#8217;)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The resulting PathGroup</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#angr.path_group.PathGroup" title="angr.path_group.PathGroup">PathGroup</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.path_group.PathGroup.unstash">
<code class="descname">unstash</code><span class="sig-paren">(</span><em>filter_func=None</em>, <em>to_stash=None</em>, <em>from_stash=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.path_group.PathGroup.unstash" title="Permalink to this definition">¶</a></dt>
<dd><p>Unstash some paths. This is an alias for move(), with defaults for the stashes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filter_func</strong> &#8211; Unstash paths that match this filter. Should be a function that takes a path and returns
True or False. (default: unstash all paths)</li>
<li><strong>from_stash</strong> &#8211; take matching paths from this stash. (default: &#8216;stashed&#8217;)</li>
<li><strong>to_stash</strong> &#8211; put matching paths into this stash. (default: &#8216;active&#8217;)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The resulting PathGroup.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#angr.path_group.PathGroup" title="angr.path_group.PathGroup">PathGroup</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.path_group.PathGroup.merge">
<code class="descname">merge</code><span class="sig-paren">(</span><em>merge_func=None</em>, <em>stash=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.path_group.PathGroup.merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge the states in a given stash.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>stash</strong> &#8211; The stash (default: &#8216;active&#8217;)</li>
<li><strong>merge_func</strong> &#8211; If provided, instead of using path.merge, call this function with the paths as the argument.
Should return the merged path.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result PathGroup.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#angr.path_group.PathGroup" title="angr.path_group.PathGroup">PathGroup</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.path_group.PathGroup.use_technique">
<code class="descname">use_technique</code><span class="sig-paren">(</span><em>tech</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.path_group.PathGroup.use_technique" title="Permalink to this definition">¶</a></dt>
<dd><p>Use an exploration technique with this path group.
Techniques can be found in <a class="reference internal" href="#module-angr.exploration_techniques" title="angr.exploration_techniques"><code class="xref py py-mod docutils literal"><span class="pre">angr.exploration_techniques</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>tech</strong> &#8211; An ExplorationTechnique object that contains code to modify this path group&#8217;s behavior</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.path_group.PathGroup.stash_not_addr">
<code class="descname">stash_not_addr</code><span class="sig-paren">(</span><em>addr</em>, <em>from_stash=None</em>, <em>to_stash=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.path_group.PathGroup.stash_not_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Stash all paths not at address addr from stash from_stash to stash to_stash.</p>
</dd></dl>

<dl class="method">
<dt id="angr.path_group.PathGroup.stash_addr">
<code class="descname">stash_addr</code><span class="sig-paren">(</span><em>addr</em>, <em>from_stash=None</em>, <em>to_stash=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.path_group.PathGroup.stash_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Stash all paths at address addr from stash from_stash to stash to_stash.</p>
</dd></dl>

<dl class="method">
<dt id="angr.path_group.PathGroup.stash_addr_past">
<code class="descname">stash_addr_past</code><span class="sig-paren">(</span><em>addr</em>, <em>from_stash=None</em>, <em>to_stash=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.path_group.PathGroup.stash_addr_past" title="Permalink to this definition">¶</a></dt>
<dd><p>Stash all paths containg address addr in their backtrace from stash from_stash to stash to_stash.</p>
</dd></dl>

<dl class="method">
<dt id="angr.path_group.PathGroup.stash_not_addr_past">
<code class="descname">stash_not_addr_past</code><span class="sig-paren">(</span><em>addr</em>, <em>from_stash=None</em>, <em>to_stash=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.path_group.PathGroup.stash_not_addr_past" title="Permalink to this definition">¶</a></dt>
<dd><p>Stash all paths not containg address addr in their backtrace from stash from_stash to stash to_stash.</p>
</dd></dl>

<dl class="method">
<dt id="angr.path_group.PathGroup.stash_all">
<code class="descname">stash_all</code><span class="sig-paren">(</span><em>from_stash=None</em>, <em>to_stash=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.path_group.PathGroup.stash_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Stash all paths from stash from_stash to stash to_stash.</p>
</dd></dl>

<dl class="method">
<dt id="angr.path_group.PathGroup.unstash_addr">
<code class="descname">unstash_addr</code><span class="sig-paren">(</span><em>addr</em>, <em>from_stash=None</em>, <em>to_stash=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.path_group.PathGroup.unstash_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Unstash all paths at address addr.</p>
</dd></dl>

<dl class="method">
<dt id="angr.path_group.PathGroup.unstash_addr_past">
<code class="descname">unstash_addr_past</code><span class="sig-paren">(</span><em>addr</em>, <em>from_stash=None</em>, <em>to_stash=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.path_group.PathGroup.unstash_addr_past" title="Permalink to this definition">¶</a></dt>
<dd><p>Unstash all paths containing address addr in their backtrace.</p>
</dd></dl>

<dl class="method">
<dt id="angr.path_group.PathGroup.unstash_not_addr">
<code class="descname">unstash_not_addr</code><span class="sig-paren">(</span><em>addr</em>, <em>from_stash=None</em>, <em>to_stash=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.path_group.PathGroup.unstash_not_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Unstash all paths not at address addr.</p>
</dd></dl>

<dl class="method">
<dt id="angr.path_group.PathGroup.unstash_not_addr_past">
<code class="descname">unstash_not_addr_past</code><span class="sig-paren">(</span><em>addr</em>, <em>from_stash=None</em>, <em>to_stash=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.path_group.PathGroup.unstash_not_addr_past" title="Permalink to this definition">¶</a></dt>
<dd><p>Unstash all paths not containing address addr in their backtrace.</p>
</dd></dl>

<dl class="method">
<dt id="angr.path_group.PathGroup.unstash_all">
<code class="descname">unstash_all</code><span class="sig-paren">(</span><em>from_stash=None</em>, <em>to_stash=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.path_group.PathGroup.unstash_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Unstash all paths.</p>
</dd></dl>

<dl class="method">
<dt id="angr.path_group.PathGroup.explore">
<code class="descname">explore</code><span class="sig-paren">(</span><em>stash=None</em>, <em>n=None</em>, <em>find=None</em>, <em>avoid=None</em>, <em>find_stash='found'</em>, <em>avoid_stash='avoid'</em>, <em>cfg=None</em>, <em>num_find=1</em>, <em>step_func=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.path_group.PathGroup.explore" title="Permalink to this definition">¶</a></dt>
<dd><p>Tick stash &#8220;stash&#8221; forward (up to &#8220;n&#8221; times or until &#8220;num_find&#8221; paths are found), looking for condition &#8220;find&#8221;,
avoiding condition &#8220;avoid&#8221;. Stores found paths into &#8220;find_stash&#8217; and avoided paths into &#8220;avoid_stash&#8221;.</p>
<p>The &#8220;find&#8221; and &#8220;avoid&#8221; parameters may be any of:</p>
<ul class="simple">
<li>An address to find</li>
<li>A set or list of addresses to find</li>
<li>A function that takes a path and returns whether or not it matches.</li>
</ul>
<p>If an angr CFG is passed in as the &#8220;cfg&#8221; parameter and &#8220;find&#8221; is either a number or a list or a set, then
any paths which cannot possibly reach a success state without going through a failure state will be
preemptively avoided.</p>
</dd></dl>

<dl class="method">
<dt id="angr.path_group.PathGroup.run">
<code class="descname">run</code><span class="sig-paren">(</span><em>stash=None</em>, <em>n=None</em>, <em>step_func=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.path_group.PathGroup.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Run until the path group has reached a completed state, according to
the current exploration techniques.</p>
<p>TODO: step_func doesn&#8217;t work with veritesting, since veritesting replaces
the default step logic.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>stash</strong> &#8211; Operate on this stash</li>
<li><strong>n</strong> &#8211; Step at most this many times</li>
<li><strong>step_func</strong> &#8211; If provided, should be a function that takes a PathGroup and returns a new PathGroup. Will
be called with the current PathGroup at every step.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The resulting PathGroup.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#angr.path_group.PathGroup" title="angr.path_group.PathGroup">PathGroup</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.exploration_techniques"></span><dl class="class">
<dt id="angr.exploration_techniques.ExplorationTechnique">
<em class="property">class </em><code class="descclassname">angr.exploration_techniques.</code><code class="descname">ExplorationTechnique</code><a class="headerlink" href="#angr.exploration_techniques.ExplorationTechnique" title="Permalink to this definition">¶</a></dt>
<dd><p>An otiegnqwvk is a set of hooks for path groups that assists
in the implementation of new techniques in symbolic exploration.</p>
<p>TODO: choose actual name for the functionality (techniques? something?)</p>
<p>Any number of these methods may be overridden by a subclass.
To use an exploration technique, call <code class="docutils literal"><span class="pre">pg.use_technique</span></code>.</p>
<dl class="method">
<dt id="angr.exploration_techniques.ExplorationTechnique.setup">
<code class="descname">setup</code><span class="sig-paren">(</span><em>pg</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.exploration_techniques.ExplorationTechnique.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform any initialization on this path group you might need to do.</p>
</dd></dl>

<dl class="method">
<dt id="angr.exploration_techniques.ExplorationTechnique.step_path">
<code class="descname">step_path</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.exploration_techniques.ExplorationTechnique.step_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the process of stepping a path forward.</p>
<p>If the stepping fails, return None to fall back to a default stepping procedure.
Otherwise, return a tuple of lists: successors, unconstrained, unsat, pruned, errored</p>
</dd></dl>

<dl class="method">
<dt id="angr.exploration_techniques.ExplorationTechnique.step">
<code class="descname">step</code><span class="sig-paren">(</span><em>pg</em>, <em>stash</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.exploration_techniques.ExplorationTechnique.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Step this stash of this path group forward.</p>
<p>Return the stepped path group.</p>
</dd></dl>

<dl class="method">
<dt id="angr.exploration_techniques.ExplorationTechnique.filter">
<code class="descname">filter</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.exploration_techniques.ExplorationTechnique.filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform filtering on a path.</p>
<p>If the path should not be filtered, return None.
If the path should be filtered, return the name of the stash to move the path to.
If you want to modify the path before filtering it, return a tuple of the stash to move the path to and the
modified path.</p>
</dd></dl>

<dl class="method">
<dt id="angr.exploration_techniques.ExplorationTechnique.complete">
<code class="descname">complete</code><span class="sig-paren">(</span><em>pg</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.exploration_techniques.ExplorationTechnique.complete" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether or not this path group has reached a &#8220;completed&#8221; state, i.e. <code class="docutils literal"><span class="pre">pathgroup.run()</span></code> should halt.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.exploration_techniques.dfs"></span><dl class="class">
<dt id="angr.exploration_techniques.dfs.DFS">
<em class="property">class </em><code class="descclassname">angr.exploration_techniques.dfs.</code><code class="descname">DFS</code><a class="headerlink" href="#angr.exploration_techniques.dfs.DFS" title="Permalink to this definition">¶</a></dt>
<dd><p>Depth-first search.</p>
<p>Will only keep one path active at a time, any others will be stashed in the &#8216;deferred&#8217; stash.
When we run out of active paths to step, we take the longest one from deferred and continue.</p>
</dd></dl>

<span class="target" id="module-angr.exploration_techniques.explorer"></span><dl class="class">
<dt id="angr.exploration_techniques.explorer.Explorer">
<em class="property">class </em><code class="descclassname">angr.exploration_techniques.explorer.</code><code class="descname">Explorer</code><span class="sig-paren">(</span><em>find=None</em>, <em>avoid=None</em>, <em>find_stash='found'</em>, <em>avoid_stash='avoid'</em>, <em>cfg=None</em>, <em>num_find=1</em>, <em>avoid_priority=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.exploration_techniques.explorer.Explorer" title="Permalink to this definition">¶</a></dt>
<dd><p>Search for up to &#8220;num_find&#8221; paths that satisfy condition &#8220;find&#8221;, avoiding condition &#8220;avoid&#8221;. Stashes found paths into &#8220;find_stash&#8217; and avoided paths into &#8220;avoid_stash&#8221;.</p>
<p>The &#8220;find&#8221; and &#8220;avoid&#8221; parameters may be any of:</p>
<ul class="simple">
<li>An address to find</li>
<li>A set or list of addresses to find</li>
<li>A function that takes a path and returns whether or not it matches.</li>
</ul>
<p>If an angr CFG is passed in as the &#8220;cfg&#8221; parameter and &#8220;find&#8221; is either a number or a list or a set, then
any paths which cannot possibly reach a success state without going through a failure state will be
preemptively avoided.</p>
<p>If either the &#8220;find&#8221; or &#8220;avoid&#8221; parameter is a function returning a boolean, and a path triggers both conditions, it will be added to the find stash, unless &#8220;avoid_priority&#8221; is set to True.</p>
</dd></dl>

<span class="target" id="module-angr.exploration_techniques.looplimiter"></span><dl class="class">
<dt id="angr.exploration_techniques.looplimiter.LoopLimiter">
<em class="property">class </em><code class="descclassname">angr.exploration_techniques.looplimiter.</code><code class="descname">LoopLimiter</code><span class="sig-paren">(</span><em>count=5</em>, <em>discard_stash='spinning'</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.exploration_techniques.looplimiter.LoopLimiter" title="Permalink to this definition">¶</a></dt>
<dd><p>Limit the number of loops a path may go through.
Paths that exceed the loop limit are moved to a discard stash.</p>
<p>Note that this uses the default detect_loops method from Path, which approximates loop
counts by counting the number of times each basic block is executed in a given stack frame.</p>
</dd></dl>

<span class="target" id="module-angr.exploration_techniques.threading"></span><dl class="class">
<dt id="angr.exploration_techniques.threading.Threading">
<em class="property">class </em><code class="descclassname">angr.exploration_techniques.threading.</code><code class="descname">Threading</code><span class="sig-paren">(</span><em>threads=8</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.exploration_techniques.threading.Threading" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable multithreading.</p>
<p>This is only useful in paths where a lot of time is taken inside z3, doing constraint solving.
This is because of python&#8217;s GIL, which says that only one thread at a time may be executing python code.</p>
</dd></dl>

<span class="target" id="module-angr.exploration_techniques.veritesting"></span><dl class="class">
<dt id="angr.exploration_techniques.veritesting.Veritesting">
<em class="property">class </em><code class="descclassname">angr.exploration_techniques.veritesting.</code><code class="descname">Veritesting</code><span class="sig-paren">(</span><em>**options</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.exploration_techniques.veritesting.Veritesting" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable veritesting. This technique, described in a paper[1] from CMU, attempts to address the problem of state
explosions in loops by performing smart merging.</p>
<p>[1] <a class="reference external" href="https://users.ece.cmu.edu/~aavgerin/papers/veritesting-icse-2014.pdf">https://users.ece.cmu.edu/~aavgerin/papers/veritesting-icse-2014.pdf</a></p>
</dd></dl>

<span class="target" id="module-angr.path_hierarchy"></span><span class="target" id="module-angr.pathprioritizer"></span></div>
<div class="section" id="module-angr.knowledge_base">
<span id="knowledge-base"></span><h2>Knowledge Base<a class="headerlink" href="#module-angr.knowledge_base" title="Permalink to this headline">¶</a></h2>
<p>Representing the artifacts of a project.</p>
<dl class="class">
<dt id="angr.knowledge_base.KnowledgeBase">
<em class="property">class </em><code class="descclassname">angr.knowledge_base.</code><code class="descname">KnowledgeBase</code><span class="sig-paren">(</span><em>project</em>, <em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.knowledge_base.KnowledgeBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a &#8220;model&#8221; of knowledge about an artifact.</p>
<p>Contains things like a CFG, data references, etc.</p>
</dd></dl>

<span class="target" id="module-angr.knowledge"></span><span class="target" id="module-angr.knowledge.codenode"></span><span class="target" id="module-angr.knowledge.data"></span><span class="target" id="module-angr.knowledge.function"></span><dl class="class">
<dt id="angr.knowledge.function.Function">
<em class="property">class </em><code class="descclassname">angr.knowledge.function.</code><code class="descname">Function</code><span class="sig-paren">(</span><em>function_manager</em>, <em>addr</em>, <em>name=None</em>, <em>syscall=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.knowledge.function.Function" title="Permalink to this definition">¶</a></dt>
<dd><p>A representation of a function and various information about it.</p>
<p>Function constructor</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>addr</strong> &#8211; The address of the function.</li>
<li><strong>name</strong> &#8211; (Optional) The name of the function.</li>
<li><strong>syscall</strong> &#8211; (Optional) Whether this function is a syscall or not.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="angr.knowledge.function.Function.blocks">
<code class="descname">blocks</code><a class="headerlink" href="#angr.knowledge.function.Function.blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>An iterator of all local blocks in the current function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">angr.lifter.Block instances.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="angr.knowledge.function.Function.block_addrs">
<code class="descname">block_addrs</code><a class="headerlink" href="#angr.knowledge.function.Function.block_addrs" title="Permalink to this definition">¶</a></dt>
<dd><p>An iterator of all local block addresses in the current function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">block addresses.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="angr.knowledge.function.Function.block_addrs_set">
<code class="descname">block_addrs_set</code><a class="headerlink" href="#angr.knowledge.function.Function.block_addrs_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a set of block addresses for a better performance of inclusion tests.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A set of block addresses.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">set</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="angr.knowledge.function.Function.operations">
<code class="descname">operations</code><a class="headerlink" href="#angr.knowledge.function.Function.operations" title="Permalink to this definition">¶</a></dt>
<dd><p>All of the operations that are done by this functions.</p>
</dd></dl>

<dl class="attribute">
<dt id="angr.knowledge.function.Function.code_constants">
<code class="descname">code_constants</code><a class="headerlink" href="#angr.knowledge.function.Function.code_constants" title="Permalink to this definition">¶</a></dt>
<dd><p>All of the constants that are used by this functions&#8217;s code.</p>
</dd></dl>

<dl class="method">
<dt id="angr.knowledge.function.Function.string_references">
<code class="descname">string_references</code><span class="sig-paren">(</span><em>minimum_length=2</em>, <em>vex_only=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.knowledge.function.Function.string_references" title="Permalink to this definition">¶</a></dt>
<dd><p>All of the constant string references used by this function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>minimum_length</strong> &#8211; The minimum length of strings to find (default is 1)</li>
<li><strong>vex_only</strong> &#8211; Only analyze VEX IR, don&#8217;t interpret the entry state to detect additional constants.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A list of tuples of (address, string) where is address is the location of the string in
memory.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="angr.knowledge.function.Function.local_runtime_values">
<code class="descname">local_runtime_values</code><a class="headerlink" href="#angr.knowledge.function.Function.local_runtime_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Tries to find all runtime values of this function which do not come from inputs.
These values are generated by starting from a blank state and reanalyzing the basic blocks once each.
Function calls are skipped, and back edges are never taken so these values are often unreliable,
This function is good at finding simple constant addresses which the function will use or calculate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a set of constants</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="angr.knowledge.function.Function.runtime_values">
<code class="descname">runtime_values</code><a class="headerlink" href="#angr.knowledge.function.Function.runtime_values" title="Permalink to this definition">¶</a></dt>
<dd><p>All of the concrete values used by this function at runtime (i.e., including passed-in arguments and global
values).</p>
</dd></dl>

<dl class="attribute">
<dt id="angr.knowledge.function.Function.binary">
<code class="descname">binary</code><a class="headerlink" href="#angr.knowledge.function.Function.binary" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the object this function belongs to.
:return: The object this function belongs to.</p>
</dd></dl>

<dl class="method">
<dt id="angr.knowledge.function.Function.mark_nonreturning_calls_endpoints">
<code class="descname">mark_nonreturning_calls_endpoints</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.knowledge.function.Function.mark_nonreturning_calls_endpoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate through all call edges in transition graph. For each call a non-returning function, mark the source
basic block as an endpoint.</p>
<p>This method should only be executed once all functions are recovered and analyzed by CFG recovery, so we know
whether each function returns or not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.knowledge.function.Function.get_call_sites">
<code class="descname">get_call_sites</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.knowledge.function.Function.get_call_sites" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a list of all the basic blocks that end in calls.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A list of the addresses of the blocks that end in calls.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.knowledge.function.Function.get_call_target">
<code class="descname">get_call_target</code><span class="sig-paren">(</span><em>callsite_addr</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.knowledge.function.Function.get_call_target" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the target of a call.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>callsite_addr</strong> &#8211; The address of a basic block that ends in a call.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The target of said call, or None if callsite_addr is not a
callsite.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.knowledge.function.Function.get_call_return">
<code class="descname">get_call_return</code><span class="sig-paren">(</span><em>callsite_addr</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.knowledge.function.Function.get_call_return" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the hypothetical return address of a call.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>callsite_addr</strong> &#8211; The address of the basic block that ends in a call.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The likely return target of said call, or None if callsite_addr
is not a callsite.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="angr.knowledge.function.Function.graph">
<code class="descname">graph</code><a class="headerlink" href="#angr.knowledge.function.Function.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a local transition graph that only contain nodes in current function.</p>
</dd></dl>

<dl class="method">
<dt id="angr.knowledge.function.Function.subgraph">
<code class="descname">subgraph</code><span class="sig-paren">(</span><em>ins_addrs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.knowledge.function.Function.subgraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a sub control flow graph of instruction addresses based on self.graph</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>ins_addrs</strong> (<em>iterable</em>) &#8211; A collection of instruction addresses that should be included in the subgraph.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A subgraph.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">networkx.DiGraph</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.knowledge.function.Function.instruction_size">
<code class="descname">instruction_size</code><span class="sig-paren">(</span><em>insn_addr</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.knowledge.function.Function.instruction_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the size of the instruction specified by <cite>insn_addr</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>insn_addr</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; Address of the instruction</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Size of the instruction in bytes, or None if the instruction is not found.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int">int</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.knowledge.function.Function.dbg_print">
<code class="descname">dbg_print</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.knowledge.function.Function.dbg_print" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a representation of the list of basic blocks in this function.</p>
</dd></dl>

<dl class="method">
<dt id="angr.knowledge.function.Function.dbg_draw">
<code class="descname">dbg_draw</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.knowledge.function.Function.dbg_draw" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw the graph and save it to a PNG file.</p>
</dd></dl>

<dl class="method">
<dt id="angr.knowledge.function.Function.normalize">
<code class="descname">normalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.knowledge.function.Function.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Make sure all basic blocks in the transition graph of this function do not overlap. You will end up with a CFG
that IDA Pro generates.</p>
<p>This method does not touch the CFG result. You may call CFG{Accurate, Fast}.normalize() for that matter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.knowledge.function_manager"></span><dl class="class">
<dt id="angr.knowledge.function_manager.FunctionDict">
<em class="property">class </em><code class="descclassname">angr.knowledge.function_manager.</code><code class="descname">FunctionDict</code><span class="sig-paren">(</span><em>backref</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.knowledge.function_manager.FunctionDict" title="Permalink to this definition">¶</a></dt>
<dd><p>FunctionDict is a dict where the keys are function starting addresses and
map to the associated <code class="xref py py-class docutils literal"><span class="pre">Function</span></code>.</p>
</dd></dl>

<dl class="class">
<dt id="angr.knowledge.function_manager.FunctionManager">
<em class="property">class </em><code class="descclassname">angr.knowledge.function_manager.</code><code class="descname">FunctionManager</code><span class="sig-paren">(</span><em>kb</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.knowledge.function_manager.FunctionManager" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a function boundaries management tool. It takes in intermediate
results during CFG generation, and manages a function map of the binary.</p>
<dl class="method">
<dt id="angr.knowledge.function_manager.FunctionManager.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>addr=None</em>, <em>name=None</em>, <em>create=False</em>, <em>syscall=False</em>, <em>plt=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.knowledge.function_manager.FunctionManager.function" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a function object from the function manager.</p>
<p>Pass either <cite>addr</cite> or <cite>name</cite> with the appropriate values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>addr</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; Address of the function.</li>
<li><strong>name</strong> (<em>str</em>) &#8211; Name of the function.</li>
<li><strong>create</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; Whether to create the function or not if the function does not exist.</li>
<li><strong>syscall</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; True to create the function as a syscall, False otherwise.</li>
<li><strong>or None plt</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; True to find the PLT stub, False to find a non-PLT stub, None to disable this
restriction.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The Function instance, or None if the function is not found and create is False.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Function or None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-angr.analysis">
<span id="analysis"></span><h2>Analysis<a class="headerlink" href="#module-angr.analysis" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="angr.analysis.Analyses">
<em class="property">class </em><code class="descclassname">angr.analysis.</code><code class="descname">Analyses</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analysis.Analyses" title="Permalink to this definition">¶</a></dt>
<dd><p>This class contains functions for all the registered and runnable analyses,</p>
<p>Creates an Analyses object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><strong>p</strong> &#8211; A project</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="angr.analysis.Analysis">
<em class="property">class </em><code class="descclassname">angr.analysis.</code><code class="descname">Analysis</code><a class="headerlink" href="#angr.analysis.Analysis" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents an analysis on the program.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><a class="reference internal" href="#module-angr.project" title="angr.project"><strong>project</strong></a> &#8211; The project for this analysis.</li>
<li><strong>kb</strong> (<a class="reference internal" href="#angr.knowledge_base.KnowledgeBase" title="angr.knowledge_base.KnowledgeBase"><em>KnowledgeBase</em></a>) &#8211; The knowledgebase object.</li>
<li><strong>_progress_callback</strong> (<a class="reference internal" href="#angr.factory.AngrObjectFactory.callable" title="angr.factory.AngrObjectFactory.callable"><em>callable</em></a>) &#8211; A callback function for receiving the progress of this analysis. It only takes
one argument, which is a float number from 0.0 to 100.0 indicating the current
progress.</li>
<li><strong>_show_progressbar</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; If a progressbar should be shown during the analysis. It&#8217;s independent from
_progress_callback.</li>
<li><strong>_progressbar</strong> (<em>progressbar.ProgressBar</em>) &#8211; The progress bar object.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<span class="target" id="module-angr.annocfg"></span><dl class="class">
<dt id="angr.annocfg.AnnotatedCFG">
<em class="property">class </em><code class="descclassname">angr.annocfg.</code><code class="descname">AnnotatedCFG</code><span class="sig-paren">(</span><em>project</em>, <em>cfg=None</em>, <em>detect_loops=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.annocfg.AnnotatedCFG" title="Permalink to this definition">¶</a></dt>
<dd><p>AnnotatedCFG is a control flow graph with statement whitelists and exit whitelists to describe a slice of the
program.</p>
<p>Constructor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>project</strong> &#8211; The angr Project instance</li>
<li><strong>cfg</strong> &#8211; Control flow graph. Only used when path prioritizer is used.</li>
<li><strong>detect_loops</strong> &#8211; Only used when path prioritizer is used.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="angr.annocfg.AnnotatedCFG.from_digraph">
<code class="descname">from_digraph</code><span class="sig-paren">(</span><em>digraph</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.annocfg.AnnotatedCFG.from_digraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize this AnnotatedCFG object with a networkx.DiGraph consisting of the following
form of nodes:</p>
<p>Tuples like (block address, statement ID)</p>
<p>Those nodes are connected by edges indicating the execution flow.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>digraph</strong> &#8211; A networkx.DiGraph object</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.annocfg.AnnotatedCFG.add_loop">
<code class="descname">add_loop</code><span class="sig-paren">(</span><em>loop_tuple</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.annocfg.AnnotatedCFG.add_loop" title="Permalink to this definition">¶</a></dt>
<dd><p>A loop tuple contains a series of IRSB addresses that form a loop. Ideally
it always starts with the first IRSB that we meet during the execution.</p>
</dd></dl>

<dl class="method">
<dt id="angr.annocfg.AnnotatedCFG.get_whitelisted_statements">
<code class="descname">get_whitelisted_statements</code><span class="sig-paren">(</span><em>addr</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.annocfg.AnnotatedCFG.get_whitelisted_statements" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">True if all statements are whitelisted</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.annocfg.AnnotatedCFG.dbg_print_irsb">
<code class="descname">dbg_print_irsb</code><span class="sig-paren">(</span><em>irsb_addr</em>, <em>project=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.annocfg.AnnotatedCFG.dbg_print_irsb" title="Permalink to this definition">¶</a></dt>
<dd><p>Pretty-print an IRSB with whitelist information</p>
</dd></dl>

<dl class="method">
<dt id="angr.annocfg.AnnotatedCFG.keep_path">
<code class="descname">keep_path</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.annocfg.AnnotatedCFG.keep_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a path, returns True if the path should be kept, False if it should be cut.</p>
</dd></dl>

<dl class="method">
<dt id="angr.annocfg.AnnotatedCFG.filter_path">
<code class="descname">filter_path</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.annocfg.AnnotatedCFG.filter_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Used for debugging.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path</strong> &#8211; A Path instance</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True/False</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.annocfg.AnnotatedCFG.path_priority">
<code class="descname">path_priority</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.annocfg.AnnotatedCFG.path_priority" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a path, returns the path priority. A lower number means a higher priority.</p>
</dd></dl>

<dl class="method">
<dt id="angr.annocfg.AnnotatedCFG.successor_func">
<code class="descname">successor_func</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.annocfg.AnnotatedCFG.successor_func" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback routine that takes in a path, and returns all feasible successors to path group. This callback routine
should be passed to the keyword argument &#8220;successor_func&#8221; of PathGroup.step().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path</strong> &#8211; A Path instance.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A list of all feasible Path successors.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.blade"></span><dl class="class">
<dt id="angr.blade.Blade">
<em class="property">class </em><code class="descclassname">angr.blade.</code><code class="descname">Blade</code><span class="sig-paren">(</span><em>graph</em>, <em>dst_run</em>, <em>dst_stmt_idx</em>, <em>direction='backward'</em>, <em>project=None</em>, <em>cfg=None</em>, <em>ignore_sp=False</em>, <em>ignore_bp=False</em>, <em>ignored_regs=None</em>, <em>max_level=3</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.blade.Blade" title="Permalink to this definition">¶</a></dt>
<dd><p>Blade is a light-weight program slicer that works with networkx DiGraph containing CFGNodes.
It is meant to be used in angr for small or on-the-fly analyses.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>graph</strong> (<em>networkx.DiGraph</em>) &#8211; A graph representing the control flow graph. Note that it does not take
angr.analyses.CFGAccurate or angr.analyses.CFGFast.</li>
<li><strong>dst_run</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; An address specifying the target SimRun.</li>
<li><strong>dst_stmt_idx</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The target statement index. -1 means executing until the last statement.</li>
<li><strong>direction</strong> (<em>str</em>) &#8211; &#8216;backward&#8217; or &#8216;forward&#8217; slicing. Forward slicing is not yet supported.</li>
<li><strong>project</strong> (<em>angr.Project</em>) &#8211; The project instance.</li>
<li><strong>cfg</strong> (<em>angr.analyses.CFGBase</em>) &#8211; the CFG instance. It will be made mandatory later.</li>
<li><strong>ignore_sp</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; Whether the stack pointer should be ignored in dependency tracking. Any
dependency from/to stack pointers will be ignored if this options is True.</li>
<li><strong>ignore_bp</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; Whether the base pointer should be ignored or not.</li>
<li><strong>max_level</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The maximum number of blocks that we trace back for.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<span class="target" id="module-angr.analyses"></span><span class="target" id="module-angr.analyses.backward_slice"></span><dl class="class">
<dt id="angr.analyses.backward_slice.BackwardSlice">
<em class="property">class </em><code class="descclassname">angr.analyses.backward_slice.</code><code class="descname">BackwardSlice</code><span class="sig-paren">(</span><em>cfg</em>, <em>cdg</em>, <em>ddg</em>, <em>targets=None</em>, <em>cfg_node=None</em>, <em>stmt_id=None</em>, <em>control_flow_slice=False</em>, <em>same_function=False</em>, <em>no_construct=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.backward_slice.BackwardSlice" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a backward slice of the program.</p>
<p>Create a backward slice from a specific statement based on provided control flow graph (CFG), control
dependence graph (CDG), and data dependence graph (DDG).</p>
<p>The data dependence graph can be either CFG-based, or Value-set analysis based. A CFG-based DDG is much faster
to generate, but it only reflects those states while generating the CFG, and it is neither sound nor accurate.
The VSA based DDG (called VSA_DDG) is based on static analysis, which gives you a much better result.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cfg</strong> &#8211; The control flow graph.</li>
<li><strong>cdg</strong> &#8211; The control dependence graph.</li>
<li><strong>ddg</strong> &#8211; The data dependence graph.</li>
<li><strong>targets</strong> &#8211; A list of &#8220;target&#8221; that specify targets of the backward slices. Each target can be a
tuple in form of (cfg_node, stmt_idx), or a CodeLocation instance.</li>
<li><strong>cfg_node</strong> &#8211; Deprecated. The target CFGNode to reach. It should exist in the CFG.</li>
<li><strong>stmt_id</strong> &#8211; Deprecated. The target statement to reach.</li>
<li><strong>control_flow_slice</strong> &#8211; True/False, indicates whether we should slice only based on CFG. Sometimes when
acquiring DDG is difficult or impossible, you can just create a slice on your CFG.
Well, if you don&#8217;t even have a CFG, then...</li>
<li><strong>no_construct</strong> &#8211; Only used for testing and debugging to easily create a BackwardSlice object.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="angr.analyses.backward_slice.BackwardSlice.dbg_repr">
<code class="descname">dbg_repr</code><span class="sig-paren">(</span><em>max_display=10</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.backward_slice.BackwardSlice.dbg_repr" title="Permalink to this definition">¶</a></dt>
<dd><p>Debugging output of this slice.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>max_display</strong> &#8211; The maximum number of SimRun slices to show.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A string representation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.backward_slice.BackwardSlice.dbg_repr_run">
<code class="descname">dbg_repr_run</code><span class="sig-paren">(</span><em>run_addr</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.backward_slice.BackwardSlice.dbg_repr_run" title="Permalink to this definition">¶</a></dt>
<dd><p>Debugging output of a single SimRun slice.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>run_addr</strong> &#8211; Address of the SimRun.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A string representation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.backward_slice.BackwardSlice.annotated_cfg">
<code class="descname">annotated_cfg</code><span class="sig-paren">(</span><em>start_point=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.backward_slice.BackwardSlice.annotated_cfg" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an AnnotatedCFG based on slicing result.</p>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.backward_slice.BackwardSlice.is_taint_related_to_ip">
<code class="descname">is_taint_related_to_ip</code><span class="sig-paren">(</span><em>simrun_addr</em>, <em>stmt_idx</em>, <em>taint_type</em>, <em>simrun_whitelist=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.backward_slice.BackwardSlice.is_taint_related_to_ip" title="Permalink to this definition">¶</a></dt>
<dd><p>Query in taint graph to check if a specific taint will taint the IP in the future or not.
The taint is specified with the tuple (simrun_addr, stmt_idx, taint_type).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>simrun_addr</strong> &#8211; Address of the SimRun.</li>
<li><strong>stmt_idx</strong> &#8211; Statement ID.</li>
<li><strong>taint_type</strong> &#8211; Type of the taint, might be one of the following: &#8216;reg&#8217;, &#8216;tmp&#8217;, &#8216;mem&#8217;.</li>
<li><strong>simrun_whitelist</strong> &#8211; A list of SimRun addresses that are whitelisted, i.e. the tainted exit will be
ignored if it is in those SimRuns.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">True/False</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.backward_slice.BackwardSlice.is_taint_impacting_stack_pointers">
<code class="descname">is_taint_impacting_stack_pointers</code><span class="sig-paren">(</span><em>simrun_addr</em>, <em>stmt_idx</em>, <em>taint_type</em>, <em>simrun_whitelist=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.backward_slice.BackwardSlice.is_taint_impacting_stack_pointers" title="Permalink to this definition">¶</a></dt>
<dd><p>Query in taint graph to check if a specific taint will taint the stack pointer in the future or not.
The taint is specified with the tuple (simrun_addr, stmt_idx, taint_type).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>simrun_addr</strong> &#8211; Address of the SimRun.</li>
<li><strong>stmt_idx</strong> &#8211; Statement ID.</li>
<li><strong>taint_type</strong> &#8211; Type of the taint, might be one of the following: &#8216;reg&#8217;, &#8216;tmp&#8217;, &#8216;mem&#8217;.</li>
<li><strong>simrun_whitelist</strong> &#8211; A list of SimRun addresses that are whitelisted.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">True/False.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.analyses.bindiff"></span><dl class="function">
<dt id="angr.analyses.bindiff.differing_constants">
<code class="descclassname">angr.analyses.bindiff.</code><code class="descname">differing_constants</code><span class="sig-paren">(</span><em>block_a</em>, <em>block_b</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.bindiff.differing_constants" title="Permalink to this definition">¶</a></dt>
<dd><p>Compares two basic blocks and finds all the constants that differ from the first block to the second.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>block_a</strong> &#8211; The first block to compare.</li>
<li><strong>block_b</strong> &#8211; The second block to compare.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Returns a list of differing constants in the form of ConstantChange, which has the offset in the
block and the respective constants.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="angr.analyses.bindiff.FunctionDiff">
<em class="property">class </em><code class="descclassname">angr.analyses.bindiff.</code><code class="descname">FunctionDiff</code><span class="sig-paren">(</span><em>function_a</em>, <em>function_b</em>, <em>bindiff=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.bindiff.FunctionDiff" title="Permalink to this definition">¶</a></dt>
<dd><p>This class computes the a diff between two functions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>function_a</strong> &#8211; The first angr Function object to diff.</li>
<li><strong>function_b</strong> &#8211; The second angr Function object.</li>
<li><strong>bindiff</strong> &#8211; An optional Bindiff object. Used for some extra normalization during basic block comparison.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="angr.analyses.bindiff.FunctionDiff.probably_identical">
<code class="descname">probably_identical</code><a class="headerlink" href="#angr.analyses.bindiff.FunctionDiff.probably_identical" title="Permalink to this definition">¶</a></dt>
<dd><p><em>returns</em> &#8211; Whether or not these two functions are identical.</p>
</dd></dl>

<dl class="attribute">
<dt id="angr.analyses.bindiff.FunctionDiff.identical_blocks">
<code class="descname">identical_blocks</code><a class="headerlink" href="#angr.analyses.bindiff.FunctionDiff.identical_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p><em>returns</em> &#8211; A list of block matches which appear to be identical</p>
</dd></dl>

<dl class="attribute">
<dt id="angr.analyses.bindiff.FunctionDiff.differing_blocks">
<code class="descname">differing_blocks</code><a class="headerlink" href="#angr.analyses.bindiff.FunctionDiff.differing_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p><em>returns</em> &#8211; A list of block matches which appear to differ</p>
</dd></dl>

<dl class="attribute">
<dt id="angr.analyses.bindiff.FunctionDiff.blocks_with_differing_constants">
<code class="descname">blocks_with_differing_constants</code><a class="headerlink" href="#angr.analyses.bindiff.FunctionDiff.blocks_with_differing_constants" title="Permalink to this definition">¶</a></dt>
<dd><p><em>return</em> &#8211; A list of block matches which appear to differ</p>
</dd></dl>

<dl class="staticmethod">
<dt id="angr.analyses.bindiff.FunctionDiff.get_normalized_block">
<em class="property">static </em><code class="descname">get_normalized_block</code><span class="sig-paren">(</span><em>addr</em>, <em>function</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.bindiff.FunctionDiff.get_normalized_block" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>addr</strong> &#8211; Where to start the normalized block.</li>
<li><strong>function</strong> &#8211; A function containing the block address.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A normalized basic block.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.bindiff.FunctionDiff.block_similarity">
<code class="descname">block_similarity</code><span class="sig-paren">(</span><em>block_a</em>, <em>block_b</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.bindiff.FunctionDiff.block_similarity" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>block_a</strong> &#8211; The first block address.</li>
<li><strong>block_b</strong> &#8211; The second block address.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The similarity of the basic blocks, normalized for the base address of the block and function
call addresses.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.bindiff.FunctionDiff.blocks_probably_identical">
<code class="descname">blocks_probably_identical</code><span class="sig-paren">(</span><em>block_a</em>, <em>block_b</em>, <em>check_constants=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.bindiff.FunctionDiff.blocks_probably_identical" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>block_a</strong> &#8211; The first block address.</li>
<li><strong>block_b</strong> &#8211; The second block address.</li>
<li><strong>check_constants</strong> &#8211; Whether or not to require matching constants in blocks.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Whether or not the blocks appear to be identical.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="angr.analyses.bindiff.BinDiff">
<em class="property">class </em><code class="descclassname">angr.analyses.bindiff.</code><code class="descname">BinDiff</code><span class="sig-paren">(</span><em>other_project</em>, <em>enable_advanced_backward_slicing=False</em>, <em>cfg_a=None</em>, <em>cfg_b=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.bindiff.BinDiff" title="Permalink to this definition">¶</a></dt>
<dd><p>This class computes the a diff between two binaries represented by angr Projects</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other_project</strong> &#8211; The second project to diff</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="angr.analyses.bindiff.BinDiff.functions_probably_identical">
<code class="descname">functions_probably_identical</code><span class="sig-paren">(</span><em>func_a_addr</em>, <em>func_b_addr</em>, <em>check_consts=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.bindiff.BinDiff.functions_probably_identical" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two functions and return True if they appear identical.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>func_a_addr</strong> &#8211; The address of the first function (in the first binary).</li>
<li><strong>func_b_addr</strong> &#8211; The address of the second function (in the second binary).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Whether or not the functions appear to be identical.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="angr.analyses.bindiff.BinDiff.identical_functions">
<code class="descname">identical_functions</code><a class="headerlink" href="#angr.analyses.bindiff.BinDiff.identical_functions" title="Permalink to this definition">¶</a></dt>
<dd><p><em>returns</em> &#8211; A list of function matches that appear to be identical</p>
</dd></dl>

<dl class="attribute">
<dt id="angr.analyses.bindiff.BinDiff.differing_functions">
<code class="descname">differing_functions</code><a class="headerlink" href="#angr.analyses.bindiff.BinDiff.differing_functions" title="Permalink to this definition">¶</a></dt>
<dd><p><em>returns</em> &#8211; A list of function matches that appear to differ</p>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.bindiff.BinDiff.differing_functions_with_consts">
<code class="descname">differing_functions_with_consts</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.bindiff.BinDiff.differing_functions_with_consts" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A list of function matches that appear to differ including just by constants</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="angr.analyses.bindiff.BinDiff.differing_blocks">
<code class="descname">differing_blocks</code><a class="headerlink" href="#angr.analyses.bindiff.BinDiff.differing_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p><em>returns</em> &#8211; A list of block matches that appear to differ</p>
</dd></dl>

<dl class="attribute">
<dt id="angr.analyses.bindiff.BinDiff.identical_blocks">
<code class="descname">identical_blocks</code><a class="headerlink" href="#angr.analyses.bindiff.BinDiff.identical_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>return A list of all block matches that appear to be identical</p>
</dd></dl>

<dl class="attribute">
<dt id="angr.analyses.bindiff.BinDiff.blocks_with_differing_constants">
<code class="descname">blocks_with_differing_constants</code><a class="headerlink" href="#angr.analyses.bindiff.BinDiff.blocks_with_differing_constants" title="Permalink to this definition">¶</a></dt>
<dd><p><em>return</em> &#8211; A dict of block matches with differing constants to the tuple of constants</p>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.bindiff.BinDiff.get_function_diff">
<code class="descname">get_function_diff</code><span class="sig-paren">(</span><em>function_addr_a</em>, <em>function_addr_b</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.bindiff.BinDiff.get_function_diff" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>function_addr_a</strong> &#8211; The address of the first function (in the first binary)</li>
<li><strong>function_addr_b</strong> &#8211; The address of the second function (in the second binary)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the FunctionDiff of the two functions</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.analyses.boyscout"></span><dl class="class">
<dt id="angr.analyses.boyscout.BoyScout">
<em class="property">class </em><code class="descclassname">angr.analyses.boyscout.</code><code class="descname">BoyScout</code><span class="sig-paren">(</span><em>cookiesize=1</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.boyscout.BoyScout" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to determine the architecture and endieness of a binary blob</p>
</dd></dl>

<span class="target" id="module-angr.analyses.cdg"></span><dl class="class">
<dt id="angr.analyses.cdg.TemporaryNode">
<em class="property">class </em><code class="descclassname">angr.analyses.cdg.</code><code class="descname">TemporaryNode</code><span class="sig-paren">(</span><em>label</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cdg.TemporaryNode" title="Permalink to this definition">¶</a></dt>
<dd><p>A temporary node.</p>
<p>Used as the start node and end node in post-dominator tree generation. Also used in some test cases.</p>
</dd></dl>

<dl class="class">
<dt id="angr.analyses.cdg.ContainerNode">
<em class="property">class </em><code class="descclassname">angr.analyses.cdg.</code><code class="descname">ContainerNode</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cdg.ContainerNode" title="Permalink to this definition">¶</a></dt>
<dd><p>A container node.</p>
<p>Only used in post-dominator tree generation. We did this so we can set the index property without modifying the
original object.</p>
</dd></dl>

<dl class="class">
<dt id="angr.analyses.cdg.CDG">
<em class="property">class </em><code class="descclassname">angr.analyses.cdg.</code><code class="descname">CDG</code><span class="sig-paren">(</span><em>cfg</em>, <em>start=None</em>, <em>no_construct=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cdg.CDG" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements a control dependence graph.</p>
<p>Constructor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cfg</strong> &#8211; The control flow graph upon which this control dependence graph will build</li>
<li><strong>start</strong> &#8211; The starting point to begin constructing the control dependence graph</li>
<li><strong>no_construct</strong> &#8211; Skip the construction step. Only used in unit-testing.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="angr.analyses.cdg.CDG.get_post_dominators">
<code class="descname">get_post_dominators</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cdg.CDG.get_post_dominators" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the post-dom tree</p>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cdg.CDG.get_dependants">
<code class="descname">get_dependants</code><span class="sig-paren">(</span><em>run</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cdg.CDG.get_dependants" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of nodes that are control dependent on the given node in the control dependence graph</p>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cdg.CDG.get_guardians">
<code class="descname">get_guardians</code><span class="sig-paren">(</span><em>run</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cdg.CDG.get_guardians" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of nodes on whom the specific node is control dependent in the control dependence graph</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.analyses.cfg_accurate"></span><dl class="class">
<dt id="angr.analyses.cfg_accurate.CFGAccurate">
<em class="property">class </em><code class="descclassname">angr.analyses.cfg_accurate.</code><code class="descname">CFGAccurate</code><span class="sig-paren">(</span><em>context_sensitivity_level=1</em>, <em>start=None</em>, <em>avoid_runs=None</em>, <em>enable_function_hints=False</em>, <em>call_depth=None</em>, <em>call_tracing_filter=None</em>, <em>initial_state=None</em>, <em>starts=None</em>, <em>keep_state=False</em>, <em>enable_advanced_backward_slicing=False</em>, <em>enable_symbolic_back_traversal=False</em>, <em>additional_edges=None</em>, <em>no_construct=False</em>, <em>normalize=False</em>, <em>max_iterations=1</em>, <em>address_whitelist=None</em>, <em>base_graph=None</em>, <em>iropt_level=None</em>, <em>max_steps=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg_accurate.CFGAccurate" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents a control-flow graph.</p>
<p>All parameters are optional.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>context_sensitivity_level</strong> &#8211; The level of context-sensitivity of this CFG (see documentation for
further details). It ranges from 0 to infinity. Default 1.</li>
<li><strong>avoid_runs</strong> &#8211; A list of runs to avoid.</li>
<li><strong>enable_function_hints</strong> &#8211; Whether to use function hints (constants that might be used as exit
targets) or not.</li>
<li><strong>call_depth</strong> &#8211; How deep in the call stack to trace.</li>
<li><strong>call_tracing_filter</strong> &#8211; Filter to apply on a given path and jumpkind to determine if it
should be skipped when call_depth is reached.</li>
<li><strong>initial_state</strong> &#8211; An initial state to use to begin analysis.</li>
<li><strong>starts</strong> (<em>iterable</em>) &#8211; A collection of starting points to begin analysis. It can contain
the following three different types of entries: an address specified
as an integer, a 2-tuple that includes an integer address and a
jumpkind, or a SimState instance. Unsupported entries in starts will
lead to an AngrCFGError being raised.</li>
<li><strong>keep_state</strong> &#8211; Whether to keep the SimStates for each CFGNode.</li>
<li><strong>enable_advanced_backward_slicing</strong> &#8211; Whether to enable an intensive technique for resolving direct jumps</li>
<li><strong>enable_symbolic_back_traversal</strong> &#8211; Whether to enable an intensive technique for resolving indirect jumps</li>
<li><strong>additional_edges</strong> &#8211; A dict mapping addresses of basic blocks to addresses of
successors to manually include and analyze forward from.</li>
<li><strong>no_construct</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; Skip the construction procedure. Only used in unit-testing.</li>
<li><strong>normalize</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; If the CFG as well as all Function graphs should be normalized or
not.</li>
<li><strong>max_iterations</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The maximum number of iterations that each basic block should be
&#8220;executed&#8221;. 1 by default. Larger numbers of iterations are usually
required for complex analyses like loop analysis.</li>
<li><strong>address_whitelist</strong> (<em>iterable</em>) &#8211; A list of allowed addresses. Any basic blocks outside of this
collection of addresses will be ignored.</li>
<li><strong>base_graph</strong> (<em>networkx.DiGraph</em>) &#8211; A basic control flow graph to follow. Each node inside this graph
must have the following properties: <cite>addr</cite> and <cite>size</cite>. CFG recovery
will strictly follow nodes and edges shown in the graph, and discard
any contorl flow that does not follow an existing edge in the base
graph. For example, you can pass in a Function local transition
graph as the base graph, and CFGAccurate will traverse nodes and
edges and extract useful information.</li>
<li><strong>iropt_level</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The optimization level of VEX IR (0, 1, 2). The default level will
be used if <cite>iropt_level</cite> is None.</li>
<li><strong>max_steps</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The maximum number of basic blocks to recover forthe longest path
from each start before pausing the recovery procedure.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="angr.analyses.cfg_accurate.CFGAccurate.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg_accurate.CFGAccurate.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a copy of the CFG.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A copy of the CFG instance.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">angr.analyses.CFG</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg_accurate.CFGAccurate.resume">
<code class="descname">resume</code><span class="sig-paren">(</span><em>starts=None</em>, <em>max_steps=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg_accurate.CFGAccurate.resume" title="Permalink to this definition">¶</a></dt>
<dd><p>Resume a paused or terminated control flow graph recovery.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>starts</strong> (<em>iterable</em>) &#8211; A collection of new starts to resume from. If <cite>starts</cite> is None, we will resume CFG
recovery from where it was paused before.</li>
<li><strong>max_steps</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The maximum number of blocks on the longest path starting from each start before pausing
the recovery.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg_accurate.CFGAccurate.downsize">
<code class="descname">downsize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg_accurate.CFGAccurate.downsize" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove saved states from all CFGNodes to reduce memory usage.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg_accurate.CFGAccurate.unroll_loops">
<code class="descname">unroll_loops</code><span class="sig-paren">(</span><em>max_loop_unrolling_times</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg_accurate.CFGAccurate.unroll_loops" title="Permalink to this definition">¶</a></dt>
<dd><p>Unroll loops for each function. The resulting CFG may still contain loops due to recursion, function calls, etc.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>max_loop_unrolling_times</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The maximum iterations of unrolling.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg_accurate.CFGAccurate.force_unroll_loops">
<code class="descname">force_unroll_loops</code><span class="sig-paren">(</span><em>max_loop_unrolling_times</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg_accurate.CFGAccurate.force_unroll_loops" title="Permalink to this definition">¶</a></dt>
<dd><p>Unroll loops globally. The resulting CFG does not contain any loop, but this method is slow on large graphs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>max_loop_unrolling_times</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The maximum iterations of unrolling.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg_accurate.CFGAccurate.remove_fakerets">
<code class="descname">remove_fakerets</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg_accurate.CFGAccurate.remove_fakerets" title="Permalink to this definition">¶</a></dt>
<dd><p>Get rid of fake returns (i.e., Ijk_FakeRet edges) from this CFG</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg_accurate.CFGAccurate.get_topological_order">
<code class="descname">get_topological_order</code><span class="sig-paren">(</span><em>cfg_node</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg_accurate.CFGAccurate.get_topological_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the topological order of a CFG Node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cfg_node</strong> &#8211; A CFGNode instance.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">An integer representing its order, or None if the CFGNode does not exist in the graph.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg_accurate.CFGAccurate.get_subgraph">
<code class="descname">get_subgraph</code><span class="sig-paren">(</span><em>starting_node</em>, <em>block_addresses</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg_accurate.CFGAccurate.get_subgraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a sub-graph out of a bunch of basic block addresses.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>starting_node</strong> (<a class="reference internal" href="#angr.analyses.cfg_node.CFGNode" title="angr.analyses.cfg_node.CFGNode"><em>CFGNode</em></a>) &#8211; The beginning of the subgraph</li>
<li><strong>block_addresses</strong> (<em>iterable</em>) &#8211; A collection of block addresses that should be included in the subgraph if
there is a path between <cite>starting_node</cite> and a CFGNode with the specified
address, and all nodes on the path should also be included in the subgraph.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A new CFG that only contain the specific subgraph.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#angr.analyses.cfg_accurate.CFGAccurate" title="angr.analyses.cfg_accurate.CFGAccurate">CFGAccurate</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg_accurate.CFGAccurate.get_function_subgraph">
<code class="descname">get_function_subgraph</code><span class="sig-paren">(</span><em>start</em>, <em>max_call_depth=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg_accurate.CFGAccurate.get_function_subgraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a sub-graph of a certain function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>start</strong> &#8211; The function start. Currently it should be an integer.</li>
<li><strong>max_call_depth</strong> &#8211; Call depth limit. None indicates no limit.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A CFG instance which is a sub-graph of self.graph</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="angr.analyses.cfg_accurate.CFGAccurate.unresolvables">
<code class="descname">unresolvables</code><a class="headerlink" href="#angr.analyses.cfg_accurate.CFGAccurate.unresolvables" title="Permalink to this definition">¶</a></dt>
<dd><p>Get those SimRuns that have non-resolvable exits.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A set of SimRuns</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">set</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="angr.analyses.cfg_accurate.CFGAccurate.deadends">
<code class="descname">deadends</code><a class="headerlink" href="#angr.analyses.cfg_accurate.CFGAccurate.deadends" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all CFGNodes that has an out-degree of 0</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A list of CFGNode instances</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.analyses.cfg_base"></span><dl class="class">
<dt id="angr.analyses.cfg_base.CFGBase">
<em class="property">class </em><code class="descclassname">angr.analyses.cfg_base.</code><code class="descname">CFGBase</code><span class="sig-paren">(</span><em>sort</em>, <em>context_sensitivity_level</em>, <em>normalize=False</em>, <em>binary=None</em>, <em>force_segment=False</em>, <em>iropt_level=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg_base.CFGBase" title="Permalink to this definition">¶</a></dt>
<dd><p>The base class for control flow graphs.</p>
<dl class="method">
<dt id="angr.analyses.cfg_base.CFGBase.make_copy">
<code class="descname">make_copy</code><span class="sig-paren">(</span><em>copy_to</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg_base.CFGBase.make_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy self attributes to the new object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>copy_to</strong> (<a class="reference internal" href="#angr.analyses.cfg_base.CFGBase" title="angr.analyses.cfg_base.CFGBase"><em>CFGBase</em></a>) &#8211; The target to copy to.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg_base.CFGBase.generate_index">
<code class="descname">generate_index</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg_base.CFGBase.generate_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an index of all nodes in the graph in order to speed up get_any_node() with anyaddr=True.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg_base.CFGBase.get_predecessors">
<code class="descname">get_predecessors</code><span class="sig-paren">(</span><em>cfgnode</em>, <em>excluding_fakeret=True</em>, <em>jumpkind=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg_base.CFGBase.get_predecessors" title="Permalink to this definition">¶</a></dt>
<dd><p>Get predecessors of a node in the control flow graph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>cfgnode</strong> (<a class="reference internal" href="#angr.analyses.cfg_node.CFGNode" title="angr.analyses.cfg_node.CFGNode"><em>CFGNode</em></a>) &#8211; The node.</li>
<li><strong>excluding_fakeret</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; True if you want to exclude all predecessors that is connected to the node
with a fakeret edge.</li>
<li><strong>or None jumpkind</strong> (<em>str</em>) &#8211; Only return predecessors with the specified jumpkind. This argument will be
ignored if set to None.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A list of predecessors</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg_base.CFGBase.get_successors">
<code class="descname">get_successors</code><span class="sig-paren">(</span><em>basic_block</em>, <em>excluding_fakeret=True</em>, <em>jumpkind=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg_base.CFGBase.get_successors" title="Permalink to this definition">¶</a></dt>
<dd><p>Get successors of a node in the control flow graph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>cfgnode</strong> (<a class="reference internal" href="#angr.analyses.cfg_node.CFGNode" title="angr.analyses.cfg_node.CFGNode"><em>CFGNode</em></a>) &#8211; The node.</li>
<li><strong>excluding_fakeret</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; True if you want to exclude all successors that is connected to the node
with a fakeret edge.</li>
<li><strong>or None jumpkind</strong> (<em>str</em>) &#8211; Only return successors with the specified jumpkind. This argument will be
ignored if set to None.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A list of successors</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg_base.CFGBase.get_all_predecessors">
<code class="descname">get_all_predecessors</code><span class="sig-paren">(</span><em>cfgnode</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg_base.CFGBase.get_all_predecessors" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all predecessors of a specific node on the control flow graph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cfgnode</strong> (<a class="reference internal" href="#angr.analyses.cfg_node.CFGNode" title="angr.analyses.cfg_node.CFGNode"><em>CFGNode</em></a>) &#8211; The CFGNode object</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A list of predecessors in the CFG</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg_base.CFGBase.get_node">
<code class="descname">get_node</code><span class="sig-paren">(</span><em>block_id</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg_base.CFGBase.get_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a single node from node key.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>block_id</strong> (<em>BlockID</em>) &#8211; Block ID of the node.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The CFGNode</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#angr.analyses.cfg_node.CFGNode" title="angr.analyses.cfg_node.CFGNode">CFGNode</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg_base.CFGBase.get_any_node">
<code class="descname">get_any_node</code><span class="sig-paren">(</span><em>addr</em>, <em>is_syscall=None</em>, <em>anyaddr=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg_base.CFGBase.get_any_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an arbitrary CFGNode (without considering their contexts) from our graph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>addr</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; Address of the beginning of the basic block. Set anyaddr to True to support arbitrary
address.</li>
<li><strong>is_syscall</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; Whether you want to get the syscall node or any other node. This is due to the fact that
syscall SimProcedures have the same address as the targer it returns to.
None means get either, True means get a syscall node, False means get something that isn&#8217;t
a syscall node.</li>
<li><strong>anyaddr</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; If anyaddr is True, then addr doesn&#8217;t have to be the beginning address of a basic
block. By default the entire graph.nodes() will be iterated, and the first node
containing the specific address is returned, which is slow. If you need to do many such
queries, you may first call <cite>generate_index()</cite> to create some indices that may speed up the
query.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A CFGNode if there is any that satisfies given conditions, or None otherwise</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg_base.CFGBase.irsb_from_node">
<code class="descname">irsb_from_node</code><span class="sig-paren">(</span><em>cfg_node</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg_base.CFGBase.irsb_from_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an IRSB from a CFGNode object.</p>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg_base.CFGBase.get_any_irsb">
<code class="descname">get_any_irsb</code><span class="sig-paren">(</span><em>addr</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg_base.CFGBase.get_any_irsb" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an IRSB of a certain address. If there are many IRSBs with the same address in CFG, return an arbitrary
one.
You should never assume this method returns a specific IRSB.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>addr</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; Address of the IRSB to get.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">An arbitrary IRSB located at <cite>addr</cite>.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">simuvex.IRSB</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg_base.CFGBase.get_all_nodes">
<code class="descname">get_all_nodes</code><span class="sig-paren">(</span><em>addr</em>, <em>is_syscall=None</em>, <em>anyaddr=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg_base.CFGBase.get_all_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all CFGNodes whose address is the specified one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>addr</strong> &#8211; Address of the node</li>
<li><strong>is_syscall</strong> &#8211; True returns the syscall node, False returns the normal CFGNode, None returns both</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">all CFGNodes</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg_base.CFGBase.nodes_iter">
<code class="descname">nodes_iter</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg_base.CFGBase.nodes_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>An iterator of all nodes in the graph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The iterator.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">iterator</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg_base.CFGBase.get_all_irsbs">
<code class="descname">get_all_irsbs</code><span class="sig-paren">(</span><em>addr</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg_base.CFGBase.get_all_irsbs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns all IRSBs of a certain address, without considering contexts.</p>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg_base.CFGBase.get_branching_nodes">
<code class="descname">get_branching_nodes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg_base.CFGBase.get_branching_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns all nodes that has an out degree &gt;= 2</p>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg_base.CFGBase.get_exit_stmt_idx">
<code class="descname">get_exit_stmt_idx</code><span class="sig-paren">(</span><em>src_block</em>, <em>dst_block</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg_base.CFGBase.get_exit_stmt_idx" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the corresponding exit statement ID for control flow to reach destination block from source block. The exit
statement ID was put on the edge when creating the CFG.
Note that there must be a direct edge between the two blocks, otherwise an exception will be raised.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The exit statement ID</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg_base.CFGBase.normalize">
<code class="descname">normalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg_base.CFGBase.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalize the CFG, making sure that there are no overlapping basic blocks.</p>
<p>Note that this method will not alter transition graphs of each function in self.kb.functions. You may call
normalize() on each Function object to normalize their transition graphs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg_base.CFGBase.remove_function_alignments">
<code class="descname">remove_function_alignments</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg_base.CFGBase.remove_function_alignments" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all function alignments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg_base.CFGBase.make_functions">
<code class="descname">make_functions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg_base.CFGBase.make_functions" title="Permalink to this definition">¶</a></dt>
<dd><p>Revisit the entire control flow graph, create Function instances accordingly, and correctly put blocks into
each function.</p>
<p>Although Function objects are crated during the CFG recovery, they are neither sound nor accurate. With a
pre-constructed CFG, this method rebuilds all functions bearing the following rules:</p>
<blockquote>
<div><ul class="simple">
<li>A block may only belong to one function.</li>
<li>Small functions lying inside the startpoint and the endpoint of another function will be merged with the
other function</li>
<li>Tail call optimizations are detected.</li>
<li>PLT stubs are aligned by 16.</li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.analyses.cfg_fast"></span><dl class="class">
<dt id="angr.analyses.cfg_fast.Segment">
<em class="property">class </em><code class="descclassname">angr.analyses.cfg_fast.</code><code class="descname">Segment</code><span class="sig-paren">(</span><em>start</em>, <em>end</em>, <em>sort</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg_fast.Segment" title="Permalink to this definition">¶</a></dt>
<dd><p>Representing a memory block. This is not the &#8220;Segment&#8221; in ELF memory model</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>start</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; Start address.</li>
<li><strong>end</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; End address.</li>
<li><strong>sort</strong> (<em>str</em>) &#8211; Type of the segment, can be code, data, etc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="angr.analyses.cfg_fast.Segment.size">
<code class="descname">size</code><a class="headerlink" href="#angr.analyses.cfg_fast.Segment.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the size of the Segment.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Size of the Segment.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int">int</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg_fast.Segment.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg_fast.Segment.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a copy of the Segment.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A copy of the Segment instance.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#angr.analyses.cfg_fast.Segment" title="angr.analyses.cfg_fast.Segment">angr.analyses.cfg_fast.Segment</a></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="angr.analyses.cfg_fast.SegmentList">
<em class="property">class </em><code class="descclassname">angr.analyses.cfg_fast.</code><code class="descname">SegmentList</code><a class="headerlink" href="#angr.analyses.cfg_fast.SegmentList" title="Permalink to this definition">¶</a></dt>
<dd><p>SegmentList describes a series of segmented memory blocks. You may query whether an address belongs to any of the
blocks or not, and obtain the exact block(segment) that the address belongs to.</p>
<dl class="method">
<dt id="angr.analyses.cfg_fast.SegmentList.next_free_pos">
<code class="descname">next_free_pos</code><span class="sig-paren">(</span><em>address</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg_fast.SegmentList.next_free_pos" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the next free position with respect to an address, including that address itself</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>address</strong> &#8211; The address to begin the search with (including itself)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The next free position</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg_fast.SegmentList.is_occupied">
<code class="descname">is_occupied</code><span class="sig-paren">(</span><em>address</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg_fast.SegmentList.is_occupied" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if an address belongs to any segment</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>address</strong> &#8211; The address to check</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if this address belongs to a segment, False otherwise</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg_fast.SegmentList.occupied_by_sort">
<code class="descname">occupied_by_sort</code><span class="sig-paren">(</span><em>address</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg_fast.SegmentList.occupied_by_sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if an address belongs to any segment, and if yes, returns the sort of the segment</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>address</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The address to check</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Sort of the segment that occupies this address</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg_fast.SegmentList.occupy">
<code class="descname">occupy</code><span class="sig-paren">(</span><em>address</em>, <em>size</em>, <em>sort</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg_fast.SegmentList.occupy" title="Permalink to this definition">¶</a></dt>
<dd><p>Include a block, specified by (address, size), in this segment list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>address</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The starting address of the block.</li>
<li><strong>size</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; Size of the block.</li>
<li><strong>sort</strong> (<em>str</em>) &#8211; Type of the block.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg_fast.SegmentList.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg_fast.SegmentList.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a copy of the SegmentList.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A copy of the SegmentList instance.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#angr.analyses.cfg_fast.SegmentList" title="angr.analyses.cfg_fast.SegmentList">angr.analyses.cfg_fast.SegmentList</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="angr.analyses.cfg_fast.SegmentList.occupied_size">
<code class="descname">occupied_size</code><a class="headerlink" href="#angr.analyses.cfg_fast.SegmentList.occupied_size" title="Permalink to this definition">¶</a></dt>
<dd><p>The sum of sizes of all blocks</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">An integer</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="angr.analyses.cfg_fast.SegmentList.has_blocks">
<code class="descname">has_blocks</code><a class="headerlink" href="#angr.analyses.cfg_fast.SegmentList.has_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns if this segment list has any block or not. !is_empty</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">True if it&#8217;s not empty, False otherwise</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="angr.analyses.cfg_fast.FunctionReturn">
<em class="property">class </em><code class="descclassname">angr.analyses.cfg_fast.</code><code class="descname">FunctionReturn</code><span class="sig-paren">(</span><em>callee_func_addr</em>, <em>caller_func_addr</em>, <em>call_site_addr</em>, <em>return_to</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg_fast.FunctionReturn" title="Permalink to this definition">¶</a></dt>
<dd><p>FunctionReturn describes a function call in a specific location and its return location. Hashable and equatable</p>
</dd></dl>

<dl class="class">
<dt id="angr.analyses.cfg_fast.MemoryData">
<em class="property">class </em><code class="descclassname">angr.analyses.cfg_fast.</code><code class="descname">MemoryData</code><span class="sig-paren">(</span><em>address</em>, <em>size</em>, <em>sort</em>, <em>irsb</em>, <em>irsb_addr</em>, <em>stmt</em>, <em>stmt_idx</em>, <em>pointer_addr=None</em>, <em>max_size=None</em>, <em>insn_addr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg_fast.MemoryData" title="Permalink to this definition">¶</a></dt>
<dd><p>MemoryData describes the syntactic contents of single address of memory along with a set of references to this
address (when not from previous instruction).</p>
<dl class="method">
<dt id="angr.analyses.cfg_fast.MemoryData.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg_fast.MemoryData.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a copy of the MemoryData.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A copy of the MemoryData instance.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#angr.analyses.cfg_fast.MemoryData" title="angr.analyses.cfg_fast.MemoryData">angr.analyses.cfg_fast.MemoryData</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg_fast.MemoryData.add_ref">
<code class="descname">add_ref</code><span class="sig-paren">(</span><em>irsb_addr</em>, <em>stmt_idx</em>, <em>insn_addr</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg_fast.MemoryData.add_ref" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a reference from code to this memory data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>irsb_addr</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; Address of the basic block.</li>
<li><strong>stmt_idx</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; ID of the statement referencing this data entry.</li>
<li><strong>insn_addr</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; Address of the instruction referencing this data entry.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="angr.analyses.cfg_fast.CFGJob">
<em class="property">class </em><code class="descclassname">angr.analyses.cfg_fast.</code><code class="descname">CFGJob</code><span class="sig-paren">(</span><em>addr</em>, <em>func_addr</em>, <em>jumpkind</em>, <em>ret_target=None</em>, <em>last_addr=None</em>, <em>src_node=None</em>, <em>src_ins_addr=None</em>, <em>src_stmt_idx=None</em>, <em>returning_source=None</em>, <em>syscall=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg_fast.CFGJob" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a job to work on during the CFG recovery</p>
</dd></dl>

<dl class="class">
<dt id="angr.analyses.cfg_fast.CFGFast">
<em class="property">class </em><code class="descclassname">angr.analyses.cfg_fast.</code><code class="descname">CFGFast</code><span class="sig-paren">(</span><em>binary=None</em>, <em>regions=None</em>, <em>pickle_intermediate_results=False</em>, <em>symbols=True</em>, <em>function_prologues=True</em>, <em>resolve_indirect_jumps=True</em>, <em>force_segment=False</em>, <em>force_complete_scan=True</em>, <em>indirect_jump_target_limit=100000</em>, <em>collect_data_references=False</em>, <em>extra_cross_references=False</em>, <em>normalize=False</em>, <em>function_starts=None</em>, <em>extra_memory_regions=None</em>, <em>data_type_guessing_handlers=None</em>, <em>arch_options=None</em>, <em>start=None</em>, <em>end=None</em>, <em>**extra_arch_options</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg_fast.CFGFast" title="Permalink to this definition">¶</a></dt>
<dd><p>We find functions inside the given binary, and build a control-flow graph in very fast manners: instead of
simulating program executions, keeping track of states, and performing expensive data-flow analysis, CFGFast will
only perform light-weight analyses combined with some heuristics, and with some strong assumptions.</p>
<p>In order to identify as many functions as possible, and as accurate as possible, the following operation sequence
is followed:</p>
<p># Active scanning</p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt>If the binary has &#8220;function symbols&#8221; (TODO: this term is not accurate enough), they are starting points of</dt>
<dd><p class="first last">the code scanning</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>If the binary does not have any &#8220;function symbol&#8221;, we will first perform a function prologue scanning on the</dt>
<dd><p class="first last">entire binary, and start from those places that look like function beginnings</p>
</dd>
</dl>
</li>
<li><p class="first">Otherwise, the binary&#8217;s entry point will be the starting point for scanning</p>
</li>
</ul>
</div></blockquote>
<p># Passive scanning</p>
<blockquote>
<div><ul class="simple">
<li>After all active scans are done, we will go through the whole image and scan all code pieces</li>
</ul>
</div></blockquote>
<p>Due to the nature of those techniques that are used here, a base address is often not required to use this analysis
routine. However, with a correct base address, CFG recovery will almost always yield a much better result. A custom
analysis, called GirlScout, is specifically made to recover the base address of a binary blob. After the base
address is determined, you may want to reload the binary with the new base address by creating a new Project object,
and then re-recover the CFG.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>binary</strong> &#8211; The binary to recover CFG on. By default the main binary is used.</li>
<li><strong>regions</strong> (<em>iterable</em>) &#8211; A list of tuples in the form of (start address, end address) describing memory
regions that the CFG should cover.</li>
<li><strong>pickle_intermediate_results</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; If we want to store the intermediate results or not.</li>
<li><strong>symbols</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; Get function beginnings from symbols in the binary.</li>
<li><strong>function_prologues</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; Scan the binary for function prologues, and use those positions as function
beginnings</li>
<li><strong>resolve_indirect_jumps</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; Try to resolve indirect jumps. This is necessary to resolve jump targets
from jump tables, etc.</li>
<li><strong>force_segment</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; Force CFGFast to rely on binary segments instead of sections.</li>
<li><strong>force_complete_scan</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; Perform a complete scan on the binary and maximize the number of identified
code blocks.</li>
<li><strong>collect_data_references</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; If CFGFast should collect data references from individual basic blocks or
not.</li>
<li><strong>extra_cross_references</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; True if we should collect data references for all places in the program
that access each memory data entry, which requires more memory, and is
noticeably slower. Setting it to False means each memory data entry has at
most one reference (which is the initial one).</li>
<li><strong>normalize</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; Normalize the CFG as well as all function graphs after CFG recovery.</li>
<li><strong>function_starts</strong> (<em>list</em>) &#8211; A list of extra function starting points. CFGFast will try to resume scanning
from each address in the list.</li>
<li><strong>extra_memory_regions</strong> (<em>list</em>) &#8211; A list of 2-tuple (start-address, end-address) that shows extra memory
regions. Integers falling inside will be considered as pointers.</li>
<li><strong>start</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; (Deprecated) The beginning address of CFG recovery.</li>
<li><strong>end</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; (Deprecated) The end address of CFG recovery.</li>
<li><strong>arch_options</strong> (<em>CFGArchOptions</em>) &#8211; Architecture-specific options.</li>
<li><strong>extra_arch_options</strong> (<em>dict</em>) &#8211; Any key-value pair in kwargs will be seen as an arch-specific option and will
be used to set the option value in self._arch_options.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Extra parameters that angr.Analysis takes:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>progress_callback</strong> &#8211; Specify a callback function to get the progress during CFG recovery.</li>
<li><strong>show_progressbar</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; Should CFGFast show a progressbar during CFG recovery or not.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="angr.analyses.cfg_fast.CFGFast.functions">
<code class="descname">functions</code><a class="headerlink" href="#angr.analyses.cfg_fast.CFGFast.functions" title="Permalink to this definition">¶</a></dt>
<dd><p>A collection of all functions in current CFG via FunctionManager</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">FunctionManager with all functions</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">angr.knowedge.function_manager.FunctionManager</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg_fast.CFGFast.generate_code_cover">
<code class="descname">generate_code_cover</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg_fast.CFGFast.generate_code_cover" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a list of all recovered basic blocks.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.analyses.cfg_node"></span><dl class="class">
<dt id="angr.analyses.cfg_node.CFGNode">
<em class="property">class </em><code class="descclassname">angr.analyses.cfg_node.</code><code class="descname">CFGNode</code><span class="sig-paren">(</span><em>addr</em>, <em>size</em>, <em>cfg</em>, <em>callstack=None</em>, <em>input_state=None</em>, <em>simprocedure_name=None</em>, <em>syscall_name=None</em>, <em>looping_times=0</em>, <em>no_ret=False</em>, <em>is_syscall=False</em>, <em>syscall=None</em>, <em>function_address=None</em>, <em>final_states=None</em>, <em>block_id=None</em>, <em>irsb=None</em>, <em>instruction_addrs=None</em>, <em>depth=None</em>, <em>callstack_key=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg_node.CFGNode" title="Permalink to this definition">¶</a></dt>
<dd><p>This class stands for each single node in CFG.</p>
<p>Note: simprocedure_name is not used to recreate the SimProcedure object. It&#8217;s only there for better
__repr__.</p>
<dl class="method">
<dt id="angr.analyses.cfg_node.CFGNode.downsize">
<code class="descname">downsize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg_node.CFGNode.downsize" title="Permalink to this definition">¶</a></dt>
<dd><p>Drop saved states.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.analyses.code_location"></span><dl class="class">
<dt id="angr.analyses.code_location.CodeLocation">
<em class="property">class </em><code class="descclassname">angr.analyses.code_location.</code><code class="descname">CodeLocation</code><span class="sig-paren">(</span><em>block_addr</em>, <em>stmt_idx</em>, <em>sim_procedure=None</em>, <em>ins_addr=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.code_location.CodeLocation" title="Permalink to this definition">¶</a></dt>
<dd><p>Stands for a specific program point by specifying basic block address and statement ID (for IRSBs), or SimProcedure
name (for SimProcedures).</p>
<p>Constructor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>block_addr</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; Address of the block</li>
<li><strong>stmt_idx</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; Statement ID. None for SimProcedures</li>
<li><strong>sim_procedure</strong> (<em>class</em>) &#8211; The corresponding SimProcedure class.</li>
<li><strong>ins_addr</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The instruction address. Optional.</li>
<li><strong>kwargs</strong> &#8211; Optional arguments, will be stored, but not used in __eq__ or __hash__.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<span class="target" id="module-angr.analyses.datagraph_meta"></span><span class="target" id="module-angr.analyses.ddg"></span><dl class="class">
<dt id="angr.analyses.ddg.ProgramVariable">
<em class="property">class </em><code class="descclassname">angr.analyses.ddg.</code><code class="descname">ProgramVariable</code><span class="sig-paren">(</span><em>variable</em>, <em>location</em>, <em>initial=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.ddg.ProgramVariable" title="Permalink to this definition">¶</a></dt>
<dd><p>Describes a variable in the program at a specific location.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>variable</strong> (<em>SimVariable</em>) &#8211; The variable.</li>
<li><strong>location</strong> (<a class="reference internal" href="#angr.analyses.code_location.CodeLocation" title="angr.analyses.code_location.CodeLocation"><em>CodeLocation</em></a>) &#8211; Location of the variable.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="angr.analyses.ddg.LiveDefinitions">
<em class="property">class </em><code class="descclassname">angr.analyses.ddg.</code><code class="descname">LiveDefinitions</code><a class="headerlink" href="#angr.analyses.ddg.LiveDefinitions" title="Permalink to this definition">¶</a></dt>
<dd><p>A collection of live definitions with some handy interfaces for definition killing and lookups.</p>
<p>Constructor.</p>
<dl class="method">
<dt id="angr.analyses.ddg.LiveDefinitions.branch">
<code class="descname">branch</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.ddg.LiveDefinitions.branch" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a branch of the current live definition collection.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A new LiveDefinition instance.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#angr.analyses.ddg.LiveDefinitions" title="angr.analyses.ddg.LiveDefinitions">LiveDefinitions</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.ddg.LiveDefinitions.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.ddg.LiveDefinitions.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a hard copy of <cite>self</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A new LiveDefinition instance.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#angr.analyses.ddg.LiveDefinitions" title="angr.analyses.ddg.LiveDefinitions">LiveDefinitions</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.ddg.LiveDefinitions.add_def">
<code class="descname">add_def</code><span class="sig-paren">(</span><em>variable</em>, <em>location</em>, <em>size_threshold=32</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.ddg.LiveDefinitions.add_def" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a new definition of variable.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> (<em>SimVariable</em>) &#8211; The variable being defined.</li>
<li><strong>location</strong> (<a class="reference internal" href="#angr.analyses.code_location.CodeLocation" title="angr.analyses.code_location.CodeLocation"><em>CodeLocation</em></a>) &#8211; Location of the varaible being defined.</li>
<li><strong>size_threshold</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The maximum bytes to consider for the variable.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">True if the definition was new, False otherwise</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool">bool</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.ddg.LiveDefinitions.add_defs">
<code class="descname">add_defs</code><span class="sig-paren">(</span><em>variable</em>, <em>locations</em>, <em>size_threshold=32</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.ddg.LiveDefinitions.add_defs" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a collection of new definitions of a variable.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> (<em>SimVariable</em>) &#8211; The variable being defined.</li>
<li><strong>locations</strong> (<em>iterable</em>) &#8211; A collection of locations where the variable was defined.</li>
<li><strong>size_threshold</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The maximum bytes to consider for the variable.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">True if any of the definition was new, False otherwise</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool">bool</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.ddg.LiveDefinitions.kill_def">
<code class="descname">kill_def</code><span class="sig-paren">(</span><em>variable</em>, <em>location</em>, <em>size_threshold=32</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.ddg.LiveDefinitions.kill_def" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a new definition for variable and kill all previous definitions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> (<em>SimVariable</em>) &#8211; The variable to kill.</li>
<li><strong>location</strong> (<a class="reference internal" href="#angr.analyses.code_location.CodeLocation" title="angr.analyses.code_location.CodeLocation"><em>CodeLocation</em></a>) &#8211; The location where this variable is defined.</li>
<li><strong>size_threshold</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The maximum bytes to consider for the variable.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.ddg.LiveDefinitions.lookup_defs">
<code class="descname">lookup_defs</code><span class="sig-paren">(</span><em>variable</em>, <em>size_threshold=32</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.ddg.LiveDefinitions.lookup_defs" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all definitions of the varaible</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> (<em>SimVariable</em>) &#8211; The variable to lookup for.</li>
<li><strong>size_threshold</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The maximum bytes to consider for the variable. For example, if the variable is 100
byte long, only the first <cite>size_threshold</cite> bytes are considered.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A set of code locations where the variable is defined.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">set</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.ddg.LiveDefinitions.iteritems">
<code class="descname">iteritems</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.ddg.LiveDefinitions.iteritems" title="Permalink to this definition">¶</a></dt>
<dd><p>An iterator that returns all live definitions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The iterator.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">iter</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.ddg.LiveDefinitions.itervariables">
<code class="descname">itervariables</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.ddg.LiveDefinitions.itervariables" title="Permalink to this definition">¶</a></dt>
<dd><p>An iterator that returns all live variables.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The iterator.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">iter</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="angr.analyses.ddg.DDG">
<em class="property">class </em><code class="descclassname">angr.analyses.ddg.</code><code class="descname">DDG</code><span class="sig-paren">(</span><em>cfg</em>, <em>start=None</em>, <em>call_depth=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.ddg.DDG" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a fast data dependence graph directly generated from our CFG analysis result. The only reason for its
existence is the speed. There is zero guarantee for being sound or accurate. You are supposed to use it only when
you want to track the simplest data dependence, and you do not care about soundness or accuracy.</p>
<p>For a better data dependence graph, please consider performing a better static analysis first (like Value-set
Analysis), and then construct a dependence graph on top of the analysis result (for example, the VFG in angr).</p>
<p>Also note that since we are using states from CFG, any improvement in analysis performed on CFG (like a points-to
analysis) will directly benefit the DDG.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cfg</strong> &#8211; Control flow graph. Please make sure each node has an associated <cite>state</cite> with it. You may
want to generate your CFG with <cite>keep_state=True</cite>.</li>
<li><strong>start</strong> &#8211; An address, Specifies where we start the generation of this data dependence graph.</li>
<li><strong>call_depth</strong> &#8211; None or integers. A non-negative integer specifies how deep we would like to track in the
call tree. None disables call_depth limit.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="angr.analyses.ddg.DDG.graph">
<code class="descname">graph</code><a class="headerlink" href="#angr.analyses.ddg.DDG.graph" title="Permalink to this definition">¶</a></dt>
<dd><p><em>returns</em> &#8211; A networkx DiGraph instance representing the dependence relations between statements.
:rtype: networkx.DiGraph</p>
</dd></dl>

<dl class="attribute">
<dt id="angr.analyses.ddg.DDG.data_graph">
<code class="descname">data_graph</code><a class="headerlink" href="#angr.analyses.ddg.DDG.data_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the data dependence graph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A networkx DiGraph instance representing data dependence.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">networkx.DiGraph</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="angr.analyses.ddg.DDG.simplified_data_graph">
<code class="descname">simplified_data_graph</code><a class="headerlink" href="#angr.analyses.ddg.DDG.simplified_data_graph" title="Permalink to this definition">¶</a></dt>
<dd><p><em>return</em></p>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.ddg.DDG.pp">
<code class="descname">pp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.ddg.DDG.pp" title="Permalink to this definition">¶</a></dt>
<dd><p>Pretty printing.</p>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.ddg.DDG.dbg_repr">
<code class="descname">dbg_repr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.ddg.DDG.dbg_repr" title="Permalink to this definition">¶</a></dt>
<dd><p>Representation for debugging.</p>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.ddg.DDG.get_predecessors">
<code class="descname">get_predecessors</code><span class="sig-paren">(</span><em>code_location</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.ddg.DDG.get_predecessors" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns all predecessors of the code location.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>code_location</strong> &#8211; A CodeLocation instance.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A list of all predecessors.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.ddg.DDG.function_dependency_graph">
<code class="descname">function_dependency_graph</code><span class="sig-paren">(</span><em>func</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.ddg.DDG.function_dependency_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dependency graph for the function <cite>func</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>func</strong> &#8211; The Function object in CFG.function_manager.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A networkx.DiGraph instance.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.ddg.DDG.data_sub_graph">
<code class="descname">data_sub_graph</code><span class="sig-paren">(</span><em>pv</em>, <em>simplified=True</em>, <em>killing_edges=False</em>, <em>excluding_types=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.ddg.DDG.data_sub_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a subgraph from the data graph or the simplified data graph that starts from node pv.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>pv</strong> (<a class="reference internal" href="#angr.analyses.ddg.ProgramVariable" title="angr.analyses.ddg.ProgramVariable"><em>ProgramVariable</em></a>) &#8211; The starting point of the subgraph.</li>
<li><strong>simplified</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; When True, the simplified data graph is used, otherwise the data graph is used.</li>
<li><strong>killing_edges</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; Are killing edges included or not.</li>
<li><strong>excluding_types</strong> (<em>iterable</em>) &#8211; Excluding edges whose types are among those excluded types.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A subgraph.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">networkx.MultiDiGraph</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.ddg.DDG.find_definitions">
<code class="descname">find_definitions</code><span class="sig-paren">(</span><em>variable</em>, <em>simplified_graph=True</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.ddg.DDG.find_definitions" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all definitions of the given variable.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> (<em>SimVariable</em>) &#8211; </li>
<li><strong>simplified_graph</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; True if you just want to search in the simplified graph instead of the normal
graph. Usually the simplified graph suffices for finding definitions of register
or memory variables.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A collection of all variable definitions to the specific variable.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.ddg.DDG.find_consumers">
<code class="descname">find_consumers</code><span class="sig-paren">(</span><em>var_def</em>, <em>simplified_graph=True</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.ddg.DDG.find_consumers" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all consumers to the specified variable definition.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>var_def</strong> (<a class="reference internal" href="#angr.analyses.ddg.ProgramVariable" title="angr.analyses.ddg.ProgramVariable"><em>ProgramVariable</em></a>) &#8211; The variable definition.</li>
<li><strong>simplified_graph</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; True if we want to search in the simplified graph, False otherwise.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A collection of all consumers to the specified variable definition.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.ddg.DDG.find_killers">
<code class="descname">find_killers</code><span class="sig-paren">(</span><em>var_def</em>, <em>simplified_graph=True</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.ddg.DDG.find_killers" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all killers to the specified variable definition.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>var_def</strong> (<a class="reference internal" href="#angr.analyses.ddg.ProgramVariable" title="angr.analyses.ddg.ProgramVariable"><em>ProgramVariable</em></a>) &#8211; The variable definition.</li>
<li><strong>simplified_graph</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; True if we want to search in the simplified graph, False otherwise.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A collection of all killers to the specified variable definition.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.ddg.DDG.find_sources">
<code class="descname">find_sources</code><span class="sig-paren">(</span><em>var_def</em>, <em>simplified_graph=True</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.ddg.DDG.find_sources" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all sources to the specified variable definition.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>var_def</strong> (<a class="reference internal" href="#angr.analyses.ddg.ProgramVariable" title="angr.analyses.ddg.ProgramVariable"><em>ProgramVariable</em></a>) &#8211; The variable definition.</li>
<li><strong>simplified_graph</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; True if we want to search in the simplified graph, False otherwise.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A collection of all sources to the specified variable definition.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.analyses.dfg"></span><span class="target" id="module-angr.analyses.forward_analysis"></span><dl class="class">
<dt id="angr.analyses.forward_analysis.EntryInfo">
<em class="property">class </em><code class="descclassname">angr.analyses.forward_analysis.</code><code class="descname">EntryInfo</code><span class="sig-paren">(</span><em>key</em>, <em>entry</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.forward_analysis.EntryInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Stores information for each entry</p>
<dl class="attribute">
<dt id="angr.analyses.forward_analysis.EntryInfo.entry">
<code class="descname">entry</code><a class="headerlink" href="#angr.analyses.forward_analysis.EntryInfo.entry" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the latest available entry.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The latest available entry.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.forward_analysis.EntryInfo.add_entry">
<code class="descname">add_entry</code><span class="sig-paren">(</span><em>entry</em>, <em>merged=False</em>, <em>widened=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.forward_analysis.EntryInfo.add_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>Appended a new entry to this EntryInfo node.
:param entry: The new entry to append
:param bool merged: Whether it is a merged entry or not.
:param bool widened: Whether it is a widened entry or not.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="angr.analyses.forward_analysis.ForwardAnalysis">
<em class="property">class </em><code class="descclassname">angr.analyses.forward_analysis.</code><code class="descname">ForwardAnalysis</code><span class="sig-paren">(</span><em>order_entries=False</em>, <em>allow_merging=False</em>, <em>allow_widening=False</em>, <em>status_callback=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.forward_analysis.ForwardAnalysis" title="Permalink to this definition">¶</a></dt>
<dd><p>This is my very first attempt to build a static forward analysis framework that can serve as the base of multiple
static analyses in angr, including CFG analysis, VFG analysis, DDG, etc.</p>
<p>In short, ForwardAnalysis performs a forward data-flow analysis by traversing the CFG (or the binary if a CFG is
not available) and generating a graph with nodes linked with each program point (usually per basic-block, or SimRun
in angr terms). A node on the graph stores analysis-specific information. For more information about nodes, take a
look at the implementation of CFGNode.</p>
<p>Feel free to discuss with me (Fish) if you have any suggestion or complaint!</p>
<p>Constructor</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>order_entries</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; If all entries should be ordered or not.</li>
<li><strong>allow_merging</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; If entry merging is allowed.</li>
<li><strong>allow_widening</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; If entry widening is allowed.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="angr.analyses.forward_analysis.ForwardAnalysis.should_abort">
<code class="descname">should_abort</code><a class="headerlink" href="#angr.analyses.forward_analysis.ForwardAnalysis.should_abort" title="Permalink to this definition">¶</a></dt>
<dd><p>Should the analysis be terminated.
:return: True/False</p>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.forward_analysis.ForwardAnalysis.abort">
<code class="descname">abort</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.forward_analysis.ForwardAnalysis.abort" title="Permalink to this definition">¶</a></dt>
<dd><p>Abort the analysis
:return: None</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.analyses.girlscout"></span><dl class="class">
<dt id="angr.analyses.girlscout.GirlScout">
<em class="property">class </em><code class="descclassname">angr.analyses.girlscout.</code><code class="descname">GirlScout</code><span class="sig-paren">(</span><em>binary=None</em>, <em>start=None</em>, <em>end=None</em>, <em>pickle_intermediate_results=False</em>, <em>perform_full_code_scan=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.girlscout.GirlScout" title="Permalink to this definition">¶</a></dt>
<dd><p>We find functions inside the given binary, try to decide the base address if needed, and build a control-flow
graph on top of that to see if there is an entry or not. Obviously if the binary is not loaded as a blob (not
using Blob as its backend), GirlScout will not try to determine the base address.</p>
<p>It&#8217;s also optional to perform a full code scan of the binary to show where all codes are. By default we don&#8217;t scan
the entire binary since it&#8217;s time consuming.</p>
<p>You probably need a BoyScout to determine the possible architecture and endianess of your binary blob.</p>
<dl class="method">
<dt id="angr.analyses.girlscout.GirlScout.genenare_callmap_sif">
<code class="descname">genenare_callmap_sif</code><span class="sig-paren">(</span><em>filepath</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.girlscout.GirlScout.genenare_callmap_sif" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a sif file from the call map</p>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.girlscout.GirlScout.generate_code_cover">
<code class="descname">generate_code_cover</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.girlscout.GirlScout.generate_code_cover" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a list of all recovered basic blocks.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.analyses.loopfinder"></span><dl class="class">
<dt id="angr.analyses.loopfinder.LoopFinder">
<em class="property">class </em><code class="descclassname">angr.analyses.loopfinder.</code><code class="descname">LoopFinder</code><span class="sig-paren">(</span><em>functions=None</em>, <em>normalize=True</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.loopfinder.LoopFinder" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts all the loops from all the functions in a binary.</p>
</dd></dl>

<span class="target" id="module-angr.analyses.veritesting"></span><span class="target" id="module-angr.analyses.vfg"></span><dl class="class">
<dt id="angr.analyses.vfg.VFGJob">
<em class="property">class </em><code class="descclassname">angr.analyses.vfg.</code><code class="descname">VFGJob</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.vfg.VFGJob" title="Permalink to this definition">¶</a></dt>
<dd><p>An EntryWrapper that contains vfg local variables</p>
</dd></dl>

<dl class="class">
<dt id="angr.analyses.vfg.AnalysisTask">
<em class="property">class </em><code class="descclassname">angr.analyses.vfg.</code><code class="descname">AnalysisTask</code><a class="headerlink" href="#angr.analyses.vfg.AnalysisTask" title="Permalink to this definition">¶</a></dt>
<dd><p>An analysis task describes a task that should be done before popping this task out of the task stack and discard it.</p>
</dd></dl>

<dl class="class">
<dt id="angr.analyses.vfg.FunctionAnalysis">
<em class="property">class </em><code class="descclassname">angr.analyses.vfg.</code><code class="descname">FunctionAnalysis</code><span class="sig-paren">(</span><em>function_address</em>, <em>return_address</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.vfg.FunctionAnalysis" title="Permalink to this definition">¶</a></dt>
<dd><p>Analyze a function, generate fix-point states from all endpoints of that function, and then merge them to one state.</p>
</dd></dl>

<dl class="class">
<dt id="angr.analyses.vfg.CallAnalysis">
<em class="property">class </em><code class="descclassname">angr.analyses.vfg.</code><code class="descname">CallAnalysis</code><span class="sig-paren">(</span><em>address</em>, <em>return_address</em>, <em>function_analysis_tasks=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.vfg.CallAnalysis" title="Permalink to this definition">¶</a></dt>
<dd><p>Analyze a call by analyze all functions this call might be calling, collect all final states generated by analyzing
those functions, and merge them into one state.</p>
</dd></dl>

<dl class="class">
<dt id="angr.analyses.vfg.VFGNode">
<em class="property">class </em><code class="descclassname">angr.analyses.vfg.</code><code class="descname">VFGNode</code><span class="sig-paren">(</span><em>addr</em>, <em>key</em>, <em>state=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.vfg.VFGNode" title="Permalink to this definition">¶</a></dt>
<dd><p>A descriptor of nodes in a Value-Flow Graph</p>
<p>Constructor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>addr</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; </li>
<li><strong>key</strong> (<em>BlockID</em>) &#8211; </li>
<li><strong>state</strong> (<em>simuvex.SimState</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="angr.analyses.vfg.VFGNode.append_state">
<code class="descname">append_state</code><span class="sig-paren">(</span><em>s</em>, <em>is_widened_state=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.vfg.VFGNode.append_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Appended a new state to this VFGNode.
:param s: The new state to append
:param is_widened_state: Whether it is a widened state or not.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="angr.analyses.vfg.VFG">
<em class="property">class </em><code class="descclassname">angr.analyses.vfg.</code><code class="descname">VFG</code><span class="sig-paren">(</span><em>cfg=None</em>, <em>context_sensitivity_level=2</em>, <em>start=None</em>, <em>function_start=None</em>, <em>interfunction_level=0</em>, <em>initial_state=None</em>, <em>avoid_runs=None</em>, <em>remove_options=None</em>, <em>timeout=None</em>, <em>max_iterations_before_widening=8</em>, <em>max_iterations=40</em>, <em>widening_interval=3</em>, <em>final_state_callback=None</em>, <em>status_callback=None</em>, <em>record_function_final_states=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.vfg.VFG" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents a control-flow graph with static analysis result.</p>
<p>Perform abstract interpretation analysis starting from the given function address. The output is an invariant at
the beginning (or the end) of each basic block.</p>
<p>Steps:</p>
<blockquote>
<div><ul>
<li><p class="first">Generate a CFG first if CFG is not provided.</p>
</li>
<li><p class="first">Identify all merge points (denote the set of merge points as Pw) in the CFG.</p>
</li>
<li><p class="first">Cut those loop back edges (can be derived from Pw) so that we gain an acyclic CFG.</p>
</li>
<li><dl class="first docutils">
<dt>Identify all variables that are 1) from memory loading 2) from initial values, or 3) phi functions. Denote</dt>
<dd><p class="first last">the set of those variables as S_{var}.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Start real AI analysis and try to compute a fix point of each merge point. Perform widening/narrowing only on</dt>
<dd><p class="first last">variables in S_{var}.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cfg</strong> &#8211; The control-flow graph to base this analysis on. If none is provided, we will
construct a CFGAccurate.</li>
<li><strong>context_sensitivity_level</strong> &#8211; The level of context-sensitivity of this VFG.
It ranges from 0 to infinity. Default 2.</li>
<li><strong>function_start</strong> &#8211; The address of the function to analyze.</li>
<li><strong>interfunction_level</strong> &#8211; The level of interfunction-ness to be</li>
<li><strong>initial_state</strong> &#8211; A state to use as the initial one</li>
<li><strong>avoid_runs</strong> &#8211; A list of runs to avoid</li>
<li><strong>remove_options</strong> &#8211; State options to remove from the initial state. It only works when <cite>initial_state</cite> is
None</li>
<li><strong>timeout</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="angr.analyses.vfg.VFG.get_any_node">
<code class="descname">get_any_node</code><span class="sig-paren">(</span><em>addr</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.vfg.VFG.get_any_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Get any VFG node corresponding to the basic block at &#64;addr.
Note that depending on the context sensitivity level, there might be
multiple nodes corresponding to different contexts. This function will
return the first one it encounters, which might not be what you want.</p>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.vfg.VFG.get_paths">
<code class="descname">get_paths</code><span class="sig-paren">(</span><em>begin</em>, <em>end</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.vfg.VFG.get_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all the simple paths between &#64;begin and &#64;end.
Returns: a list of angr.Path instances.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.analyses.vsa_ddg"></span><dl class="class">
<dt id="angr.analyses.vsa_ddg.DefUseChain">
<em class="property">class </em><code class="descclassname">angr.analyses.vsa_ddg.</code><code class="descname">DefUseChain</code><span class="sig-paren">(</span><em>def_loc</em>, <em>use_loc</em>, <em>variable</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.vsa_ddg.DefUseChain" title="Permalink to this definition">¶</a></dt>
<dd><p>Stand for a def-use chain. it is generated by the DDG itself.</p>
<p>Constructor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>def_loc</strong> &#8211; </li>
<li><strong>use_loc</strong> &#8211; </li>
<li><strong>variable</strong> &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="angr.analyses.vsa_ddg.VSA_DDG">
<em class="property">class </em><code class="descclassname">angr.analyses.vsa_ddg.</code><code class="descname">VSA_DDG</code><span class="sig-paren">(</span><em>vfg=None</em>, <em>start_addr=None</em>, <em>interfunction_level=0</em>, <em>context_sensitivity_level=2</em>, <em>keep_data=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.vsa_ddg.VSA_DDG" title="Permalink to this definition">¶</a></dt>
<dd><p>A Data dependency graph based on VSA states.
That means we don&#8217;t (and shouldn&#8217;t) expect any symbolic expressions.</p>
<p>Constructor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>vfg</strong> &#8211; An already constructed VFG. If not specified, a new VFG will be created with other
specified parameters. <cite>vfg</cite> and <cite>start_addr</cite> cannot both be unspecified.</li>
<li><strong>start_addr</strong> &#8211; The address where to start the analysis (typically, a function&#8217;s entry point).</li>
<li><strong>interfunction_level</strong> &#8211; See VFG analysis.</li>
<li><strong>context_sensitivity_level</strong> &#8211; See VFG analysis.</li>
<li><strong>keep_data</strong> &#8211; Whether we keep set of addresses as edges in the graph, or just the cardinality of
the sets, which can be used as a &#8220;weight&#8221;.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="angr.analyses.vsa_ddg.VSA_DDG.get_predecessors">
<code class="descname">get_predecessors</code><span class="sig-paren">(</span><em>code_location</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.vsa_ddg.VSA_DDG.get_predecessors" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns all predecessors of <cite>code_location</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>code_location</strong> &#8211; A CodeLocation instance.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A list of all predecessors.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.vsa_ddg.VSA_DDG.get_all_nodes">
<code class="descname">get_all_nodes</code><span class="sig-paren">(</span><em>simrun_addr</em>, <em>stmt_idx</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.vsa_ddg.VSA_DDG.get_all_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all DDG nodes matching the given basic block address and statement index.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-angr.simos">
<span id="simos"></span><h2>SimOS<a class="headerlink" href="#module-angr.simos" title="Permalink to this headline">¶</a></h2>
<p>Manage OS-level configuration.</p>
<dl class="class">
<dt id="angr.simos.SyscallEntry">
<em class="property">class </em><code class="descclassname">angr.simos.</code><code class="descname">SyscallEntry</code><span class="sig-paren">(</span><em>name</em>, <em>pseudo_addr</em>, <em>simproc</em>, <em>supported=True</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.simos.SyscallEntry" title="Permalink to this definition">¶</a></dt>
<dd><p>Describes a syscall.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><a class="reference internal" href="claripy.html#claripy.backends.Backend.name" title="claripy.backends.Backend.name"><strong>name</strong></a> (<em>str</em>) &#8211; Name of the syscall.</li>
<li><strong>pseudo_addr</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The pseudo address assigned to this syscall.</li>
<li><strong>simproc</strong> &#8211; The SimProcedure class for handling this syscall.</li>
<li><strong>supported</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; True if this syscall is defined and has a SimProcedure implemented, False otherwise.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Constructor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) &#8211; Syscall name.</li>
<li><strong>pseudo_addr</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The pseudo address assigned to this syscall.</li>
<li><strong>simproc</strong> &#8211; The SimProcedure for handling this syscall.</li>
<li><strong>supported</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; True if this syscall is defined and there is a SimProcedure implemented for it.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="angr.simos.SyscallTable">
<em class="property">class </em><code class="descclassname">angr.simos.</code><code class="descname">SyscallTable</code><span class="sig-paren">(</span><em>max_syscall_number=None</em>, <em>unknown_syscall_number=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.simos.SyscallTable" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a syscall table.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>max_syscall_number</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The maximum syscall number of all supported syscalls in the platform.</li>
<li><strong>unknown_syscall_number</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The syscall number of the &#8220;unknown&#8221; syscall used for unsupported syscalls.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Constructor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>or None max_syscall_number</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The maximum syscall number of all supported syscalls in the platform.</li>
<li><strong>unknown_syscall_number</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The syscall number to use for unknown/undefined syscalls.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="angr.simos.SyscallTable.max_syscall">
<code class="descname">max_syscall</code><a class="headerlink" href="#angr.simos.SyscallTable.max_syscall" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the maximum syscall number, or None if the syscall table is empty and <cite>max_syscall_number</cite> is not set..</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The syscall number.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">int or None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="angr.simos.SyscallTable.unknown_syscall">
<code class="descname">unknown_syscall</code><a class="headerlink" href="#angr.simos.SyscallTable.unknown_syscall" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the &#8220;unknown&#8221; syscall entry.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The syscall entry for unknown syscalls.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#angr.simos.SyscallEntry" title="angr.simos.SyscallEntry">SyscallEntry</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.simos.SyscallTable.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.simos.SyscallTable.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear all defined syscalls.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.simos.SyscallTable.supports">
<code class="descname">supports</code><span class="sig-paren">(</span><em>syscall_number</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.simos.SyscallTable.supports" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the syscall number is defined and supported.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>syscall_number</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The number of syscall to check.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if the syscall number is defined and supported by angr, False otherwise</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool">bool</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.simos.SyscallTable.get_by_addr">
<code class="descname">get_by_addr</code><span class="sig-paren">(</span><em>addr</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.simos.SyscallTable.get_by_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a syscall by the pseudo address.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>addr</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The pseudo address assigned to the syscall.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The syscall instance if the pseudo address is assigned to a syscall, or None otherwise.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">SyscallEntry or None</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="angr.simos.SimOS">
<em class="property">class </em><code class="descclassname">angr.simos.</code><code class="descname">SimOS</code><span class="sig-paren">(</span><em>project</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.simos.SimOS" title="Permalink to this definition">¶</a></dt>
<dd><p>A class describing OS/arch-level configuration.</p>
<dl class="method">
<dt id="angr.simos.SimOS.syscall_info">
<code class="descname">syscall_info</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.simos.SimOS.syscall_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Get information about the syscall that is about to be called. Note that symbolic syscalls are not supported -
the syscall number <em>must</em> have only one solution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>state</strong> (<a class="reference internal" href="simuvex.html#simuvex.s_state.SimState" title="simuvex.s_state.SimState"><em>simuvex.s_state.SimState</em></a>) &#8211; the program state.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A tuple of (cc, syscall_addr, syscall_name, syscall_class)</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">tuple</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.simos.SimOS.handle_syscall">
<code class="descname">handle_syscall</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.simos.SimOS.handle_syscall" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle a state whose immediate preceding jumpkind is syscall by creating a new SimRun. Note that symbolic
syscalls are not supported - the syscall number <em>must</em> have only one solution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>state</strong> (<a class="reference internal" href="simuvex.html#simuvex.s_state.SimState" title="simuvex.s_state.SimState"><em>simuvex.s_state.SimState</em></a>) &#8211; the program state.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">an instanciated, but not executed SimProcedure for this syscall</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="simuvex.html#simuvex.s_procedure.SimProcedure" title="simuvex.s_procedure.SimProcedure">simuvex.s_procedure.SimProcedure</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.simos.SimOS.configure_project">
<code class="descname">configure_project</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.simos.SimOS.configure_project" title="Permalink to this definition">¶</a></dt>
<dd><p>Configure the project to set up global settings (like SimProcedures).</p>
</dd></dl>

<dl class="method">
<dt id="angr.simos.SimOS.state_blank">
<code class="descname">state_blank</code><span class="sig-paren">(</span><em>addr=None</em>, <em>initial_prefix=None</em>, <em>stack_size=8388608</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.simos.SimOS.state_blank" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a blank state.</p>
<p>All parameters are optional.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>addr</strong> &#8211; The execution start address.</li>
<li><strong>initial_prefix</strong> &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The initialized SimState.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">simuvex.SimState</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.simos.SimOS.prepare_call_state">
<code class="descname">prepare_call_state</code><span class="sig-paren">(</span><em>calling_state</em>, <em>initial_state=None</em>, <em>preserve_registers=()</em>, <em>preserve_memory=()</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.simos.SimOS.prepare_call_state" title="Permalink to this definition">¶</a></dt>
<dd><p>This function prepares a state that is executing a call instruction.
If given an initial_state, it copies over all of the critical registers to it from the
calling_state. Otherwise, it prepares the calling_state for action.</p>
<p>This is mostly used to create minimalistic for CFG generation. Some ABIs, such as MIPS PIE and
x86 PIE, require certain information to be maintained in certain registers. For example, for
PIE MIPS, this function transfer t9, gp, and ra to the new state.</p>
</dd></dl>

<dl class="method">
<dt id="angr.simos.SimOS.prepare_function_symbol">
<code class="descname">prepare_function_symbol</code><span class="sig-paren">(</span><em>symbol_name</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.simos.SimOS.prepare_function_symbol" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare the address space with the data necessary to perform relocations pointing to the given symbol</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="angr.simos.SimLinux">
<em class="property">class </em><code class="descclassname">angr.simos.</code><code class="descname">SimLinux</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.simos.SimLinux" title="Permalink to this definition">¶</a></dt>
<dd><p>OS-specific configuration for *nix-y OSes.</p>
<dl class="method">
<dt id="angr.simos.SimLinux.prepare_function_symbol">
<code class="descname">prepare_function_symbol</code><span class="sig-paren">(</span><em>symbol_name</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.simos.SimLinux.prepare_function_symbol" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare the address space with the data necessary to perform relocations pointing to the given symbol.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="surveyors">
<h2>Surveyors<a class="headerlink" href="#surveyors" title="Permalink to this headline">¶</a></h2>
<p>Do not use surveyors. They are a legacy interface.</p>
<span class="target" id="module-angr.surveyor"></span><dl class="class">
<dt id="angr.surveyor.Surveyor">
<em class="property">class </em><code class="descclassname">angr.surveyor.</code><code class="descname">Surveyor</code><span class="sig-paren">(</span><em>project</em>, <em>start=None</em>, <em>max_active=None</em>, <em>max_concurrency=None</em>, <em>pickle_paths=None</em>, <em>save_deadends=None</em>, <em>enable_veritesting=False</em>, <em>veritesting_options=None</em>, <em>keep_pruned=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.surveyor.Surveyor" title="Permalink to this definition">¶</a></dt>
<dd><p>The surveyor class eases the implementation of symbolic analyses. This
provides a base upon which analyses can be implemented.</p>
<p>Surveyors provide at least the following members:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>active</strong> &#8211; The paths that are still active in the analysis.</li>
<li><strong>deadended</strong> &#8211; The paths that are still active in the analysis.</li>
<li><strong>spilled</strong> &#8211; The paths that are still active in the analysis.</li>
<li><strong>errored</strong> &#8211; The paths that have at least one error-state exit.</li>
<li><strong>pruned</strong> &#8211; The paths that were pruned because their ancestors were unsat.</li>
<li><strong>unconstrained</strong> &#8211; The paths that have a successor with an unconstrained instruction pointer.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>A Surveryor has the following overloadable properties:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><a class="reference internal" href="#angr.surveyor.Surveyor.done" title="angr.surveyor.Surveyor.done"><strong>done</strong></a> &#8211; returns True if the analysis is done (by default, this is when self.active is empty).</li>
<li><a class="reference internal" href="#angr.surveyor.Surveyor.run" title="angr.surveyor.Surveyor.run"><strong>run</strong></a> &#8211; runs a loop of tick()ing and spill()ing until self.done is True.</li>
<li><a class="reference internal" href="#angr.surveyor.Surveyor.tick" title="angr.surveyor.Surveyor.tick"><strong>tick</strong></a> &#8211; ticks all paths forward. The default implementation calls tick_path() on every path.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>A Surveyor has the following overloadable functions :</p>
<p><a class="reference internal" href="#angr.surveyor.Surveyor.tick_path" title="angr.surveyor.Surveyor.tick_path"><code class="xref py py-func docutils literal"><span class="pre">tick_path()</span></code></a> moves a provided path forward, returning a set of new paths.</p>
<p><a class="reference internal" href="#angr.surveyor.Surveyor.spill" title="angr.surveyor.Surveyor.spill"><code class="xref py py-func docutils literal"><span class="pre">spill()</span></code></a> spills all paths, in-place. The default implementation first calls <code class="xref py py-func docutils literal"><span class="pre">spill_path()</span></code> on every
path, then <a class="reference internal" href="#angr.surveyor.Surveyor.spill_paths" title="angr.surveyor.Surveyor.spill_paths"><code class="xref py py-func docutils literal"><span class="pre">spill_paths()</span></code></a> on the resulting sequence, then keeps the rest.</p>
<p><code class="xref py py-func docutils literal"><span class="pre">spill_path()</span></code> returns a spilled sequence of paths from a provided sequence of paths.</p>
<p>An analysis can overload either the specific sub-portions of surveyor
(i.e, the tick_path and spill_path functions) or bigger and bigger pieces
to implement more and more customizeable analyses.</p>
<p>Creates the Surveyor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>project</strong> &#8211; the angr.Project to analyze.</li>
<li><strong>start</strong> &#8211; a path (or set of paths) to start the analysis from</li>
<li><strong>max_active</strong> &#8211; the maximum number of paths to explore at a time</li>
<li><strong>max_concurrency</strong> &#8211; the maximum number of worker threads</li>
<li><strong>pickle_paths</strong> &#8211; pickle spilled paths to save memory</li>
<li><strong>save_deadends</strong> &#8211; save deadended paths</li>
<li><strong>enable_veritesting</strong> &#8211; use static symbolic execution to speed up exploration</li>
<li><strong>veritesting_options</strong> &#8211; special options to be passed to Veritesting</li>
<li><strong>keep_pruned</strong> &#8211; keep pruned unsat states</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="angr.surveyor.Surveyor.pre_tick">
<code class="descname">pre_tick</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.surveyor.Surveyor.pre_tick" title="Permalink to this definition">¶</a></dt>
<dd><p>Provided for analyses to use for pre-tick actions.</p>
</dd></dl>

<dl class="method">
<dt id="angr.surveyor.Surveyor.post_tick">
<code class="descname">post_tick</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.surveyor.Surveyor.post_tick" title="Permalink to this definition">¶</a></dt>
<dd><p>Provided for analyses to use for pre-tick actions.</p>
</dd></dl>

<dl class="method">
<dt id="angr.surveyor.Surveyor.step">
<code class="descname">step</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.surveyor.Surveyor.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes one step in the analysis (called by run()).</p>
</dd></dl>

<dl class="method">
<dt id="angr.surveyor.Surveyor.run">
<code class="descname">run</code><span class="sig-paren">(</span><em>n=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.surveyor.Surveyor.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs the analysis through completion (until done() returns True) or, if n is provided, n times.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>n</strong> &#8211; the maximum number of ticks</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">itself for chaining</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="angr.surveyor.Surveyor.done">
<code class="descname">done</code><a class="headerlink" href="#angr.surveyor.Surveyor.done" title="Permalink to this definition">¶</a></dt>
<dd><p>True if the analysis is done.</p>
</dd></dl>

<dl class="method">
<dt id="angr.surveyor.Surveyor.tick">
<code class="descname">tick</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.surveyor.Surveyor.tick" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes one step in the analysis. Typically, this moves all active paths forward.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">itself, for chaining</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.surveyor.Surveyor.tick_path">
<code class="descname">tick_path</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.surveyor.Surveyor.tick_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Ticks a single path forward. Returns a sequence of successor paths.</p>
</dd></dl>

<dl class="method">
<dt id="angr.surveyor.Surveyor.prune">
<code class="descname">prune</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.surveyor.Surveyor.prune" title="Permalink to this definition">¶</a></dt>
<dd><p>Prune unsat paths.</p>
</dd></dl>

<dl class="method">
<dt id="angr.surveyor.Surveyor.filter_path">
<code class="descname">filter_path</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.surveyor.Surveyor.filter_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the given path should be kept in the analysis, False
otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="angr.surveyor.Surveyor.filter_paths">
<code class="descname">filter_paths</code><span class="sig-paren">(</span><em>paths</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.surveyor.Surveyor.filter_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of paths, returns filters them and returns the rest.</p>
</dd></dl>

<dl class="method">
<dt id="angr.surveyor.Surveyor.path_comparator">
<code class="descname">path_comparator</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.surveyor.Surveyor.path_comparator" title="Permalink to this definition">¶</a></dt>
<dd><p>This function should compare paths a and b, to determine which should
have a higher priority in the analysis. It&#8217;s used as the cmp argument
to sort.</p>
</dd></dl>

<dl class="method">
<dt id="angr.surveyor.Surveyor.prioritize_paths">
<code class="descname">prioritize_paths</code><span class="sig-paren">(</span><em>paths</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.surveyor.Surveyor.prioritize_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is called to sort a list of paths, to prioritize
the analysis of paths. Should return a list of paths, with higher-
priority paths first.</p>
</dd></dl>

<dl class="method">
<dt id="angr.surveyor.Surveyor.spill_paths">
<code class="descname">spill_paths</code><span class="sig-paren">(</span><em>active</em>, <em>spilled</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.surveyor.Surveyor.spill_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>Called with the currently active and spilled paths to spill some
paths. Should return the new active and spilled paths.</p>
</dd></dl>

<dl class="method">
<dt id="angr.surveyor.Surveyor.spill">
<code class="descname">spill</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.surveyor.Surveyor.spill" title="Permalink to this definition">¶</a></dt>
<dd><p>Spills/unspills paths, in-place.</p>
</dd></dl>

<dl class="method">
<dt id="angr.surveyor.Surveyor.suspend_path">
<code class="descname">suspend_path</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.surveyor.Surveyor.suspend_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Suspends and returns a state.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>p</strong> &#8211; the path</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the path</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.surveyors"></span><span class="target" id="module-angr.surveyors.caller"></span><dl class="class">
<dt id="angr.surveyors.caller.Callable">
<em class="property">class </em><code class="descclassname">angr.surveyors.caller.</code><code class="descname">Callable</code><span class="sig-paren">(</span><em>project</em>, <em>addr</em>, <em>concrete_only=False</em>, <em>perform_merge=True</em>, <em>base_state=None</em>, <em>toc=None</em>, <em>cc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.surveyors.caller.Callable" title="Permalink to this definition">¶</a></dt>
<dd><p>Callable is a representation of a function in the binary that can be
interacted with like a native python function.</p>
<p>If you set perform_merge=True (the default), the result will be returned to you, and
you can get the result state with callable.result_state.</p>
<p>Otherwise, you can get the resulting path group (immutable) at callable.result_path_group.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>project</strong> &#8211; The project to operate on</li>
<li><strong>addr</strong> &#8211; The address of the function to use</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The following parameters are optional:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>concrete_only</strong> &#8211; Throw an exception if the execution splits into multiple paths</li>
<li><strong>perform_merge</strong> &#8211; Merge all result states into one at the end (only relevant if concrete_only=False)</li>
<li><strong>base_state</strong> &#8211; The state from which to do these runs</li>
<li><strong>toc</strong> &#8211; The address of the table of contents for ppc64</li>
<li><strong>cc</strong> &#8211; The SimCC to use for a calling convention</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="angr.surveyors.caller.Callable.set_base_state">
<code class="descname">set_base_state</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.surveyors.caller.Callable.set_base_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Swap out the state you&#8217;d like to use to perform the call
:param state: The state to use to perform the call</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="angr.surveyors.caller.Caller">
<em class="property">class </em><code class="descclassname">angr.surveyors.caller.</code><code class="descname">Caller</code><span class="sig-paren">(</span><em>project</em>, <em>addr</em>, <em>args=()</em>, <em>start=None</em>, <em>num_find=None</em>, <em>concrete_only=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.surveyors.caller.Caller" title="Permalink to this definition">¶</a></dt>
<dd><p>Caller is a surveyor that executes functions to see what they do.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>project</strong> &#8211; the project</li>
<li><strong>addr</strong> &#8211; the address to start calling at</li>
<li><strong>args</strong> &#8211; a tuple of arguments. Any members that are None will be replaced with symbolic expressions with a
length of the architecture&#8217;s bitwidth.</li>
<li><strong>start</strong> &#8211; a path (or set of paths) to start from</li>
<li><strong>num_find</strong> &#8211; find at least this many returns from the function</li>
<li><strong>concrete_only</strong> &#8211; Throw an exception if the execution splits into multiple paths</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="angr.surveyors.caller.Caller.map_se">
<code class="descname">map_se</code><span class="sig-paren">(</span><em>func</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.surveyors.caller.Caller.map_se" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps the state.se.&#8221;func&#8221; function for all the return address states. This is a generator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>func</strong> &#8211; the function name, used as getattr(p.state.se, func). Normally any_n_int or any_n_str</li>
<li><strong>runs</strong> &#8211; the maximum number of runs to execute</li>
<li><strong>solutions</strong> &#8211; check only returns with this value as a possible solution</li>
<li><strong>sort</strong> &#8211; sort the result before yielding it</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Other <em>args and **kwargs are passed to the called state.se.</em> function.</p>
<p>yields (r, func_return) for each state.</p>
</dd></dl>

<dl class="method">
<dt id="angr.surveyors.caller.Caller.map_func">
<code class="descname">map_func</code><span class="sig-paren">(</span><em>func</em>, <em>runs=None</em>, <em>solution=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.surveyors.caller.Caller.map_func" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls func(return_value, args_tuple, path) for each function return. This is a generator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>func</strong> &#8211; the function to call</li>
<li><strong>runs</strong> &#8211; the maximum number of runs to execute</li>
<li><strong>solutions</strong> &#8211; check only returns with this value as a possible solution</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>yields the return values of func</p>
</dd></dl>

<dl class="method">
<dt id="angr.surveyors.caller.Caller.iter_returns">
<code class="descname">iter_returns</code><span class="sig-paren">(</span><em>runs=None</em>, <em>solution=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.surveyors.caller.Caller.iter_returns" title="Permalink to this definition">¶</a></dt>
<dd><p>Yields (return_value, path) for every return. This is a generator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>runs</strong> &#8211; the maximum number of runs to execute</li>
<li><strong>solutions</strong> &#8211; check only returns with this value as a possible solution</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.surveyors.escaper"></span><dl class="class">
<dt id="angr.surveyors.escaper.Escaper">
<em class="property">class </em><code class="descclassname">angr.surveyors.escaper.</code><code class="descname">Escaper</code><span class="sig-paren">(</span><em>project</em>, <em>loop_addresses</em>, <em>start=None</em>, <em>max_concurrency=None</em>, <em>max_active=None</em>, <em>pickle_paths=None</em>, <em>loop_iterations=0</em>, <em>iteration_depth=100</em>, <em>unconstrain_memory=True</em>, <em>unconstrain_registers=True</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.surveyors.escaper.Escaper" title="Permalink to this definition">¶</a></dt>
<dd><p>Escaper implements loop escaping!</p>
<p>normal - any found normal paths from the loop
forced - forced paths from the loop, if a normal wasn&#8217;t found</p>
<p>Creates an Escaper. Most options are for Surveyor (separate docs).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>loop_addresses</strong> &#8211; the addresses of all the basic blocks in the loop, to know the
instructions to which the analysis should be restricted</li>
<li><strong>loop_iterations</strong> &#8211; the number of times to run the loop before escaping</li>
<li><strong>iteration_depth</strong> &#8211; the maximum depth (in SimRuns) of a path through the loop</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="angr.surveyors.escaper.Escaper.unconstrain_loop">
<code class="descname">unconstrain_loop</code><span class="sig-paren">(</span><em>constrained_entry</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.surveyors.escaper.Escaper.unconstrain_loop" title="Permalink to this definition">¶</a></dt>
<dd><p>Unconstrains an exit to the loop header by looping one more time
and replacing all modified variables with unconstrained versions.</p>
</dd></dl>

<dl class="method">
<dt id="angr.surveyors.escaper.Escaper.tick">
<code class="descname">tick</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.surveyors.escaper.Escaper.tick" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes one run through the loop.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.surveyors.executor"></span><dl class="class">
<dt id="angr.surveyors.executor.Executor">
<em class="property">class </em><code class="descclassname">angr.surveyors.executor.</code><code class="descname">Executor</code><span class="sig-paren">(</span><em>project</em>, <em>start</em>, <em>final_addr=None</em>, <em>pickle_paths=None</em>, <em>max_run=50000</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.surveyors.executor.Executor" title="Permalink to this definition">¶</a></dt>
<dd><p>This class handles pure concrete execution related issues.
No state splitting is ever allowed.</p>
</dd></dl>

<span class="target" id="module-angr.surveyors.explorer"></span><dl class="class">
<dt id="angr.surveyors.explorer.Explorer">
<em class="property">class </em><code class="descclassname">angr.surveyors.explorer.</code><code class="descname">Explorer</code><span class="sig-paren">(</span><em>project</em>, <em>start=None</em>, <em>max_concurrency=None</em>, <em>max_active=None</em>, <em>pickle_paths=None</em>, <em>find=None</em>, <em>avoid=None</em>, <em>restrict=None</em>, <em>min_depth=0</em>, <em>max_depth=None</em>, <em>max_repeats=10000000</em>, <em>num_find=1</em>, <em>num_avoid=None</em>, <em>num_deviate=1</em>, <em>num_loop=None</em>, <em>cfg=None</em>, <em>enable_veritesting=None</em>, <em>veritesting_options=None</em>, <em>keep_pruned=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.surveyors.explorer.Explorer" title="Permalink to this definition">¶</a></dt>
<dd><p>Explorer implements a symbolic exploration engine!</p>
<p>WARNING: Explorers are not really maintained - Use path_group instead when possible</p>
<p>found - paths where the target addresses have been found.
avoided - paths where the to-avoid addresses have been found.
deviating - paths that deviate from the restricted-to addresses.
looping - paths that were detected as looping.</p>
<p>Explores the path space until a block containing a specified address is found.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>project</strong> &#8211; </td>
</tr>
</tbody>
</table>
<p>The following parameters are optional :</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>start</strong> &#8211; </li>
<li><strong>max_concurrency</strong> &#8211; </li>
<li><strong>max_active</strong> &#8211; </li>
<li><strong>pickle_paths</strong> &#8211; </li>
<li><strong>find</strong> &#8211; A tuple containing the addresses to search for.</li>
<li><strong>avoid</strong> &#8211; A tuple containing the addresses to avoid.</li>
<li><strong>restrict</strong> &#8211; A tuple containing the addresses to restrict the analysis to (avoid all others).</li>
<li><strong>min_depth</strong> &#8211; The minimum number of SimRuns in the resulting path.</li>
<li><strong>max_depth</strong> &#8211; The maximum number of SimRuns in the resulting path.</li>
<li><strong>num_find</strong> &#8211; The minimum number of paths to find. (default: 1)</li>
<li><strong>num_avoid</strong> &#8211; The minimum number of paths to avoid. (default: infinite)</li>
<li><strong>num_deviate</strong> &#8211; The minimum number of paths to deviate. (default: infinite)</li>
<li><strong>num_loop</strong> &#8211; The minimum number of paths to loop (default: infinite)</li>
<li><strong>cfg</strong> &#8211; A CFG to use to cut any paths that have no chance of going to the target.</li>
<li><strong>enable_veritesting</strong> &#8211; Whether Veritesting should be enabled or not.</li>
<li><strong>veritesting_options</strong> &#8211; Options that should be passed to Veritesting.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<span class="target" id="module-angr.surveyors.slicecutor"></span><dl class="class">
<dt id="angr.surveyors.slicecutor.Slicecutor">
<em class="property">class </em><code class="descclassname">angr.surveyors.slicecutor.</code><code class="descname">Slicecutor</code><span class="sig-paren">(</span><em>project</em>, <em>annotated_cfg</em>, <em>start=None</em>, <em>targets=None</em>, <em>max_concurrency=None</em>, <em>max_active=None</em>, <em>max_loop_iterations=None</em>, <em>pickle_paths=None</em>, <em>merge_countdown=10</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.surveyors.slicecutor.Slicecutor" title="Permalink to this definition">¶</a></dt>
<dd><p>The Slicecutor is a surveyor that executes provided code slices.</p>
</dd></dl>

</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="simuvex.html" class="btn btn-neutral float-right" title="simuvex — Program State and Emulation" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral" title="angr API documentation" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, The angr project.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'6.7.3.26',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>