

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>angr — Analysis and Coordination &mdash; angr 7.7.12.16 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="angr 7.7.12.16 documentation" href="index.html"/>
        <link rel="next" title="claripy — Solver Engine" href="claripy.html"/>
        <link rel="prev" title="angr API documentation" href="index.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> angr
          

          
          </a>

          
            
            
              <div class="version">
                7.7.12.16
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#"><code class="docutils literal"><span class="pre">angr</span></code> &#8212; Analysis and Coordination</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-angr.project">Project</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-angr.sim_state">Program State</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-angr.storage">Storage</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-angr.manager">Simulation Manager</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-angr.engines">Simulation Engines</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-angr.state_plugins.sim_action">Simulation Logging</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-angr.sim_procedure">Procedures</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-angr.calling_conventions">Calling Conventions and Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-angr.knowledge_base">Knowledge Base</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-angr.analyses">Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-angr.simos">SimOS</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="claripy.html"><code class="docutils literal"><span class="pre">claripy</span></code> &#8212; Solver Engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="cle.html"><code class="docutils literal"><span class="pre">cle</span></code> &#8212; Binary Loader</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyvex.html"><code class="docutils literal"><span class="pre">pyvex</span></code> &#8212; Binary Translator</a></li>
<li class="toctree-l1"><a class="reference internal" href="archinfo.html"><code class="docutils literal"><span class="pre">archinfo</span></code> &#8212; Arch Information Repository</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">angr</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li><code class="docutils literal"><span class="pre">angr</span></code> &#8212; Analysis and Coordination</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/angr.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="angr-analysis-and-coordination">
<h1><code class="xref py py-mod docutils literal"><span class="pre">angr</span></code> &#8212; Analysis and Coordination<a class="headerlink" href="#angr-analysis-and-coordination" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-angr.project">
<span id="project"></span><h2>Project<a class="headerlink" href="#module-angr.project" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="angr.project.register_default_engine">
<code class="descclassname">angr.project.</code><code class="descname">register_default_engine</code><span class="sig-paren">(</span><em>loader_backend</em>, <em>engine</em>, <em>arch='any'</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.project.register_default_engine" title="Permalink to this definition">¶</a></dt>
<dd><p>Register the default execution engine to be used with a given CLE backend.
Usually this is the SimEngineVEX, but if you&#8217;re operating on something that isn&#8217;t
going to be lifted to VEX, you&#8217;ll need to make sure the desired engine is registered here.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>loader_backend</strong> &#8211; The loader backend (a type)</li>
<li><strong>engine</strong> (<em>type</em>) &#8211; The engine to use for the loader backend (a type)</li>
<li><strong>arch</strong> &#8211; The architecture to associate with this engine. Optional.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="angr.project.get_default_engine">
<code class="descclassname">angr.project.</code><code class="descname">get_default_engine</code><span class="sig-paren">(</span><em>loader_backend</em>, <em>arch='any'</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.project.get_default_engine" title="Permalink to this definition">¶</a></dt>
<dd><p>Get some sort of sane default for a given loader and/or arch.
Can be set with register_default_engine()
:param loader_backend:
:param arch:
:return:</p>
</dd></dl>

<dl class="function">
<dt id="angr.project.load_shellcode">
<code class="descclassname">angr.project.</code><code class="descname">load_shellcode</code><span class="sig-paren">(</span><em>shellcode</em>, <em>arch</em>, <em>start_offset=0</em>, <em>load_address=0</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.project.load_shellcode" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a new project based on a string of raw bytecode.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>shellcode</strong> &#8211; The data to load</li>
<li><strong>arch</strong> &#8211; The name of the arch to use, or an archinfo class</li>
<li><strong>start_offset</strong> &#8211; The offset into the data to start analysis (default 0)</li>
<li><strong>load_address</strong> &#8211; The address to place the data in memory (default 0)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="angr.project.Project">
<em class="property">class </em><code class="descclassname">angr.project.</code><code class="descname">Project</code><span class="sig-paren">(</span><em>thing</em>, <em>default_analysis_mode=None</em>, <em>ignore_functions=None</em>, <em>use_sim_procedures=True</em>, <em>exclude_sim_procedures_func=None</em>, <em>exclude_sim_procedures_list=()</em>, <em>arch=None</em>, <em>simos=None</em>, <em>load_options=None</em>, <em>translation_cache=True</em>, <em>support_selfmodifying_code=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.project.Project" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the main class of the angr module. It is meant to contain a set of binaries and the relationships between
them, and perform analyses on them.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>thing</strong> &#8211; The path to the main executable object to analyze, or a CLE Loader object.</td>
</tr>
</tbody>
</table>
<p>The following parameters are optional.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>default_analysis_mode</strong> &#8211; The mode of analysis to use by default. Defaults to &#8216;symbolic&#8217;.</li>
<li><strong>ignore_functions</strong> &#8211; A list of function names that, when imported from shared libraries, should
never be stepped into in analysis (calls will return an unconstrained value).</li>
<li><strong>use_sim_procedures</strong> &#8211; Whether to replace resolved dependencies for which simprocedures are
available with said simprocedures.</li>
<li><strong>exclude_sim_procedures_func</strong> &#8211; A function that, when passed a function name, returns whether or not to wrap
it with a simprocedure.</li>
<li><strong>exclude_sim_procedures_list</strong> &#8211; A list of functions to <em>not</em> wrap with simprocedures.</li>
<li><strong>arch</strong> &#8211; The target architecture (auto-detected otherwise).</li>
<li><strong>simos</strong> &#8211; a SimOS class to use for this project.</li>
<li><strong>translation_cache</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; If True, cache translated basic blocks rather than re-translating them.</li>
<li><strong>support_selfmodifying_code</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; Whether we aggressively support self-modifying code. When enabled, emulation
will try to read code from the current state instead of the original memory,
regardless of the current memory protections.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Any additional keyword arguments passed will be passed onto <code class="docutils literal"><span class="pre">cle.Loader</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><a class="reference internal" href="#module-angr.analyses" title="angr.analyses"><strong>analyses</strong></a> &#8211; The available analyses.</li>
<li><strong>entry</strong> &#8211; The program entrypoint.</li>
<li><a class="reference internal" href="#module-angr.factory" title="angr.factory"><strong>factory</strong></a> &#8211; Provides access to important analysis elements such as path groups and symbolic execution results.</li>
<li><strong>filename</strong> &#8211; The filename of the executable.</li>
<li><a class="reference internal" href="cle.html#module-cle.loader" title="cle.loader"><strong>loader</strong></a> &#8211; The program loader.</li>
<li><strong>surveyors</strong> &#8211; The available surveyors.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="angr.project.Project.hook">
<code class="descname">hook</code><span class="sig-paren">(</span><em>addr</em>, <em>hook=None</em>, <em>length=0</em>, <em>kwargs=None</em>, <em>replace=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.project.Project.hook" title="Permalink to this definition">¶</a></dt>
<dd><p>Hook a section of code with a custom function. This is used internally to provide symbolic
summaries of library functions, and can be used to instrument execution or to modify
control flow.</p>
<p>When hook is not specified, it returns a function decorator that allows easy hooking.
Usage:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Assuming proj is an instance of angr.Project, we will add a custom hook at the entry</span>
<span class="c1"># point of the project.</span>
<span class="nd">@proj</span><span class="o">.</span><span class="n">hook</span><span class="p">(</span><span class="n">proj</span><span class="o">.</span><span class="n">entry</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">my_hook</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
    <span class="nb">print</span> <span class="s2">&quot;Welcome to execution!&quot;</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>addr</strong> &#8211; The address to hook.</li>
<li><strong>hook</strong> &#8211; A <code class="xref py py-class docutils literal"><span class="pre">angr.project.Hook</span></code> describing a procedure to run at the
given address. You may also pass in a SimProcedure class or a function
directly and it will be wrapped in a Hook object for you.</li>
<li><strong>length</strong> &#8211; If you provide a function for the hook, this is the number of bytes
that will be skipped by executing the hook by default.</li>
<li><strong>kwargs</strong> &#8211; If you provide a SimProcedure for the hook, these are the keyword
arguments that will be passed to the procedure&#8217;s <cite>run</cite> method
eventually.</li>
<li><strong>replace</strong> &#8211; Control the behavior on finding that the address is already hooked. If
true, silently replace the hook. If false (default), warn and do not
replace the hook. If none, warn and replace the hook.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.project.Project.is_hooked">
<code class="descname">is_hooked</code><span class="sig-paren">(</span><em>addr</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.project.Project.is_hooked" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if <cite>addr</cite> is hooked.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>addr</strong> &#8211; An address.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if addr is hooked, False otherwise.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.project.Project.hooked_by">
<code class="descname">hooked_by</code><span class="sig-paren">(</span><em>addr</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.project.Project.hooked_by" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the current hook for <cite>addr</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>addr</strong> &#8211; An address.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">None if the address is not hooked.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.project.Project.unhook">
<code class="descname">unhook</code><span class="sig-paren">(</span><em>addr</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.project.Project.unhook" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a hook.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>addr</strong> &#8211; The address of the hook.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.project.Project.hook_symbol">
<code class="descname">hook_symbol</code><span class="sig-paren">(</span><em>symbol_name</em>, <em>obj</em>, <em>kwargs=None</em>, <em>replace=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.project.Project.hook_symbol" title="Permalink to this definition">¶</a></dt>
<dd><p>Resolve a dependency in a binary. Looks up the address of the given symbol, and then hooks that
address. If the symbol was not available in the loaded libraries, this address may be provided
by the CLE externs object.</p>
<p>Additionally, if instead of a symbol name you provide an address, some secret functionality will
kick in and you will probably just hook that address, UNLESS you&#8217;re on powerpc64 ABIv1 or some
yet-unknown scary ABI that has its function pointers point to something other than the actual
functions, in which case it&#8217;ll do the right thing.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>symbol_name</strong> &#8211; The name of the dependency to resolve.</li>
<li><strong>obj</strong> &#8211; The thing with which to satisfy the dependency.</li>
<li><strong>kwargs</strong> &#8211; If you provide a SimProcedure for the hook, these are the keyword
arguments that will be passed to the procedure&#8217;s <cite>run</cite> method
eventually.</li>
<li><strong>replace</strong> &#8211; Control the behavior on finding that the address is already hooked. If
true, silently replace the hook. If false, warn and do not replace the
hook. If none (default), warn and replace the hook.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The address of the new symbol.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int">int</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.project.Project.is_symbol_hooked">
<code class="descname">is_symbol_hooked</code><span class="sig-paren">(</span><em>symbol_name</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.project.Project.is_symbol_hooked" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if a symbol is already hooked.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>symbol_name</strong> (<em>str</em>) &#8211; Name of the symbol.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if the symbol can be resolved and is hooked, False otherwise.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool">bool</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.project.Project.unhook_symbol">
<code class="descname">unhook_symbol</code><span class="sig-paren">(</span><em>symbol_name</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.project.Project.unhook_symbol" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the hook on a symbol.
This function will fail if the symbol is provided by the extern object, as that would result in a state where
analysis would be unable to cope with a call to this symbol.</p>
</dd></dl>

<dl class="method">
<dt id="angr.project.Project.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.project.Project.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is a symbolic execution helper in the simple style
supported by triton and manticore. It designed to be run after
setting up hooks (see Project.hook), in which the symbolic state
can be checked.</p>
<p>This function can be run in three different ways:</p>
<blockquote>
<div><ul class="simple">
<li>When run with no parameters, this function begins symbolic execution
from the entrypoint.</li>
<li>It can also be run with a &#8220;state&#8221; parameter specifying a SimState to
begin symbolic execution from.</li>
<li>Finally, it can accept any arbitrary keyword arguments, which are all
passed to project.factory.full_init_state.</li>
</ul>
</div></blockquote>
<p>If symbolic execution finishes, this function returns the resulting
simulation manager.</p>
</dd></dl>

<dl class="method">
<dt id="angr.project.Project.terminate_execution">
<code class="descname">terminate_execution</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.project.Project.terminate_execution" title="Permalink to this definition">¶</a></dt>
<dd><p>Terminates a symbolic execution that was started with Project.execute().</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.factory"></span><dl class="class">
<dt id="angr.factory.AngrObjectFactory">
<em class="property">class </em><code class="descclassname">angr.factory.</code><code class="descname">AngrObjectFactory</code><span class="sig-paren">(</span><em>project</em>, <em>default_engine</em>, <em>procedure_engine</em>, <em>engines</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.factory.AngrObjectFactory" title="Permalink to this definition">¶</a></dt>
<dd><p>This factory provides access to important analysis elements.</p>
<dl class="method">
<dt id="angr.factory.AngrObjectFactory.successors">
<code class="descname">successors</code><span class="sig-paren">(</span><em>state</em>, <em>addr=None</em>, <em>jumpkind=None</em>, <em>inline=False</em>, <em>default_engine=False</em>, <em>engines=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.factory.AngrObjectFactory.successors" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform execution using any applicable engine. Enumerate the current engines and use the
first one that works. Return a SimSuccessors object classifying the results of the run.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>state</strong> &#8211; The state to analyze</li>
<li><strong>addr</strong> &#8211; optional, an address to execute at instead of the state&#8217;s ip</li>
<li><strong>jumpkind</strong> &#8211; optional, the jumpkind of the previous exit</li>
<li><strong>inline</strong> &#8211; This is an inline execution. Do not bother copying the state.</li>
<li><strong>default_engine</strong> &#8211; Whether we should only attempt to use the default engine (usually VEX)</li>
<li><strong>engines</strong> &#8211; A list of engines to try to use, instead of the default.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Additional keyword arguments will be passed directly into each engine&#8217;s process method.</p>
</dd></dl>

<dl class="method">
<dt id="angr.factory.AngrObjectFactory.blank_state">
<code class="descname">blank_state</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.factory.AngrObjectFactory.blank_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a mostly-uninitialized state object. All parameters are optional.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>addr</strong> &#8211; The address the state should start at instead of the entry point.</li>
<li><strong>initial_prefix</strong> &#8211; If this is provided, all symbolic registers will hold symbolic values with names
prefixed by this string.</li>
<li><strong>fs</strong> &#8211; A dictionary of file names with associated preset SimFile objects.</li>
<li><strong>concrete_fs</strong> &#8211; bool describing whether the host filesystem should be consulted when opening files.</li>
<li><strong>chroot</strong> &#8211; A path to use as a fake root directory, Behaves similarly to a real chroot. Used only
when concrete_fs is set to True.</li>
<li><strong>kwargs</strong> &#8211; Any additional keyword args will be passed to the SimState constructor.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The blank state.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#angr.sim_state.SimState" title="angr.sim_state.SimState">SimState</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.factory.AngrObjectFactory.entry_state">
<code class="descname">entry_state</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.factory.AngrObjectFactory.entry_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a state object representing the program at its entry point. All parameters are optional.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>addr</strong> &#8211; The address the state should start at instead of the entry point.</li>
<li><strong>initial_prefix</strong> &#8211; If this is provided, all symbolic registers will hold symbolic values with names
prefixed by this string.</li>
<li><strong>fs</strong> &#8211; a dictionary of file names with associated preset SimFile objects.</li>
<li><strong>concrete_fs</strong> &#8211; boolean describing whether the host filesystem should be consulted when opening files.</li>
<li><strong>chroot</strong> &#8211; a path to use as a fake root directory, behaves similar to a real chroot. used only when
concrete_fs is set to True.</li>
<li><strong>argc</strong> &#8211; a custom value to use for the program&#8217;s argc. May be either an int or a bitvector. If
not provided, defaults to the length of args.</li>
<li><strong>args</strong> &#8211; a list of values to use as the program&#8217;s argv. May be mixed strings and bitvectors.</li>
<li><strong>env</strong> &#8211; a dictionary to use as the environment for the program. Both keys and values may be
mixed strings and bitvectors.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The entry state.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#angr.sim_state.SimState" title="angr.sim_state.SimState">SimState</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.factory.AngrObjectFactory.full_init_state">
<code class="descname">full_init_state</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.factory.AngrObjectFactory.full_init_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Very much like <a class="reference internal" href="#angr.factory.AngrObjectFactory.entry_state" title="angr.factory.AngrObjectFactory.entry_state"><code class="xref py py-meth docutils literal"><span class="pre">entry_state()</span></code></a>, except that instead of starting execution at the program entry point,
execution begins at a special SimProcedure that plays the role of the dynamic loader, calling each of the
initializer functions that should be called before execution reaches the entry point.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>addr</strong> &#8211; The address the state should start at instead of the entry point.</li>
<li><strong>initial_prefix</strong> &#8211; If this is provided, all symbolic registers will hold symbolic values with names
prefixed by this string.</li>
<li><strong>fs</strong> &#8211; a dictionary of file names with associated preset SimFile objects.</li>
<li><strong>concrete_fs</strong> &#8211; boolean describing whether the host filesystem should be consulted when opening files.</li>
<li><strong>chroot</strong> &#8211; a path to use as a fake root directory, behaves similar to a real chroot. used only when
concrete_fs is set to True.</li>
<li><strong>argc</strong> &#8211; a custom value to use for the program&#8217;s argc. May be either an int or a bitvector. If
not provided, defaults to the length of args.</li>
<li><strong>args</strong> &#8211; a list of values to use as arguments to the program. May be mixed strings and bitvectors.</li>
<li><strong>env</strong> &#8211; a dictionary to use as the environment for the program. Both keys and values may be
mixed strings and bitvectors.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The fully initialized state.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#angr.sim_state.SimState" title="angr.sim_state.SimState">SimState</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.factory.AngrObjectFactory.call_state">
<code class="descname">call_state</code><span class="sig-paren">(</span><em>addr</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.factory.AngrObjectFactory.call_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a state object initialized to the start of a given function, as if it were called with given parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>addr</strong> &#8211; The address the state should start at instead of the entry point.</li>
<li><strong>args</strong> &#8211; Any additional positional arguments will be used as arguments to the function call.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The following parametrs are optional.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>base_state</strong> &#8211; Use this SimState as the base for the new state instead of a blank state.</li>
<li><strong>cc</strong> &#8211; Optionally provide a SimCC object to use a specific calling convention.</li>
<li><strong>ret_addr</strong> &#8211; Use this address as the function&#8217;s return target.</li>
<li><strong>stack_base</strong> &#8211; An optional pointer to use as the top of the stack, circa the function entry point</li>
<li><strong>alloc_base</strong> &#8211; An optional pointer to use as the place to put excess argument data</li>
<li><strong>grow_like_stack</strong> &#8211; When allocating data at alloc_base, whether to allocate at decreasing addresses</li>
<li><strong>toc</strong> &#8211; The address of the table of contents for ppc64</li>
<li><strong>initial_prefix</strong> &#8211; If this is provided, all symbolic registers will hold symbolic values with names
prefixed by this string.</li>
<li><strong>fs</strong> &#8211; A dictionary of file names with associated preset SimFile objects.</li>
<li><strong>concrete_fs</strong> &#8211; bool describing whether the host filesystem should be consulted when opening files.</li>
<li><strong>chroot</strong> &#8211; A path to use as a fake root directory, Behaves similarly to a real chroot. Used only
when concrete_fs is set to True.</li>
<li><strong>kwargs</strong> &#8211; Any additional keyword args will be passed to the SimState constructor.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The state at the beginning of the function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#angr.sim_state.SimState" title="angr.sim_state.SimState">SimState</a></p>
</td>
</tr>
</tbody>
</table>
<p>The idea here is that you can provide almost any kind of python type in <cite>args</cite> and it&#8217;ll be translated to a
binary format to be placed into simulated memory. Lists (representing arrays) must be entirely elements of the
same type and size, while tuples (representing structs) can be elements of any type and size.
If you&#8217;d like there to be a pointer to a given value, wrap the value in a <cite>SimCC.PointerWrapper</cite>. Any value
that can&#8217;t fit in a register will be automatically put in a
PointerWrapper.</p>
<p>If stack_base is not provided, the current stack pointer will be used, and it will be updated.
If alloc_base is not provided, the current stack pointer will be used, and it will be updated.
You might not like the results if you provide stack_base but not alloc_base.</p>
<p>grow_like_stack controls the behavior of allocating data at alloc_base. When data from args needs to be wrapped
in a pointer, the pointer needs to point somewhere, so that data is dumped into memory at alloc_base. If you
set alloc_base to point to somewhere other than the stack, set grow_like_stack to False so that sequencial
allocations happen at increasing addresses.</p>
</dd></dl>

<dl class="method">
<dt id="angr.factory.AngrObjectFactory.tracer_state">
<code class="descname">tracer_state</code><span class="sig-paren">(</span><em>input_content=None</em>, <em>magic_content=None</em>, <em>preconstrain_input=True</em>, <em>preconstrain_flag=True</em>, <em>constrained_addrs=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.factory.AngrObjectFactory.tracer_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new SimState object correctly configured for tracing.</p>
<p>:param input_content     : Concrete input to feed to binary.
:param magic_content     : CGC magic flag page.
:param preconstrain_input: Should the path be preconstrained to the provided input?
:param preconstrain_flag : Should the path have the CGC flag page preconstrained?
:param constrained_addrs : Addresses which have had constraints applied to them and should not be removed.
:param kwargs            : Any additional keyword arguments that will be passed to the SimState constructor.</p>
<p>:returns : The new SimState for tracing.
:rtype   : angr.sim_state.SimState</p>
</dd></dl>

<dl class="method">
<dt id="angr.factory.AngrObjectFactory.simulation_manager">
<code class="descname">simulation_manager</code><span class="sig-paren">(</span><em>thing=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.factory.AngrObjectFactory.simulation_manager" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a new simulation manager.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>thing</strong> &#8211; Optional - What to put in the new SimulationManager&#8217;s active stash (either a SimState or a list of SimStates).</li>
<li><strong>kwargs</strong> &#8211; Any additional keyword arguments will be passed to the SimulationManager constructor</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The new SimulationManager</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#angr.manager.SimulationManager" title="angr.manager.SimulationManager">angr.manager.SimulationManager</a></p>
</td>
</tr>
</tbody>
</table>
<p>Many different types can be passed to this method:</p>
<ul class="simple">
<li>If nothing is passed in, the SimulationManager is seeded with a state initialized for the program
entry point, i.e. <a class="reference internal" href="#angr.factory.AngrObjectFactory.entry_state" title="angr.factory.AngrObjectFactory.entry_state"><code class="xref py py-meth docutils literal"><span class="pre">entry_state()</span></code></a>.</li>
<li>If a <code class="xref py py-class docutils literal"><span class="pre">SimState</span></code> is passed in, the SimulationManager is seeded with that state.</li>
<li>If a list is passed in, the list must contain only SimStates and the whole list will be used to seed the SimulationManager.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="angr.factory.AngrObjectFactory.callable">
<code class="descname">callable</code><span class="sig-paren">(</span><em>addr</em>, <em>concrete_only=False</em>, <em>perform_merge=True</em>, <em>base_state=None</em>, <em>toc=None</em>, <em>cc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.factory.AngrObjectFactory.callable" title="Permalink to this definition">¶</a></dt>
<dd><p>A Callable is a representation of a function in the binary that can be interacted with like a native python
function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>addr</strong> &#8211; The address of the function to use</li>
<li><strong>concrete_only</strong> &#8211; Throw an exception if the execution splits into multiple states</li>
<li><strong>perform_merge</strong> &#8211; Merge all result states into one at the end (only relevant if concrete_only=False)</li>
<li><strong>base_state</strong> &#8211; The state from which to do these runs</li>
<li><strong>toc</strong> &#8211; The address of the table of contents for ppc64</li>
<li><strong>cc</strong> &#8211; The SimCC to use for a calling convention</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A Callable object that can be used as a interface for executing guest code like a
python function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">angr.surveyors.caller.Callable</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.factory.AngrObjectFactory.cc">
<code class="descname">cc</code><span class="sig-paren">(</span><em>args=None</em>, <em>ret_val=None</em>, <em>sp_delta=None</em>, <em>func_ty=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.factory.AngrObjectFactory.cc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a SimCC (calling convention) parametrized for this project and, optionally, a given function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>args</strong> &#8211; A list of argument storage locations, as SimFunctionArguments.</li>
<li><strong>ret_val</strong> &#8211; The return value storage location, as a SimFunctionArgument.</li>
<li><strong>sp_delta</strong> &#8211; Does this even matter??</li>
<li><strong>func_ty</strong> &#8211; The protoype for the given function, as a SimType.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Relevant subclasses of SimFunctionArgument are SimRegArg and SimStackArg, and shortcuts to them can be found on
this <cite>cc</cite> object.</p>
<p>For stack arguments, offsets are relative to the stack pointer on function entry.</p>
</dd></dl>

<dl class="method">
<dt id="angr.factory.AngrObjectFactory.cc_from_arg_kinds">
<code class="descname">cc_from_arg_kinds</code><span class="sig-paren">(</span><em>fp_args</em>, <em>ret_fp=None</em>, <em>sizes=None</em>, <em>sp_delta=None</em>, <em>func_ty=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.factory.AngrObjectFactory.cc_from_arg_kinds" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a SimCC (calling convention) that will extract floating-point/integral args correctly.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>arch</strong> &#8211; The Archinfo arch for this CC</li>
<li><strong>fp_args</strong> &#8211; A list, with one entry for each argument the function can take. True if the argument is fp,
false if it is integral.</li>
<li><strong>ret_fp</strong> &#8211; True if the return value for the function is fp.</li>
<li><strong>sizes</strong> &#8211; Optional: A list, with one entry for each argument the function can take. Each entry is the
size of the corresponding argument in bytes.</li>
<li><strong>sp_delta</strong> &#8211; The amount the stack pointer changes over the course of this function - CURRENTLY UNUSED</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parmm func_ty:</th><td class="field-body"><p class="first last">A SimType for the function itself</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-angr.sim_state">
<span id="program-state"></span><h2>Program State<a class="headerlink" href="#module-angr.sim_state" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="angr.sim_state.SimState">
<em class="property">class </em><code class="descclassname">angr.sim_state.</code><code class="descname">SimState</code><span class="sig-paren">(</span><em>project=None</em>, <em>arch=None</em>, <em>plugins=None</em>, <em>memory_backer=None</em>, <em>permissions_backer=None</em>, <em>mode=None</em>, <em>options=None</em>, <em>add_options=None</em>, <em>remove_options=None</em>, <em>special_memory_filler=None</em>, <em>os_name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_state.SimState" title="Permalink to this definition">¶</a></dt>
<dd><p>The SimState represents the state of a program, including its memory, registers, and so forth.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>regs</strong> &#8211; A convenient view of the state&#8217;s registers, where each register is a property</li>
<li><strong>mem</strong> &#8211; A convenient view of the state&#8217;s memory, a <a class="reference internal" href="#angr.state_plugins.view.SimMemView" title="angr.state_plugins.view.SimMemView"><code class="xref py py-class docutils literal"><span class="pre">angr.state_plugins.view.SimMemView</span></code></a></li>
<li><strong>registers</strong> &#8211; The state&#8217;s register file as a flat memory region</li>
<li><a class="reference internal" href="#module-angr.storage.memory" title="angr.storage.memory"><strong>memory</strong></a> &#8211; The state&#8217;s memory as a flat memory region</li>
<li><a class="reference internal" href="#module-angr.state_plugins.solver" title="angr.state_plugins.solver"><strong>solver</strong></a> &#8211; The symbolic solver and variable manager for this state</li>
<li><a class="reference internal" href="#module-angr.state_plugins.inspect" title="angr.state_plugins.inspect"><strong>inspect</strong></a> &#8211; The breakpoint manager, a <a class="reference internal" href="#angr.state_plugins.inspect.SimInspector" title="angr.state_plugins.inspect.SimInspector"><code class="xref py py-class docutils literal"><span class="pre">angr.state_plugins.inspect.SimInspector</span></code></a></li>
<li><strong>log</strong> &#8211; Information about the state&#8217;s history</li>
<li><strong>scratch</strong> &#8211; Information about the current execution step</li>
<li><a class="reference internal" href="#module-angr.state_plugins.posix" title="angr.state_plugins.posix"><strong>posix</strong></a> &#8211; MISNOMER: information about the operating system or environment model</li>
<li><a class="reference internal" href="#module-angr.state_plugins.libc" title="angr.state_plugins.libc"><strong>libc</strong></a> &#8211; Information about the standard library we are emulating</li>
<li><a class="reference internal" href="cle.html#module-cle.backends.cgc.cgc" title="cle.backends.cgc.cgc"><strong>cgc</strong></a> &#8211; Information about the cgc environment</li>
<li><strong>uc_manager</strong> &#8211; Control of under-constrained symbolic execution</li>
<li><a class="reference internal" href="#module-angr.engines.unicorn" title="angr.engines.unicorn"><strong>unicorn</strong></a> &#8211; Control of the Unicorn Engine</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="angr.sim_state.SimState.ip">
<code class="descname">ip</code><a class="headerlink" href="#angr.sim_state.SimState.ip" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the instruction pointer expression, trigger SimInspect breakpoints, and generate SimActions.
Use <code class="docutils literal"><span class="pre">_ip</span></code> to not trigger breakpoints or generate actions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">an expression</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="angr.sim_state.SimState.addr">
<code class="descname">addr</code><a class="headerlink" href="#angr.sim_state.SimState.addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the concrete address of the instruction pointer, without triggering SimInspect breakpoints or generating
SimActions. An integer is returned, or an exception is raised if the instruction pointer is symbolic.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">an int</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.sim_state.SimState.simplify">
<code class="descname">simplify</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_state.SimState.simplify" title="Permalink to this definition">¶</a></dt>
<dd><p>Simplify this state&#8217;s constraints.</p>
</dd></dl>

<dl class="method">
<dt id="angr.sim_state.SimState.add_constraints">
<code class="descname">add_constraints</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_state.SimState.add_constraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Add some constraints to the state.</p>
<p>You may pass in any number of symbolic booleans as variadic positional arguments.</p>
</dd></dl>

<dl class="method">
<dt id="angr.sim_state.SimState.satisfiable">
<code class="descname">satisfiable</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_state.SimState.satisfiable" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether the state&#8217;s constraints are satisfiable</p>
</dd></dl>

<dl class="method">
<dt id="angr.sim_state.SimState.downsize">
<code class="descname">downsize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_state.SimState.downsize" title="Permalink to this definition">¶</a></dt>
<dd><p>Clean up after the solver engine. Calling this when a state no longer needs to be solved on will reduce memory
usage.</p>
</dd></dl>

<dl class="method">
<dt id="angr.sim_state.SimState.step">
<code class="descname">step</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_state.SimState.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a step of symbolic execution using this state.
Any arguments to <cite>AngrObjectFactory.successors</cite> can be passed to this.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A SimSuccessors object categorizing the results of the step.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.sim_state.SimState.block">
<code class="descname">block</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_state.SimState.block" title="Permalink to this definition">¶</a></dt>
<dd><p>Represent the basic block at this state&#8217;s instruction pointer.
Any arguments to <cite>AngrObjectFactory.block</cite> can ba passed to this.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A Block object describing the basic block of code at this point.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.sim_state.SimState.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_state.SimState.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of the state.</p>
</dd></dl>

<dl class="method">
<dt id="angr.sim_state.SimState.merge">
<code class="descname">merge</code><span class="sig-paren">(</span><em>*others</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_state.SimState.merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Merges this state with the other states. Returns the merging result, merged state, and the merge flag.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>states</strong> &#8211; the states to merge</li>
<li><strong>merge_conditions</strong> &#8211; a tuple of the conditions under which each state holds</li>
<li><strong>common_ancestor</strong> &#8211; a state that represents the common history between the states being merged</li>
<li><strong>plugin_whitelist</strong> &#8211; a list of plugin names that will be merged. If this option is given and is not None,
any plugin that is not inside this list will not be merged, and will be created as a
fresh instance in the new state.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(merged state, merge flag, a bool indicating if any merging occured)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.sim_state.SimState.widen">
<code class="descname">widen</code><span class="sig-paren">(</span><em>*others</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_state.SimState.widen" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a widening between self and other states
:param others:
:return:</p>
</dd></dl>

<dl class="method">
<dt id="angr.sim_state.SimState.reg_concrete">
<code class="descname">reg_concrete</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_state.SimState.reg_concrete" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the contents of a register but, if that register is symbolic,
raises a SimValueError.</p>
</dd></dl>

<dl class="method">
<dt id="angr.sim_state.SimState.mem_concrete">
<code class="descname">mem_concrete</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_state.SimState.mem_concrete" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the contents of a memory but, if the contents are symbolic,
raises a SimValueError.</p>
</dd></dl>

<dl class="method">
<dt id="angr.sim_state.SimState.stack_push">
<code class="descname">stack_push</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_state.SimState.stack_push" title="Permalink to this definition">¶</a></dt>
<dd><p>Push &#8216;thing&#8217; to the stack, writing the thing to memory and adjusting the stack pointer.</p>
</dd></dl>

<dl class="method">
<dt id="angr.sim_state.SimState.stack_pop">
<code class="descname">stack_pop</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_state.SimState.stack_pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Pops from the stack and returns the popped thing. The length will be the architecture word size.</p>
</dd></dl>

<dl class="method">
<dt id="angr.sim_state.SimState.stack_read">
<code class="descname">stack_read</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_state.SimState.stack_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads length bytes, at an offset into the stack.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>offset</strong> &#8211; The offset from the stack pointer.</li>
<li><strong>length</strong> &#8211; The number of bytes to read.</li>
<li><strong>bp</strong> &#8211; If True, offset from the BP instead of the SP. Default: False.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.sim_state.SimState.dbg_print_stack">
<code class="descname">dbg_print_stack</code><span class="sig-paren">(</span><em>depth=None</em>, <em>sp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_state.SimState.dbg_print_stack" title="Permalink to this definition">¶</a></dt>
<dd><p>Only used for debugging purposes.
Return the current stack info in formatted string. If depth is None, the
current stack frame (from sp to bp) will be printed out.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.sim_options"></span><span class="target" id="module-angr.state_plugins"></span><span class="target" id="module-angr.state_plugins.inspect"></span><dl class="class">
<dt id="angr.state_plugins.inspect.BP">
<em class="property">class </em><code class="descclassname">angr.state_plugins.inspect.</code><code class="descname">BP</code><span class="sig-paren">(</span><em>when='before'</em>, <em>enabled=None</em>, <em>condition=None</em>, <em>action=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.state_plugins.inspect.BP" title="Permalink to this definition">¶</a></dt>
<dd><p>A breakpoint.</p>
<dl class="method">
<dt id="angr.state_plugins.inspect.BP.check">
<code class="descname">check</code><span class="sig-paren">(</span><em>state</em>, <em>when</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.state_plugins.inspect.BP.check" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks state <cite>state</cite> to see if the breakpoint should fire.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>state</strong> &#8211; The state.</li>
<li><strong>when</strong> &#8211; Whether the check is happening before or after the event.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A boolean representing whether the checkpoint should fire.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.state_plugins.inspect.BP.fire">
<code class="descname">fire</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.state_plugins.inspect.BP.fire" title="Permalink to this definition">¶</a></dt>
<dd><p>Trigger the breakpoint.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>state</strong> &#8211; The state.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="angr.state_plugins.inspect.SimInspector">
<em class="property">class </em><code class="descclassname">angr.state_plugins.inspect.</code><code class="descname">SimInspector</code><a class="headerlink" href="#angr.state_plugins.inspect.SimInspector" title="Permalink to this definition">¶</a></dt>
<dd><p>The breakpoint interface, used to instrument execution. For usage information, look here:
<a class="reference external" href="https://docs.angr.io/docs/simuvex.html#breakpoints">https://docs.angr.io/docs/simuvex.html#breakpoints</a></p>
<dl class="method">
<dt id="angr.state_plugins.inspect.SimInspector.action">
<code class="descname">action</code><span class="sig-paren">(</span><em>event_type</em>, <em>when</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.state_plugins.inspect.SimInspector.action" title="Permalink to this definition">¶</a></dt>
<dd><p>Called from within SimuVEX when events happens. This function checks all breakpoints registered for that event
and fires the ones whose conditions match.</p>
</dd></dl>

<dl class="method">
<dt id="angr.state_plugins.inspect.SimInspector.make_breakpoint">
<code class="descname">make_breakpoint</code><span class="sig-paren">(</span><em>event_type</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.state_plugins.inspect.SimInspector.make_breakpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates and adds a breakpoint which would trigger on <cite>event_type</cite>. Additional arguments are passed to the
<a class="reference internal" href="#angr.state_plugins.inspect.BP" title="angr.state_plugins.inspect.BP"><code class="xref py py-class docutils literal"><span class="pre">BP</span></code></a> constructor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The created breakpoint, so that it can be removed later.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.state_plugins.inspect.SimInspector.b">
<code class="descname">b</code><span class="sig-paren">(</span><em>event_type</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.state_plugins.inspect.SimInspector.b" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates and adds a breakpoint which would trigger on <cite>event_type</cite>. Additional arguments are passed to the
<a class="reference internal" href="#angr.state_plugins.inspect.BP" title="angr.state_plugins.inspect.BP"><code class="xref py py-class docutils literal"><span class="pre">BP</span></code></a> constructor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The created breakpoint, so that it can be removed later.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.state_plugins.inspect.SimInspector.add_breakpoint">
<code class="descname">add_breakpoint</code><span class="sig-paren">(</span><em>event_type</em>, <em>bp</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.state_plugins.inspect.SimInspector.add_breakpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a breakpoint which would trigger on <cite>event_type</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>event_type</strong> &#8211; The event type to trigger on</li>
<li><strong>bp</strong> &#8211; The breakpoint</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The created breakpoint.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.state_plugins.inspect.SimInspector.remove_breakpoint">
<code class="descname">remove_breakpoint</code><span class="sig-paren">(</span><em>event_type</em>, <em>bp=None</em>, <em>filter_func=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.state_plugins.inspect.SimInspector.remove_breakpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes a breakpoint.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>bp</strong> &#8211; The breakpoint to remove.</li>
<li><strong>filter_func</strong> &#8211; A filter function to specify whether each breakpoint should be removed or not.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.state_plugins.inspect.SimInspector.downsize">
<code class="descname">downsize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.state_plugins.inspect.SimInspector.downsize" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove previously stored attributes from this plugin instance to save memory.
This method is supposed to be called by breakpoint implementors. A typical workflow looks like the following :</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Add `attr0` and `attr1` to `self.state.inspect`</span>
<span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">inspect</span><span class="p">(</span><span class="n">xxxxxx</span><span class="p">,</span> <span class="n">attr0</span><span class="o">=</span><span class="n">yyyy</span><span class="p">,</span> <span class="n">attr1</span><span class="o">=</span><span class="n">zzzz</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Get new attributes out of SimInspect in case they are modified by the user</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_attr0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">_inspect</span><span class="o">.</span><span class="n">attr0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_attr1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">_inspect</span><span class="o">.</span><span class="n">attr1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Remove them from SimInspect</span>
<span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">_inspect</span><span class="o">.</span><span class="n">downsize</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.state_plugins.libc"></span><dl class="class">
<dt id="angr.state_plugins.libc.SimStateLibc">
<em class="property">class </em><code class="descclassname">angr.state_plugins.libc.</code><code class="descname">SimStateLibc</code><a class="headerlink" href="#angr.state_plugins.libc.SimStateLibc" title="Permalink to this definition">¶</a></dt>
<dd><p>This state plugin keeps track of various libc stuff:</p>
</dd></dl>

<span class="target" id="module-angr.state_plugins.posix"></span><dl class="class">
<dt id="angr.state_plugins.posix.Stat">
<em class="property">class </em><code class="descclassname">angr.state_plugins.posix.</code><code class="descname">Stat</code><span class="sig-paren">(</span><em>st_dev</em>, <em>st_ino</em>, <em>st_nlink</em>, <em>st_mode</em>, <em>st_uid</em>, <em>st_gid</em>, <em>st_rdev</em>, <em>st_size</em>, <em>st_blksize</em>, <em>st_blocks</em>, <em>st_atime</em>, <em>st_atimensec</em>, <em>st_mtime</em>, <em>st_mtimensec</em>, <em>st_ctime</em>, <em>st_ctimensec</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.state_plugins.posix.Stat" title="Permalink to this definition">¶</a></dt>
<dd><p>Create new instance of Stat(st_dev, st_ino, st_nlink, st_mode, st_uid, st_gid, st_rdev, st_size, st_blksize, st_blocks, st_atime, st_atimensec, st_mtime, st_mtimensec, st_ctime, st_ctimensec)</p>
<dl class="attribute">
<dt id="angr.state_plugins.posix.Stat.st_atime">
<code class="descname">st_atime</code><a class="headerlink" href="#angr.state_plugins.posix.Stat.st_atime" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 10</p>
</dd></dl>

<dl class="attribute">
<dt id="angr.state_plugins.posix.Stat.st_atimensec">
<code class="descname">st_atimensec</code><a class="headerlink" href="#angr.state_plugins.posix.Stat.st_atimensec" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 11</p>
</dd></dl>

<dl class="attribute">
<dt id="angr.state_plugins.posix.Stat.st_blksize">
<code class="descname">st_blksize</code><a class="headerlink" href="#angr.state_plugins.posix.Stat.st_blksize" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 8</p>
</dd></dl>

<dl class="attribute">
<dt id="angr.state_plugins.posix.Stat.st_blocks">
<code class="descname">st_blocks</code><a class="headerlink" href="#angr.state_plugins.posix.Stat.st_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 9</p>
</dd></dl>

<dl class="attribute">
<dt id="angr.state_plugins.posix.Stat.st_ctime">
<code class="descname">st_ctime</code><a class="headerlink" href="#angr.state_plugins.posix.Stat.st_ctime" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 14</p>
</dd></dl>

<dl class="attribute">
<dt id="angr.state_plugins.posix.Stat.st_ctimensec">
<code class="descname">st_ctimensec</code><a class="headerlink" href="#angr.state_plugins.posix.Stat.st_ctimensec" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 15</p>
</dd></dl>

<dl class="attribute">
<dt id="angr.state_plugins.posix.Stat.st_dev">
<code class="descname">st_dev</code><a class="headerlink" href="#angr.state_plugins.posix.Stat.st_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

<dl class="attribute">
<dt id="angr.state_plugins.posix.Stat.st_gid">
<code class="descname">st_gid</code><a class="headerlink" href="#angr.state_plugins.posix.Stat.st_gid" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 5</p>
</dd></dl>

<dl class="attribute">
<dt id="angr.state_plugins.posix.Stat.st_ino">
<code class="descname">st_ino</code><a class="headerlink" href="#angr.state_plugins.posix.Stat.st_ino" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

<dl class="attribute">
<dt id="angr.state_plugins.posix.Stat.st_mode">
<code class="descname">st_mode</code><a class="headerlink" href="#angr.state_plugins.posix.Stat.st_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 3</p>
</dd></dl>

<dl class="attribute">
<dt id="angr.state_plugins.posix.Stat.st_mtime">
<code class="descname">st_mtime</code><a class="headerlink" href="#angr.state_plugins.posix.Stat.st_mtime" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 12</p>
</dd></dl>

<dl class="attribute">
<dt id="angr.state_plugins.posix.Stat.st_mtimensec">
<code class="descname">st_mtimensec</code><a class="headerlink" href="#angr.state_plugins.posix.Stat.st_mtimensec" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 13</p>
</dd></dl>

<dl class="attribute">
<dt id="angr.state_plugins.posix.Stat.st_nlink">
<code class="descname">st_nlink</code><a class="headerlink" href="#angr.state_plugins.posix.Stat.st_nlink" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 2</p>
</dd></dl>

<dl class="attribute">
<dt id="angr.state_plugins.posix.Stat.st_rdev">
<code class="descname">st_rdev</code><a class="headerlink" href="#angr.state_plugins.posix.Stat.st_rdev" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 6</p>
</dd></dl>

<dl class="attribute">
<dt id="angr.state_plugins.posix.Stat.st_size">
<code class="descname">st_size</code><a class="headerlink" href="#angr.state_plugins.posix.Stat.st_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 7</p>
</dd></dl>

<dl class="attribute">
<dt id="angr.state_plugins.posix.Stat.st_uid">
<code class="descname">st_uid</code><a class="headerlink" href="#angr.state_plugins.posix.Stat.st_uid" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 4</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.state_plugins.solver"></span><dl class="class">
<dt id="angr.state_plugins.solver.SimSolver">
<em class="property">class </em><code class="descclassname">angr.state_plugins.solver.</code><code class="descname">SimSolver</code><span class="sig-paren">(</span><em>solver=None</em>, <em>all_variables=None</em>, <em>temporal_tracked_variables=None</em>, <em>eternal_tracked_variables=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.state_plugins.solver.SimSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the plugin you&#8217;ll use to interact with symbolic variables, creating them and evaluating them.
It should be available on a state as <code class="docutils literal"><span class="pre">state.solver</span></code>.</p>
<p>Any top-level variable of the claripy module can be accessed as a property of this object.</p>
<dl class="method">
<dt id="angr.state_plugins.solver.SimSolver.reload_solver">
<code class="descname">reload_solver</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.state_plugins.solver.SimSolver.reload_solver" title="Permalink to this definition">¶</a></dt>
<dd><p>Reloads the solver. Useful when changing solver options.</p>
</dd></dl>

<dl class="method">
<dt id="angr.state_plugins.solver.SimSolver.get_variables">
<code class="descname">get_variables</code><span class="sig-paren">(</span><em>*keys</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.state_plugins.solver.SimSolver.get_variables" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over all variables for which their tracking key is a prefix of the values provided.</p>
<p>Elements are a tuple, the first element is the full tracking key, the second is the symbol.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">get_variables</span><span class="p">(</span><span class="s1">&#39;mem&#39;</span><span class="p">))</span>
<span class="go">[((&#39;mem&#39;, 0x1000), &lt;BV64 mem_1000_4_64&gt;), ((&#39;mem&#39;, 0x1008), &lt;BV64 mem_1008_5_64&gt;)]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">get_variables</span><span class="p">(</span><span class="s1">&#39;file&#39;</span><span class="p">))</span>
<span class="go">[((&#39;file&#39;, 1, 0), &lt;BV8 file_1_0_6_8&gt;), ((&#39;file&#39;, 1, 1), &lt;BV8 file_1_1_7_8&gt;), ((&#39;file&#39;, 2, 0), &lt;BV8 file_2_0_8_8&gt;)]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">get_variables</span><span class="p">(</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">[((&#39;file&#39;, 2, 0), &lt;BV8 file_2_0_8_8&gt;)]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">get_variables</span><span class="p">())</span>
<span class="go">[((&#39;mem&#39;, 0x1000), &lt;BV64 mem_1000_4_64&gt;), ((&#39;mem&#39;, 0x1008), &lt;BV64 mem_1008_5_64&gt;), ((&#39;file&#39;, 1, 0), &lt;BV8 file_1_0_6_8&gt;), ((&#39;file&#39;, 1, 1), &lt;BV8 file_1_1_7_8&gt;), ((&#39;file&#39;, 2, 0), &lt;BV8 file_2_0_8_8&gt;)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="angr.state_plugins.solver.SimSolver.register_variable">
<code class="descname">register_variable</code><span class="sig-paren">(</span><em>v</em>, <em>key</em>, <em>eternal=True</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.state_plugins.solver.SimSolver.register_variable" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a value with the variable tracking system</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>v</strong> &#8211; The BVS to register</li>
<li><strong>key</strong> &#8211; A tuple to register the variable under</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parma eternal:</th><td class="field-body"><p class="first last">Whether this is an eternal variable, default True. If False, an incrementing counter will be
appended to the key.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.state_plugins.solver.SimSolver.describe_variables">
<code class="descname">describe_variables</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.state_plugins.solver.SimSolver.describe_variables" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an AST, iterate over all the keys of all the BVS leaves in the tree which are registered.</p>
</dd></dl>

<dl class="method">
<dt id="angr.state_plugins.solver.SimSolver.BVS">
<code class="descname">BVS</code><span class="sig-paren">(</span><em>name</em>, <em>size</em>, <em>min=None</em>, <em>max=None</em>, <em>stride=None</em>, <em>uninitialized=False</em>, <em>explicit_name=None</em>, <em>key=None</em>, <em>eternal=False</em>, <em>inspect=True</em>, <em>events=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.state_plugins.solver.SimSolver.BVS" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a bit-vector symbol (i.e., a variable). Other keyword parameters are passed directly on to the
constructor of claripy.ast.BV.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>name</strong> &#8211; The name of the symbol.</li>
<li><strong>size</strong> &#8211; The size (in bits) of the bit-vector.</li>
<li><strong>min</strong> &#8211; The minimum value of the symbol.</li>
<li><strong>max</strong> &#8211; The maximum value of the symbol.</li>
<li><strong>stride</strong> &#8211; The stride of the symbol.</li>
<li><strong>uninitialized</strong> &#8211; Whether this value should be counted as an &#8220;uninitialized&#8221; value in the course of an
analysis.</li>
<li><strong>explicit_name</strong> &#8211; Set to True to prevent an identifier from appended to the name to ensure uniqueness.</li>
<li><strong>key</strong> &#8211; Set this to a tuple of increasingly specific identifiers (for example,
<code class="docutils literal"><span class="pre">('mem',</span> <span class="pre">0xffbeff00)</span></code> or <code class="docutils literal"><span class="pre">('file',</span> <span class="pre">4,</span> <span class="pre">0x20)</span></code> to cause it to be tracked, i.e.
accessable through <code class="docutils literal"><span class="pre">solver.get_variables</span></code>.</li>
<li><strong>eternal</strong> &#8211; Set to True in conjunction with setting a key to cause all states with the same
ancestry to retrieve the same symbol when trying to create the value. If False, a
counter will be appended to the key.</li>
<li><strong>inspect</strong> &#8211; Set to False to avoid firing SimInspect breakpoints</li>
<li><strong>events</strong> &#8211; Set to False to avoid generating a SimEvent for the occasion</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A BV object representing this symbol.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.state_plugins.solver.SimSolver.eval_to_ast">
<code class="descname">eval_to_ast</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.state_plugins.solver.SimSolver.eval_to_ast" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate an expression, using the solver if necessary. Returns AST objects.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>e</strong> &#8211; the expression</li>
<li><strong>n</strong> &#8211; the number of desired solutions</li>
<li><strong>extra_constraints</strong> &#8211; extra constraints to apply to the solver</li>
<li><strong>exact</strong> &#8211; if False, returns approximate solutions</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">a tuple of the solutions, in the form of claripy AST nodes</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">tuple</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.state_plugins.solver.SimSolver.eval_upto">
<code class="descname">eval_upto</code><span class="sig-paren">(</span><em>e</em>, <em>n</em>, <em>cast_to=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.state_plugins.solver.SimSolver.eval_upto" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate an expression, using the solver if necessary. Returns primitives as specified by the <cite>cast_to</cite>
parameter. Only certain primitives are supported, check the implementation of <cite>_cast_to</cite> to see which ones.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>e</strong> &#8211; the expression</li>
<li><strong>n</strong> &#8211; the number of desired solutions</li>
<li><strong>extra_constraints</strong> &#8211; extra constraints to apply to the solver</li>
<li><strong>exact</strong> &#8211; if False, returns approximate solutions</li>
<li><strong>cast_to</strong> &#8211; A type to cast the resulting values to</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">a tuple of the solutions, in the form of Python primitives</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">tuple</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.state_plugins.solver.SimSolver.eval">
<code class="descname">eval</code><span class="sig-paren">(</span><em>e</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.state_plugins.solver.SimSolver.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate an expression to get any possible solution. The desired output types can be specified using the
<cite>cast_to</cite> parameter. <cite>extra_constraints</cite> can be used to specify additional constraints the returned values
must satisfy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>e</strong> &#8211; the expression to get a solution for</li>
<li><strong>kwargs</strong> &#8211; Any additional kwargs will be passed down to <cite>eval_upto</cite></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>SimUnsatError</strong> &#8211; if no solution could be found satisfying the given constraints</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.state_plugins.solver.SimSolver.eval_one">
<code class="descname">eval_one</code><span class="sig-paren">(</span><em>e</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.state_plugins.solver.SimSolver.eval_one" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate an expression to get the only possible solution. Errors if either no or more than one solution is
returned. A kwarg parameter <cite>default</cite> can be specified to be returned instead of failure!</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>e</strong> &#8211; the expression to get a solution for</li>
<li><strong>default</strong> &#8211; A value can be passed as a kwarg here. It will be returned in case of failure.</li>
<li><strong>kwargs</strong> &#8211; Any additional kwargs will be passed down to <cite>eval_upto</cite></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li><strong>SimUnsatError</strong> &#8211; if no solution could be found satisfying the given constraints</li>
<li><strong>SimValueError</strong> &#8211; if more than one solution was found to satisfy the given constraints</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The value for <cite>e</cite></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.state_plugins.solver.SimSolver.eval_atmost">
<code class="descname">eval_atmost</code><span class="sig-paren">(</span><em>e</em>, <em>n</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.state_plugins.solver.SimSolver.eval_atmost" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate an expression to get at most <cite>n</cite> possible solutions. Errors if either none or more than <cite>n</cite> solutions
are returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>e</strong> &#8211; the expression to get a solution for</li>
<li><strong>n</strong> &#8211; the inclusive upper limit on the number of solutions</li>
<li><strong>kwargs</strong> &#8211; Any additional kwargs will be passed down to <cite>eval_upto</cite></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li><strong>SimUnsatError</strong> &#8211; if no solution could be found satisfying the given constraints</li>
<li><strong>SimValueError</strong> &#8211; if more than <cite>n</cite> solutions were found to satisfy the given constraints</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The solutions for <cite>e</cite></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.state_plugins.solver.SimSolver.eval_atleast">
<code class="descname">eval_atleast</code><span class="sig-paren">(</span><em>e</em>, <em>n</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.state_plugins.solver.SimSolver.eval_atleast" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate an expression to get at least <cite>n</cite> possible solutions. Errors if less than <cite>n</cite> solutions were found.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>e</strong> &#8211; the expression to get a solution for</li>
<li><strong>n</strong> &#8211; the inclusive lower limit on the number of solutions</li>
<li><strong>kwargs</strong> &#8211; Any additional kwargs will be passed down to <cite>eval_upto</cite></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li><strong>SimUnsatError</strong> &#8211; if no solution could be found satisfying the given constraints</li>
<li><strong>SimValueError</strong> &#8211; if less than <cite>n</cite> solutions were found to satisfy the given constraints</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The solutions for <cite>e</cite></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.state_plugins.solver.SimSolver.eval_exact">
<code class="descname">eval_exact</code><span class="sig-paren">(</span><em>e</em>, <em>n</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.state_plugins.solver.SimSolver.eval_exact" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate an expression to get exactly the <cite>n</cite> possible solutions. Errors if any number of solutions other
than <cite>n</cite> was found to exist.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>e</strong> &#8211; the expression to get a solution for</li>
<li><strong>n</strong> &#8211; the inclusive lower limit on the number of solutions</li>
<li><strong>kwargs</strong> &#8211; Any additional kwargs will be passed down to <cite>eval_upto</cite></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li><strong>SimUnsatError</strong> &#8211; if no solution could be found satisfying the given constraints</li>
<li><strong>SimValueError</strong> &#8211; if any number of solutions other than <cite>n</cite> were found to satisfy the given constraints</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The solutions for <cite>e</cite></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-angr.storage">
<span id="storage"></span><h2>Storage<a class="headerlink" href="#module-angr.storage" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-angr.state_plugins.view"></span><dl class="class">
<dt id="angr.state_plugins.view.SimMemView">
<em class="property">class </em><code class="descclassname">angr.state_plugins.view.</code><code class="descname">SimMemView</code><span class="sig-paren">(</span><em>ty=None</em>, <em>addr=None</em>, <em>state=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.state_plugins.view.SimMemView" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a convenient interface with which you can access a program&#8217;s memory.</p>
<p>The interface works like this:</p>
<blockquote>
<div><ul class="simple">
<li>You first use [array index notation] to specify the address you&#8217;d like to load from</li>
<li>If at that address is a pointer, you may access the <code class="docutils literal"><span class="pre">deref</span></code> property to return a SimMemView at the
address present in memory.</li>
<li>You then specify a type for the data by simply accesing a property of that name. For a list of supported
types, look at <code class="docutils literal"><span class="pre">state.mem.types</span></code>.</li>
<li>You can then <em>refine</em> the type. Any type may support any refinement it likes. Right now the only refinements
supported are that you may access any member of a struct by its member name, and you may index into a
string or array to access that element.</li>
<li>If the address you specified initially points to an array of that type, you can say <cite>.array(n)</cite> to view the
data as an array of n elements.</li>
<li>Finally, extract the structured data with <code class="docutils literal"><span class="pre">.resolved</span></code> or <code class="docutils literal"><span class="pre">.concrete</span></code>. <code class="docutils literal"><span class="pre">.resolved</span></code> will return bitvector
values, while <code class="docutils literal"><span class="pre">.concrete</span></code> will return integer, string, array, etc values, whatever best represents the
data.</li>
<li>Alternately, you may store a value to memory, by assigning to the chain of properties that you&#8217;ve
constructed. Note that because of the way python works, <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">s.mem[...].prop;</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">val</span></code> will NOT work,
you must say <code class="docutils literal"><span class="pre">s.mem[...].prop</span> <span class="pre">=</span> <span class="pre">val</span></code>.</li>
</ul>
</div></blockquote>
<p>For example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">mem</span><span class="p">[</span><span class="mh">0x601048</span><span class="p">]</span><span class="o">.</span><span class="n">long</span>
<span class="go">&lt;long (64 bits) &lt;BV64 0x4008d0&gt; at 0x601048&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">mem</span><span class="p">[</span><span class="mh">0x601048</span><span class="p">]</span><span class="o">.</span><span class="n">long</span><span class="o">.</span><span class="n">resolved</span>
<span class="go">&lt;BV64 0x4008d0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">mem</span><span class="p">[</span><span class="mh">0x601048</span><span class="p">]</span><span class="o">.</span><span class="n">deref</span>
<span class="go">&lt;&lt;untyped&gt; &lt;unresolvable&gt; at 0x4008d0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">mem</span><span class="p">[</span><span class="mh">0x601048</span><span class="p">]</span><span class="o">.</span><span class="n">deref</span><span class="o">.</span><span class="n">string</span><span class="o">.</span><span class="n">concrete</span>
<span class="go">&#39;SOSNEAKY&#39;</span>
</pre></div>
</div>
</dd></dl>

<span class="target" id="module-angr.storage.file"></span><dl class="class">
<dt id="angr.storage.file.SimFile">
<em class="property">class </em><code class="descclassname">angr.storage.file.</code><code class="descname">SimFile</code><span class="sig-paren">(</span><em>name</em>, <em>mode</em>, <em>pos=0</em>, <em>content=None</em>, <em>size=None</em>, <em>closed=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.file.SimFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a file.</p>
<dl class="method">
<dt id="angr.storage.file.SimFile.variables">
<code class="descname">variables</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.file.SimFile.variables" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the symbolic variable names associated with the file.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.storage.file.SimFile.read">
<code class="descname">read</code><span class="sig-paren">(</span><em>dst_addr</em>, <em>length</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.file.SimFile.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads some data from the current (or provided) position of the file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dst_addr</strong> &#8211; If specified, the data is written to that address.</li>
<li><strong>length</strong> &#8211; The length of the read.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The length of the read.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.storage.file.SimFile.concretize">
<code class="descname">concretize</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.file.SimFile.concretize" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a concrete value for this file satisfying the current state constraints.</p>
<p>Or: generate a testcase for this file.</p>
</dd></dl>

<dl class="method">
<dt id="angr.storage.file.SimFile.merge">
<code class="descname">merge</code><span class="sig-paren">(</span><em>others</em>, <em>merge_conditions</em>, <em>common_ancestor=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.file.SimFile.merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Merges the SimFile object with <cite>others</cite>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="angr.storage.file.SimDialogue">
<em class="property">class </em><code class="descclassname">angr.storage.file.</code><code class="descname">SimDialogue</code><span class="sig-paren">(</span><em>name</em>, <em>mode=None</em>, <em>pos=0</em>, <em>content=None</em>, <em>size=None</em>, <em>dialogue_entries=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.file.SimDialogue" title="Permalink to this definition">¶</a></dt>
<dd><p>Emulates a dialogue with a program. Enables us to perform concrete short reads.</p>
<dl class="method">
<dt id="angr.storage.file.SimDialogue.add_dialogue_entry">
<code class="descname">add_dialogue_entry</code><span class="sig-paren">(</span><em>dialogue_len</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.file.SimDialogue.add_dialogue_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a new dialogue piece to the end of the dialogue.</p>
</dd></dl>

<dl class="method">
<dt id="angr.storage.file.SimDialogue.read">
<code class="descname">read</code><span class="sig-paren">(</span><em>dst_addr</em>, <em>length</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.file.SimDialogue.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads some data from current dialogue entry, emulates short reads.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.storage.memory"></span><dl class="class">
<dt id="angr.storage.memory.AddressWrapper">
<em class="property">class </em><code class="descclassname">angr.storage.memory.</code><code class="descname">AddressWrapper</code><span class="sig-paren">(</span><em>region</em>, <em>region_base_addr</em>, <em>address</em>, <em>is_on_stack</em>, <em>function_address</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.memory.AddressWrapper" title="Permalink to this definition">¶</a></dt>
<dd><p>AddressWrapper is used in SimAbstractMemory, which provides extra meta information for an address (or a ValueSet
object) that is normalized from an integer/BVV/StridedInterval.</p>
<p>Constructor for the class AddressWrapper.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>strregion</strong> &#8211; Name of the memory regions it belongs to.</li>
<li><strong>region_base_addr</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; Base address of the memory region</li>
<li><strong>address</strong> &#8211; An address (not a ValueSet object).</li>
<li><strong>is_on_stack</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; Whether this address is on a stack region or not.</li>
<li><strong>function_address</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; Related function address (if any).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="angr.storage.memory.AddressWrapper.to_valueset">
<code class="descname">to_valueset</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.memory.AddressWrapper.to_valueset" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to a ValueSet instance</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>state</strong> &#8211; A state</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The converted ValueSet instance</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="angr.storage.memory.RegionDescriptor">
<em class="property">class </em><code class="descclassname">angr.storage.memory.</code><code class="descname">RegionDescriptor</code><span class="sig-paren">(</span><em>region_id</em>, <em>base_address</em>, <em>related_function_address=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.memory.RegionDescriptor" title="Permalink to this definition">¶</a></dt>
<dd><p>Descriptor for a memory region ID.</p>
</dd></dl>

<dl class="class">
<dt id="angr.storage.memory.RegionMap">
<em class="property">class </em><code class="descclassname">angr.storage.memory.</code><code class="descname">RegionMap</code><span class="sig-paren">(</span><em>is_stack</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.memory.RegionMap" title="Permalink to this definition">¶</a></dt>
<dd><p>Mostly used in SimAbstractMemory, RegionMap stores a series of mappings between concrete memory address ranges and
memory regions, like stack frames and heap regions.</p>
<p>Constructor</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>is_stack</strong> &#8211; Whether this is a region map for stack frames or not. Different strategies apply for stack
regions.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="angr.storage.memory.RegionMap.map">
<code class="descname">map</code><span class="sig-paren">(</span><em>absolute_address</em>, <em>region_id</em>, <em>related_function_address=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.memory.RegionMap.map" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a mapping between an absolute address and a region ID. If this is a stack region map, all stack regions
beyond (lower than) this newly added regions will be discarded.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>absolute_address</strong> &#8211; An absolute memory address.</li>
<li><strong>region_id</strong> &#8211; ID of the memory region.</li>
<li><strong>related_function_address</strong> &#8211; A related function address, mostly used for stack regions.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.storage.memory.RegionMap.unmap_by_address">
<code class="descname">unmap_by_address</code><span class="sig-paren">(</span><em>absolute_address</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.memory.RegionMap.unmap_by_address" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes a mapping based on its absolute address.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>absolute_address</strong> &#8211; An absolute address</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.storage.memory.RegionMap.absolutize">
<code class="descname">absolutize</code><span class="sig-paren">(</span><em>region_id</em>, <em>relative_address</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.memory.RegionMap.absolutize" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a relative address in some memory region to an absolute address.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>region_id</strong> &#8211; The memory region ID</li>
<li><strong>relative_address</strong> &#8211; The relative memory offset in that memory region</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An absolute address if converted, or an exception is raised when region id does not
exist.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.storage.memory.RegionMap.relativize">
<code class="descname">relativize</code><span class="sig-paren">(</span><em>absolute_address</em>, <em>target_region_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.memory.RegionMap.relativize" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an absolute address to the memory offset in a memory region.</p>
<p>Note that if an address belongs to heap region is passed in to a stack region map, it will be converted to an
offset included in the closest stack frame, and vice versa for passing a stack address to a heap region.
Therefore you should only pass in address that belongs to the same category (stack or non-stack) of this region
map.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>absolute_address</strong> &#8211; An absolute memory address</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A tuple of the closest region ID, the relative offset, and the related function
address.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="angr.storage.memory.MemoryStoreRequest">
<em class="property">class </em><code class="descclassname">angr.storage.memory.</code><code class="descname">MemoryStoreRequest</code><span class="sig-paren">(</span><em>addr</em>, <em>data=None</em>, <em>size=None</em>, <em>condition=None</em>, <em>endness=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.memory.MemoryStoreRequest" title="Permalink to this definition">¶</a></dt>
<dd><p>A MemoryStoreRequest is used internally by SimMemory to track memory request data.</p>
</dd></dl>

<dl class="class">
<dt id="angr.storage.memory.SimMemory">
<em class="property">class </em><code class="descclassname">angr.storage.memory.</code><code class="descname">SimMemory</code><span class="sig-paren">(</span><em>endness=None</em>, <em>abstract_backer=None</em>, <em>stack_region_map=None</em>, <em>generic_region_map=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.memory.SimMemory" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents the memory space of the process.</p>
<dl class="attribute">
<dt id="angr.storage.memory.SimMemory.category">
<code class="descname">category</code><a class="headerlink" href="#angr.storage.memory.SimMemory.category" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Return the category of this SimMemory instance. It can be one of the three following categories</em> &#8211; reg, mem,
or file.</p>
</dd></dl>

<dl class="method">
<dt id="angr.storage.memory.SimMemory.set_state">
<code class="descname">set_state</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.memory.SimMemory.set_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Call the set_state method in SimStatePlugin class, and then perform the delayed initialization.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>state</strong> &#8211; The SimState instance</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.storage.memory.SimMemory.set_stack_address_mapping">
<code class="descname">set_stack_address_mapping</code><span class="sig-paren">(</span><em>absolute_address</em>, <em>region_id</em>, <em>related_function_address=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.memory.SimMemory.set_stack_address_mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new mapping between an absolute address (which is the base address of a specific stack frame) and a
region ID.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>absolute_address</strong> &#8211; The absolute memory address.</li>
<li><strong>region_id</strong> &#8211; The region ID.</li>
<li><strong>related_function_address</strong> &#8211; Related function address.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.storage.memory.SimMemory.unset_stack_address_mapping">
<code class="descname">unset_stack_address_mapping</code><span class="sig-paren">(</span><em>absolute_address</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.memory.SimMemory.unset_stack_address_mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a stack mapping.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>absolute_address</strong> &#8211; An absolute memory address, which is the base address of the stack frame to destroy.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.storage.memory.SimMemory.stack_id">
<code class="descname">stack_id</code><span class="sig-paren">(</span><em>function_address</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.memory.SimMemory.stack_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a memory region ID for a function. If the default region ID exists in the region mapping, an integer
will appended to the region name. In this way we can handle recursive function calls, or a function that
appears more than once in the call frame.</p>
<p>This also means that <cite>stack_id()</cite> should only be called when creating a new stack frame for a function. You are
not supposed to call this function every time you want to map a function address to a stack ID.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>function_address</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; Address of the function.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">ID of the new memory region.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.storage.memory.SimMemory.store">
<code class="descname">store</code><span class="sig-paren">(</span><em>addr</em>, <em>data</em>, <em>size=None</em>, <em>condition=None</em>, <em>add_constraints=None</em>, <em>endness=None</em>, <em>action=None</em>, <em>inspect=True</em>, <em>priv=None</em>, <em>disable_actions=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.memory.SimMemory.store" title="Permalink to this definition">¶</a></dt>
<dd><p>Stores content into memory.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>addr</strong> &#8211; A claripy expression representing the address to store at.</li>
<li><strong>data</strong> &#8211; The data to store (claripy expression or something convertable to a claripy expression).</li>
<li><strong>size</strong> &#8211; A claripy expression representing the size of the data to store.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The following parameters are optional.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>condition</strong> &#8211; A claripy expression representing a condition if the store is conditional.</li>
<li><strong>add_constraints</strong> &#8211; Add constraints resulting from the merge (default: True).</li>
<li><strong>endness</strong> &#8211; The endianness for the data.</li>
<li><strong>action</strong> &#8211; A SimActionData to fill out with the final written value and constraints.</li>
<li><strong>inspect</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; Whether this store should trigger SimInspect breakpoints or not.</li>
<li><strong>disable_actions</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; Whether this store should avoid creating SimActions or not. When set to False,
state options are respected.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.storage.memory.SimMemory.store_cases">
<code class="descname">store_cases</code><span class="sig-paren">(</span><em>addr</em>, <em>contents</em>, <em>conditions</em>, <em>fallback=None</em>, <em>add_constraints=None</em>, <em>endness=None</em>, <em>action=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.memory.SimMemory.store_cases" title="Permalink to this definition">¶</a></dt>
<dd><p>Stores content into memory, conditional by case.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>addr</strong> &#8211; A claripy expression representing the address to store at.</li>
<li><strong>contents</strong> &#8211; A list of bitvectors, not necessarily of the same size. Use None to denote an empty
write.</li>
<li><strong>conditions</strong> &#8211; A list of conditions. Must be equal in length to contents.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The following parameters are optional.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fallback</strong> &#8211; A claripy expression representing what the write should resolve to if all conditions
evaluate to false (default: whatever was there before).</li>
<li><strong>add_constraints</strong> &#8211; Add constraints resulting from the merge (default: True)</li>
<li><strong>endness</strong> &#8211; The endianness for contents as well as fallback.</li>
<li><strong>action</strong> (<a class="reference internal" href="#angr.state_plugins.sim_action.SimActionData" title="angr.state_plugins.sim_action.SimActionData"><em>SimActionData</em></a>) &#8211; A SimActionData to fill out with the final written value and constraints.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.storage.memory.SimMemory.load">
<code class="descname">load</code><span class="sig-paren">(</span><em>addr</em>, <em>size=None</em>, <em>condition=None</em>, <em>fallback=None</em>, <em>add_constraints=None</em>, <em>action=None</em>, <em>endness=None</em>, <em>inspect=True</em>, <em>disable_actions=False</em>, <em>ret_on_segv=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.memory.SimMemory.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads size bytes from dst.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dst</strong> &#8211; The address to load from.</li>
<li><strong>size</strong> &#8211; The size (in bytes) of the load.</li>
<li><strong>condition</strong> &#8211; A claripy expression representing a condition for a conditional load.</li>
<li><strong>fallback</strong> &#8211; A fallback value if the condition ends up being False.</li>
<li><strong>add_constraints</strong> &#8211; Add constraints resulting from the merge (default: True).</li>
<li><strong>action</strong> &#8211; A SimActionData to fill out with the constraints.</li>
<li><strong>endness</strong> &#8211; The endness to load with.</li>
<li><strong>inspect</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; Whether this store should trigger SimInspect breakpoints or not.</li>
<li><strong>disable_actions</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; Whether this store should avoid creating SimActions or not. When set to False,
state options are respected.</li>
<li><strong>ret_on_segv</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; Whether returns the memory that is already loaded before a segmentation fault is triggered. The default is False.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>There are a few possible return values. If no condition or fallback are passed in,
then the return is the bytes at the address, in the form of a claripy expression.
For example:</p>
<blockquote>
<div>&lt;A BVV(0x41, 32)&gt;</div></blockquote>
<p>On the other hand, if a condition and fallback are provided, the value is conditional:</p>
<blockquote>
<div>&lt;A If(condition, BVV(0x41, 32), fallback)&gt;</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="angr.storage.memory.SimMemory.normalize_address">
<code class="descname">normalize_address</code><span class="sig-paren">(</span><em>addr</em>, <em>is_write=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.memory.SimMemory.normalize_address" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalize <cite>addr</cite> for use in static analysis (with the abstract memory model). In non-abstract mode, simply
returns the address in a single-element list.</p>
</dd></dl>

<dl class="method">
<dt id="angr.storage.memory.SimMemory.find">
<code class="descname">find</code><span class="sig-paren">(</span><em>addr</em>, <em>what</em>, <em>max_search=None</em>, <em>max_symbolic_bytes=None</em>, <em>default=None</em>, <em>step=1</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.memory.SimMemory.find" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the address of bytes equal to &#8216;what&#8217;, starting from &#8216;start&#8217;. Note that,  if you don&#8217;t specify a default
value, this search could cause the state to go unsat if no possible matching byte exists.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>addr</strong> &#8211; The start address.</li>
<li><strong>what</strong> &#8211; What to search for;</li>
<li><strong>max_search</strong> &#8211; Search at most this many bytes.</li>
<li><strong>max_symbolic_bytes</strong> &#8211; Search through at most this many symbolic bytes.</li>
<li><strong>default</strong> &#8211; The default value, if what you&#8217;re looking for wasn&#8217;t found.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An expression representing the address of the matching byte.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.storage.memory.SimMemory.copy_contents">
<code class="descname">copy_contents</code><span class="sig-paren">(</span><em>dst</em>, <em>src</em>, <em>size</em>, <em>condition=None</em>, <em>src_memory=None</em>, <em>dst_memory=None</em>, <em>inspect=True</em>, <em>disable_actions=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.memory.SimMemory.copy_contents" title="Permalink to this definition">¶</a></dt>
<dd><p>Copies data within a memory.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dst</strong> &#8211; A claripy expression representing the address of the destination</li>
<li><strong>src</strong> &#8211; A claripy expression representing the address of the source</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The following parameters are optional.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src_memory</strong> &#8211; Copy data from this SimMemory instead of self</li>
<li><strong>src_memory</strong> &#8211; Copy data to this SimMemory instead of self</li>
<li><strong>size</strong> &#8211; A claripy expression representing the size of the copy</li>
<li><strong>condition</strong> &#8211; A claripy expression representing a condition, if the write should be conditional. If this
is determined to be false, the size of the copy will be 0.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.state_plugins.symbolic_memory"></span><span class="target" id="module-angr.state_plugins.abstract_memory"></span><dl class="class">
<dt id="angr.state_plugins.abstract_memory.SimAbstractMemory">
<em class="property">class </em><code class="descclassname">angr.state_plugins.abstract_memory.</code><code class="descname">SimAbstractMemory</code><span class="sig-paren">(</span><em>memory_backer=None</em>, <em>memory_id='mem'</em>, <em>endness=None</em>, <em>stack_region_map=None</em>, <em>generic_region_map=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.state_plugins.abstract_memory.SimAbstractMemory" title="Permalink to this definition">¶</a></dt>
<dd><p>This is an implementation of the abstract store in paper [TODO].</p>
<p>Some differences:</p>
<blockquote>
<div><ul class="simple">
<li>For stack variables, we map the absolute stack address to each region so
that we can effectively trace stack accesses. When tracing into a new
function, you should call set_stack_address_mapping() to create a new mapping.
When exiting from a function, you should cancel the previous mapping by
calling unset_stack_address_mapping().
Currently this is only used for stack!</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="angr.state_plugins.abstract_memory.SimAbstractMemory.create_region">
<code class="descname">create_region</code><span class="sig-paren">(</span><em>key</em>, <em>state</em>, <em>is_stack</em>, <em>related_function_addr</em>, <em>endness</em>, <em>backer_dict=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.state_plugins.abstract_memory.SimAbstractMemory.create_region" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new MemoryRegion with the region key specified, and store it to self._regions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>key</strong> &#8211; a string which is the region key</li>
<li><strong>state</strong> &#8211; the SimState instance</li>
<li><strong>is_stack</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; Whether this memory region is on stack. True/False</li>
<li><strong>related_function_addr</strong> &#8211; Which function first creates this memory region. Just for reference.</li>
<li><strong>endness</strong> &#8211; The endianness.</li>
<li><strong>backer_dict</strong> &#8211; The memory backer object.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.state_plugins.abstract_memory.SimAbstractMemory.set_state">
<code class="descname">set_state</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.state_plugins.abstract_memory.SimAbstractMemory.set_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Overriding the SimStatePlugin.set_state() method</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>state</strong> &#8211; A SimState object</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.state_plugins.abstract_memory.SimAbstractMemory.normalize_address">
<code class="descname">normalize_address</code><span class="sig-paren">(</span><em>addr</em>, <em>is_write=False</em>, <em>convert_to_valueset=False</em>, <em>target_region=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.state_plugins.abstract_memory.SimAbstractMemory.normalize_address" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a ValueSet object into a list of addresses.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>addr</strong> &#8211; A ValueSet object (which describes an address)</li>
<li><strong>is_write</strong> &#8211; Is this address used in a write or not</li>
<li><strong>convert_to_valueset</strong> &#8211; True if you want to have a list of ValueSet instances instead of AddressWrappers,
False otherwise</li>
<li><strong>target_region</strong> &#8211; Which region to normalize the address to. To leave the decision to SimuVEX, set it to None</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A list of AddressWrapper or ValueSet objects</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.state_plugins.abstract_memory.SimAbstractMemory.get_segments">
<code class="descname">get_segments</code><span class="sig-paren">(</span><em>addr</em>, <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.state_plugins.abstract_memory.SimAbstractMemory.get_segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a segmented memory region based on AbstractLocation information available from VSA.</p>
<dl class="docutils">
<dt>Here are some assumptions to make this method fast:</dt>
<dd><ul class="first last simple">
<li>The entire memory region [addr, addr + size] is located within the same MemoryRegion</li>
<li>The address &#8216;addr&#8217; has only one concrete value. It cannot be concretized to multiple values.</li>
</ul>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>addr</strong> &#8211; An address</li>
<li><strong>size</strong> &#8211; Size of the memory area in bytes</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An ordered list of sizes each segment in the requested memory region</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.state_plugins.abstract_memory.SimAbstractMemory.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.state_plugins.abstract_memory.SimAbstractMemory.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a copy of this SimAbstractMemory object
:return:</p>
</dd></dl>

<dl class="method">
<dt id="angr.state_plugins.abstract_memory.SimAbstractMemory.merge">
<code class="descname">merge</code><span class="sig-paren">(</span><em>others</em>, <em>merge_conditions</em>, <em>common_ancestor=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.state_plugins.abstract_memory.SimAbstractMemory.merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge this guy with another SimAbstractMemory instance</p>
</dd></dl>

<dl class="method">
<dt id="angr.state_plugins.abstract_memory.SimAbstractMemory.map_region">
<code class="descname">map_region</code><span class="sig-paren">(</span><em>addr</em>, <em>length</em>, <em>permissions</em>, <em>init_zero=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.state_plugins.abstract_memory.SimAbstractMemory.map_region" title="Permalink to this definition">¶</a></dt>
<dd><p>Map a number of pages at address <cite>addr</cite> with permissions <cite>permissions</cite>.
:param addr: address to map the pages at
:param length: length in bytes of region to map, will be rounded upwards to the page size
:param permissions: AST of permissions to map, will be a bitvalue representing flags
:param init_zero: Initialize page with zeros</p>
</dd></dl>

<dl class="method">
<dt id="angr.state_plugins.abstract_memory.SimAbstractMemory.unmap_region">
<code class="descname">unmap_region</code><span class="sig-paren">(</span><em>addr</em>, <em>length</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.state_plugins.abstract_memory.SimAbstractMemory.unmap_region" title="Permalink to this definition">¶</a></dt>
<dd><p>Unmap a number of pages at address <cite>addr</cite>
:param addr: address to unmap the pages at
:param length: length in bytes of region to map, will be rounded upwards to the page size</p>
</dd></dl>

<dl class="method">
<dt id="angr.state_plugins.abstract_memory.SimAbstractMemory.dbg_print">
<code class="descname">dbg_print</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.state_plugins.abstract_memory.SimAbstractMemory.dbg_print" title="Permalink to this definition">¶</a></dt>
<dd><p>Print out debugging information</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.storage.memory_object"></span><dl class="class">
<dt id="angr.storage.memory_object.SimMemoryObject">
<em class="property">class </em><code class="descclassname">angr.storage.memory_object.</code><code class="descname">SimMemoryObject</code><span class="sig-paren">(</span><em>object</em>, <em>base</em>, <em>length=None</em>, <em>byte_width=8</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.memory_object.SimMemoryObject" title="Permalink to this definition">¶</a></dt>
<dd><p>A MemoryObjectRef instance is a reference to a byte or several bytes in
a specific object in SimSymbolicMemory. It is only used inside
SimSymbolicMemory class.</p>
</dd></dl>

<span class="target" id="module-angr.storage.paged_memory"></span><dl class="class">
<dt id="angr.storage.paged_memory.BasePage">
<em class="property">class </em><code class="descclassname">angr.storage.paged_memory.</code><code class="descname">BasePage</code><span class="sig-paren">(</span><em>page_addr</em>, <em>page_size</em>, <em>permissions=None</em>, <em>executable=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.paged_memory.BasePage" title="Permalink to this definition">¶</a></dt>
<dd><p>Page object, allowing for more flexibility than just a raw dict.</p>
<p>Create a new page object. Carries permissions information.
Permissions default to RW unless <cite>executable</cite> is True,
in which case permissions default to RWX.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>page_addr</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The base address of the page.</li>
<li><strong>page_size</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The size of the page.</li>
<li><strong>executable</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; Whether the page is executable. Typically,
this will depend on whether the binary has an
executable stack.</li>
<li><strong>permissions</strong> (<em>claripy.AST</em>) &#8211; A 3-bit bitvector setting specific permissions
for EXEC, READ, and WRITE</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="angr.storage.paged_memory.BasePage.store_mo">
<code class="descname">store_mo</code><span class="sig-paren">(</span><em>state</em>, <em>new_mo</em>, <em>overwrite=True</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.paged_memory.BasePage.store_mo" title="Permalink to this definition">¶</a></dt>
<dd><p>Stores a memory object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>new_mo</strong> &#8211; the memory object</li>
<li><strong>overwrite</strong> &#8211; whether to overwrite objects already in memory (if false, just fill in the holes)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.storage.paged_memory.BasePage.load_mo">
<code class="descname">load_mo</code><span class="sig-paren">(</span><em>state</em>, <em>page_idx</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.paged_memory.BasePage.load_mo" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads a memory object from memory.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>page_idx</strong> &#8211; the index into the page</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a tuple of the object</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.storage.paged_memory.BasePage.load_slice">
<code class="descname">load_slice</code><span class="sig-paren">(</span><em>state</em>, <em>start</em>, <em>end</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.paged_memory.BasePage.load_slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the memory objects overlapping with the provided slice.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>start</strong> &#8211; the start address</li>
<li><strong>end</strong> &#8211; the end address (non-inclusive)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">tuples of (starting_addr, memory_object)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="angr.storage.paged_memory.TreePage">
<em class="property">class </em><code class="descclassname">angr.storage.paged_memory.</code><code class="descname">TreePage</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.paged_memory.TreePage" title="Permalink to this definition">¶</a></dt>
<dd><p>Page object, implemented with a bintree.</p>
<dl class="method">
<dt id="angr.storage.paged_memory.TreePage.load_mo">
<code class="descname">load_mo</code><span class="sig-paren">(</span><em>state</em>, <em>page_idx</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.paged_memory.TreePage.load_mo" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads a memory object from memory.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>page_idx</strong> &#8211; the index into the page</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a tuple of the object</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.storage.paged_memory.TreePage.load_slice">
<code class="descname">load_slice</code><span class="sig-paren">(</span><em>state</em>, <em>start</em>, <em>end</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.paged_memory.TreePage.load_slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the memory objects overlapping with the provided slice.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>start</strong> &#8211; the start address</li>
<li><strong>end</strong> &#8211; the end address (non-inclusive)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">tuples of (starting_addr, memory_object)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="angr.storage.paged_memory.ListPage">
<em class="property">class </em><code class="descclassname">angr.storage.paged_memory.</code><code class="descname">ListPage</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.paged_memory.ListPage" title="Permalink to this definition">¶</a></dt>
<dd><p>Page object, implemented with a list.</p>
<dl class="method">
<dt id="angr.storage.paged_memory.ListPage.load_mo">
<code class="descname">load_mo</code><span class="sig-paren">(</span><em>state</em>, <em>page_idx</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.paged_memory.ListPage.load_mo" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads a memory object from memory.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>page_idx</strong> &#8211; the index into the page</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a tuple of the object</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.storage.paged_memory.ListPage.load_slice">
<code class="descname">load_slice</code><span class="sig-paren">(</span><em>state</em>, <em>start</em>, <em>end</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.paged_memory.ListPage.load_slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the memory objects overlapping with the provided slice.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>start</strong> &#8211; the start address</li>
<li><strong>end</strong> &#8211; the end address (non-inclusive)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">tuples of (starting_addr, memory_object)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="angr.storage.paged_memory.Page">
<code class="descclassname">angr.storage.paged_memory.</code><code class="descname">Page</code><a class="headerlink" href="#angr.storage.paged_memory.Page" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#angr.storage.paged_memory.ListPage" title="angr.storage.paged_memory.ListPage"><code class="xref py py-class docutils literal"><span class="pre">ListPage</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="angr.storage.paged_memory.SimPagedMemory">
<em class="property">class </em><code class="descclassname">angr.storage.paged_memory.</code><code class="descname">SimPagedMemory</code><span class="sig-paren">(</span><em>memory_backer=None</em>, <em>permissions_backer=None</em>, <em>pages=None</em>, <em>initialized=None</em>, <em>name_mapping=None</em>, <em>hash_mapping=None</em>, <em>page_size=None</em>, <em>symbolic_addrs=None</em>, <em>check_permissions=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.paged_memory.SimPagedMemory" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents paged memory.</p>
<dl class="method">
<dt id="angr.storage.paged_memory.SimPagedMemory.load_objects">
<code class="descname">load_objects</code><span class="sig-paren">(</span><em>addr</em>, <em>num_bytes</em>, <em>ret_on_segv=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.paged_memory.SimPagedMemory.load_objects" title="Permalink to this definition">¶</a></dt>
<dd><p>Load memory objects from paged memory.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>addr</strong> &#8211; Address to start loading.</li>
<li><strong>num_bytes</strong> &#8211; Number of bytes to load.</li>
<li><strong>ret_on_segv</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; True if you want load_bytes to return directly when a SIGSEV is triggered, otherwise
a SimSegfaultError will be raised.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">list of tuples of (addr, memory_object)</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">tuple</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.storage.paged_memory.SimPagedMemory.contains_no_backer">
<code class="descname">contains_no_backer</code><span class="sig-paren">(</span><em>addr</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.paged_memory.SimPagedMemory.contains_no_backer" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests if the address is contained in any page of paged memory, without considering memory backers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>addr</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The address to test.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if the address is included in one of the pages, False otherwise.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool">bool</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.storage.paged_memory.SimPagedMemory.store_memory_object">
<code class="descname">store_memory_object</code><span class="sig-paren">(</span><em>mo</em>, <em>overwrite=True</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.paged_memory.SimPagedMemory.store_memory_object" title="Permalink to this definition">¶</a></dt>
<dd><p>This function optimizes a large store by storing a single reference to the <code class="xref py py-class docutils literal"><span class="pre">SimMemoryObject</span></code> instead of
one for each byte.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>memory_object</strong> &#8211; the memory object to store</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.storage.paged_memory.SimPagedMemory.replace_memory_object">
<code class="descname">replace_memory_object</code><span class="sig-paren">(</span><em>old</em>, <em>new_content</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.paged_memory.SimPagedMemory.replace_memory_object" title="Permalink to this definition">¶</a></dt>
<dd><p>Replaces the memory object <cite>old</cite> with a new memory object containing <cite>new_content</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>old</strong> &#8211; A SimMemoryObject (i.e., one from <a class="reference internal" href="#angr.storage.paged_memory.SimPagedMemory.memory_objects_for_hash" title="angr.storage.paged_memory.SimPagedMemory.memory_objects_for_hash"><code class="xref py py-func docutils literal"><span class="pre">memory_objects_for_hash()</span></code></a> or :func:`
memory_objects_for_name()`).</li>
<li><strong>new_content</strong> &#8211; The content (claripy expression) for the new memory object.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the new memory object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.storage.paged_memory.SimPagedMemory.replace_all">
<code class="descname">replace_all</code><span class="sig-paren">(</span><em>old</em>, <em>new</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.paged_memory.SimPagedMemory.replace_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Replaces all instances of expression <cite>old</cite> with expression <cite>new</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>old</strong> &#8211; A claripy expression. Must contain at least one named variable (to make it possible to use the
name index for speedup).</li>
<li><strong>new</strong> &#8211; The new variable to replace it with.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.storage.paged_memory.SimPagedMemory.addrs_for_name">
<code class="descname">addrs_for_name</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.paged_memory.SimPagedMemory.addrs_for_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns addresses that contain expressions that contain a variable named <cite>n</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="angr.storage.paged_memory.SimPagedMemory.addrs_for_hash">
<code class="descname">addrs_for_hash</code><span class="sig-paren">(</span><em>h</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.paged_memory.SimPagedMemory.addrs_for_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns addresses that contain expressions that contain a variable with the hash of <cite>h</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="angr.storage.paged_memory.SimPagedMemory.memory_objects_for_name">
<code class="descname">memory_objects_for_name</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.paged_memory.SimPagedMemory.memory_objects_for_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a set of <code class="xref py py-class docutils literal"><span class="pre">SimMemoryObjects</span></code> that contain expressions that contain a variable with the name of
<cite>n</cite>.</p>
<p>This is useful for replacing those values in one fell swoop with <a class="reference internal" href="#angr.storage.paged_memory.SimPagedMemory.replace_memory_object" title="angr.storage.paged_memory.SimPagedMemory.replace_memory_object"><code class="xref py py-func docutils literal"><span class="pre">replace_memory_object()</span></code></a>, even if
they have been partially overwritten.</p>
</dd></dl>

<dl class="method">
<dt id="angr.storage.paged_memory.SimPagedMemory.memory_objects_for_hash">
<code class="descname">memory_objects_for_hash</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.paged_memory.SimPagedMemory.memory_objects_for_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a set of <code class="xref py py-class docutils literal"><span class="pre">SimMemoryObjects</span></code> that contain expressions that contain a variable with the hash
<cite>h</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="angr.storage.paged_memory.SimPagedMemory.permissions">
<code class="descname">permissions</code><span class="sig-paren">(</span><em>addr</em>, <em>permissions=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.storage.paged_memory.SimPagedMemory.permissions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the permissions for a page at address <cite>addr</cite>.</p>
<p>If optional argument permissions is given, set page permissions to that prior to returning permissions.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.concretization_strategies"></span><dl class="class">
<dt id="angr.concretization_strategies.SimConcretizationStrategy">
<em class="property">class </em><code class="descclassname">angr.concretization_strategies.</code><code class="descname">SimConcretizationStrategy</code><span class="sig-paren">(</span><em>filter=None</em>, <em>exact=True</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.concretization_strategies.SimConcretizationStrategy" title="Permalink to this definition">¶</a></dt>
<dd><p>Concretization strategies control the resolution of symbolic memory indices
in SimuVEX. By subclassing this class and setting it as a concretization strategy
(on state.memory.read_strategies and state.memory.write_strategies), SimuVEX&#8217;s
memory index concretization behavior can be modified.</p>
<p>Initializes the base SimConcretizationStrategy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filter</strong> &#8211; A function, taking arguments of (SimMemory, claripy.AST) that determins
if this strategy can handle resolving the provided AST.</li>
<li><strong>exact</strong> &#8211; A flag (default: True) that determines if the convenience resolution
functions provided by this class use exact or approximate resolution.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="angr.concretization_strategies.SimConcretizationStrategy.concretize">
<code class="descname">concretize</code><span class="sig-paren">(</span><em>memory</em>, <em>addr</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.concretization_strategies.SimConcretizationStrategy.concretize" title="Permalink to this definition">¶</a></dt>
<dd><p>Concretizes the address into a list of values.
If this strategy cannot handle this address, returns None.</p>
</dd></dl>

<dl class="method">
<dt id="angr.concretization_strategies.SimConcretizationStrategy.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.concretization_strategies.SimConcretizationStrategy.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of the strategy, if there is data that should be kept separate between
states. If not, returns self.</p>
</dd></dl>

<dl class="method">
<dt id="angr.concretization_strategies.SimConcretizationStrategy.merge">
<code class="descname">merge</code><span class="sig-paren">(</span><em>others</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.concretization_strategies.SimConcretizationStrategy.merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Merges this strategy with others (if there is data that should be kept separate between
states. If not, is a no-op.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-angr.manager">
<span id="simulation-manager"></span><h2>Simulation Manager<a class="headerlink" href="#module-angr.manager" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="angr.manager.SimulationManager">
<em class="property">class </em><code class="descclassname">angr.manager.</code><code class="descname">SimulationManager</code><span class="sig-paren">(</span><em>project</em>, <em>active_states=None</em>, <em>stashes=None</em>, <em>hierarchy=None</em>, <em>veritesting=None</em>, <em>veritesting_options=None</em>, <em>immutable=None</em>, <em>resilience=None</em>, <em>save_unconstrained=None</em>, <em>save_unsat=None</em>, <em>threads=None</em>, <em>errored=None</em>, <em>completion_mode=&lt;built-in function any&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.manager.SimulationManager" title="Permalink to this definition">¶</a></dt>
<dd><p>The Simulation Manager is the future future.</p>
<p>Simulation managers allow you to wrangle multiple states in a slick way. States are organized into &#8220;stashes&#8221;, which
you can step forward, filter, merge, and move around as you wish. This allows you to, for example, step two
different stashes of states at different rates, then merge them together.</p>
<p>Stashes can be accessed as attributes (i.e. .active).
A mulpyplexed stash can be retrieved by prepending the name with <cite>mp_</cite>, e.g. <cite>.mp_active</cite>.
A single state from the stash can be retrieved by prepending the name with <cite>one_</cite>, e.g. <cite>.one_active</cite>.</p>
<p>Note that you shouldn&#8217;t usually be constructing SimulationManagers directly - there is a convenient shortcut for
creating them in <code class="docutils literal"><span class="pre">Project.factory</span></code>: see <a class="reference internal" href="#angr.factory.AngrObjectFactory" title="angr.factory.AngrObjectFactory"><code class="xref py py-class docutils literal"><span class="pre">angr.factory.AngrObjectFactory</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>project</strong> (<a class="reference internal" href="#angr.project.Project" title="angr.project.Project"><em>angr.project.Project</em></a>) &#8211; A Project instance.</td>
</tr>
</tbody>
</table>
<p>The following parameters are optional.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>active_states</strong> &#8211; Active states to seed the &#8220;active&#8221; stash with.</li>
<li><strong>stashes</strong> &#8211; A dictionary to use as the stash store.</li>
<li><strong>hierarchy</strong> &#8211; A StateHierarchy object to use to track the relationships between states.</li>
<li><strong>immutable</strong> &#8211; If True, all operations will return a new SimulationManager. Otherwise (default), all operations
will modify the SimulationManager (and return it, for consistency and chaining).</li>
<li><strong>threads</strong> &#8211; the number of worker threads to concurrently analyze states (useful in z3-intensive situations).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Multithreading your search can be useful in constraint-solving-intensive situations. Indeed, Python cannot
multithread due to its GIL, but z3, written in C, can.</p>
<p>The most important methods you should look at are <code class="docutils literal"><span class="pre">step</span></code>, <code class="docutils literal"><span class="pre">explore</span></code>, and <code class="docutils literal"><span class="pre">use_technique</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>errored</strong> &#8211; Not a stash, but a list of ErrorRecords. Whenever a step raises an exception that we catch,
the state and some information about the error are placed in this list. You can adjust the
list of caught exceptions with the <cite>resilience</cite> parameter.</li>
<li><strong>stashes</strong> &#8211; All the stashes on this instance, as a dictionary.</li>
<li><strong>completion_mode</strong> &#8211; A function describing how multiple exploration techniques with the <code class="docutils literal"><span class="pre">complete</span></code> hook set will
interact. By default, the builtin function <code class="docutils literal"><span class="pre">any</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="angr.manager.SimulationManager.mulpyplex">
<code class="descname">mulpyplex</code><span class="sig-paren">(</span><em>*stashes</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.manager.SimulationManager.mulpyplex" title="Permalink to this definition">¶</a></dt>
<dd><p>Mulpyplex across several stashes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>stashes</strong> &#8211; the stashes to mulpyplex</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a mulpyplexed list of states from the stashes in question, in the specified order</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.manager.SimulationManager.apply">
<code class="descname">apply</code><span class="sig-paren">(</span><em>state_func=None</em>, <em>stash_func=None</em>, <em>stash=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.manager.SimulationManager.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies a given function to a given stash.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>state_func</strong> &#8211; A function to apply to every state. Should take a state and return a state. The returned state
will take the place of the old state. If the function <em>doesn&#8217;t</em> return a state, the old
state will be used. If the function returns a list of states, they will replace the original
states.</li>
<li><strong>stash_func</strong> &#8211; <p>A function to apply to the whole stash. Should take a list of states and return a list of
states. The resulting list will replace the stash.</p>
<p>If both state_func and stash_func are provided state_func is applied first, then stash_func
is applied on the results.</p>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The resulting SimulationManager.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#angr.manager.SimulationManager" title="angr.manager.SimulationManager">SimulationManager</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.manager.SimulationManager.split">
<code class="descname">split</code><span class="sig-paren">(</span><em>stash_splitter=None</em>, <em>stash_ranker=None</em>, <em>state_ranker=None</em>, <em>limit=None</em>, <em>from_stash=None</em>, <em>to_stash=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.manager.SimulationManager.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Split a stash of states. The stash from_stash will be split into two stashes depending on the other options
passed in. If to_stash is provided, the second stash will be written there.</p>
<p>stash_splitter overrides stash_ranker, which in turn overrides state_ranker. If no functions are provided, the
states are simply split according to the limit.</p>
<p>The sort done with state_ranker is ascending.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>stash_splitter</strong> &#8211; A function that should take a list of states and return a tuple of two lists (the two
resulting stashes).</li>
<li><strong>stash_ranker</strong> &#8211; A function that should take a list of states and return a sorted list of states. This list
will then be split according to &#8220;limit&#8221;.</li>
<li><strong>state_ranker</strong> &#8211; An alternative to stash_splitter. States will be sorted with outputs of this function.
used as a key. The first &#8220;limit&#8221; of them will be kept, the rest split off.</li>
<li><strong>limit</strong> &#8211; For use with state_ranker. The number of states to keep. Default: 8</li>
<li><strong>from_stash</strong> &#8211; The stash to split (default: &#8216;active&#8217;)</li>
<li><strong>to_stash</strong> &#8211; The stash to write to (default: &#8216;stashed&#8217;)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The resulting SimulationManager.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#angr.manager.SimulationManager" title="angr.manager.SimulationManager">SimulationManager</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.manager.SimulationManager.step">
<code class="descname">step</code><span class="sig-paren">(</span><em>n=None</em>, <em>selector_func=None</em>, <em>step_func=None</em>, <em>stash=None</em>, <em>successor_func=None</em>, <em>until=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.manager.SimulationManager.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Step a stash of states forward and categorize the successors appropriately.</p>
<p>The parameters to this function allow you to control everything about the stepping and categorization process.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>stash</strong> &#8211; The name of the stash to step (default: &#8216;active&#8217;)</li>
<li><strong>n</strong> &#8211; The number of times to step (default: 1 if &#8220;until&#8221; is not provided)</li>
<li><strong>selector_func</strong> &#8211; If provided, should be a function that takes a state and returns a boolean. If True, the
state will be stepped. Otherwise, it will be kept as-is.</li>
<li><strong>step_func</strong> &#8211; If provided, should be a function that takes a SimulationManager and returns a SimulationManager. Will
be called with the SimulationManager at every step. Note that this function should not actually
perform any stepping - it is meant to be a maintenance function called after each step.</li>
<li><strong>successor_func</strong> &#8211; If provided, should be a function that takes a state and return its successors.
Otherwise, project.factory.successors will be used.</li>
<li><strong>until</strong> &#8211; If provided, should be a function that takes a SimulationManager and returns True or False.
Stepping will terminate when it is True.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Additionally, you can pass in any of the following keyword args for project.factory.sim_run:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>jumpkind</strong> &#8211; The jumpkind of the previous exit</li>
<li><strong>addr</strong> &#8211; An address to execute at instead of the state&#8217;s ip.</li>
<li><strong>stmt_whitelist</strong> &#8211; A list of stmt indexes to which to confine execution.</li>
<li><strong>last_stmt</strong> &#8211; A statement index at which to stop execution.</li>
<li><strong>thumb</strong> &#8211; Whether the block should be lifted in ARM&#8217;s THUMB mode.</li>
<li><strong>backup_state</strong> &#8211; A state to read bytes from instead of using project memory.</li>
<li><strong>opt_level</strong> &#8211; The VEX optimization level to use.</li>
<li><strong>insn_bytes</strong> &#8211; A string of bytes to use for the block instead of the project.</li>
<li><strong>size</strong> &#8211; The maximum size of the block, in bytes.</li>
<li><strong>num_inst</strong> &#8211; The maximum number of instructions.</li>
<li><strong>traceflags</strong> &#8211; traceflags to be passed to VEX. Default: 0</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The following parameters are specific to the unicorn-engine.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>extra_stop_points</strong> &#8211; A collection of addresses where unicorn should stop, in addition to default program
points at which unicorn stops (e.g., hook points).</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The resulting SimulationManager.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#angr.manager.SimulationManager" title="angr.manager.SimulationManager">SimulationManager</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.manager.SimulationManager.prune">
<code class="descname">prune</code><span class="sig-paren">(</span><em>filter_func=None</em>, <em>from_stash=None</em>, <em>to_stash=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.manager.SimulationManager.prune" title="Permalink to this definition">¶</a></dt>
<dd><p>Prune unsatisfiable states from a stash.
This function will move all unsatisfiable states in the given stash into a different stash.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filter_func</strong> &#8211; Only prune states that match this filter.</li>
<li><strong>from_stash</strong> &#8211; Prune states from this stash. (default: &#8216;active&#8217;)</li>
<li><strong>to_stash</strong> &#8211; Put pruned states in this stash. (default: &#8216;pruned&#8217;)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The resulting SimulationManager.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#angr.manager.SimulationManager" title="angr.manager.SimulationManager">SimulationManager</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.manager.SimulationManager.move">
<code class="descname">move</code><span class="sig-paren">(</span><em>from_stash</em>, <em>to_stash</em>, <em>filter_func=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.manager.SimulationManager.move" title="Permalink to this definition">¶</a></dt>
<dd><p>Move states from one stash to another.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>from_stash</strong> &#8211; Take matching states from this stash.</li>
<li><strong>to_stash</strong> &#8211; Put matching states into this stash.</li>
<li><strong>filter_func</strong> &#8211; Stash states that match this filter. Should be a function that takes a state and returns
True or False. Default: stash all states</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The resulting SimulationManager.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#angr.manager.SimulationManager" title="angr.manager.SimulationManager">SimulationManager</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.manager.SimulationManager.stash">
<code class="descname">stash</code><span class="sig-paren">(</span><em>filter_func=None</em>, <em>from_stash=None</em>, <em>to_stash=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.manager.SimulationManager.stash" title="Permalink to this definition">¶</a></dt>
<dd><p>Stash some states. This is an alias for move(), with defaults for the stashes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filter_func</strong> &#8211; Stash states that match this filter. Should be a function. that takes a state and returns True
or False. (default: stash all states)</li>
<li><strong>from_stash</strong> &#8211; Take matching states from this stash. (default: &#8216;active&#8217;)</li>
<li><strong>to_stash</strong> &#8211; Put matching states into this stash. (default: &#8216;stashed&#8217;)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The resulting SimulationManager</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#angr.manager.SimulationManager" title="angr.manager.SimulationManager">SimulationManager</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.manager.SimulationManager.drop">
<code class="descname">drop</code><span class="sig-paren">(</span><em>filter_func=None</em>, <em>stash=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.manager.SimulationManager.drop" title="Permalink to this definition">¶</a></dt>
<dd><p>Drops states from a stash. This is an alias for move(), with defaults for the stashes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filter_func</strong> &#8211; Drop states that match this filter. Should be a function that takes a state and returns True
or False. (default: drop all states)</li>
<li><strong>stash</strong> &#8211; Drop matching states from this stash. (default: &#8216;active&#8217;)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The resulting SimulationManager</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#angr.manager.SimulationManager" title="angr.manager.SimulationManager">SimulationManager</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.manager.SimulationManager.unstash">
<code class="descname">unstash</code><span class="sig-paren">(</span><em>filter_func=None</em>, <em>to_stash=None</em>, <em>from_stash=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.manager.SimulationManager.unstash" title="Permalink to this definition">¶</a></dt>
<dd><p>Unstash some states. This is an alias for move(), with defaults for the stashes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filter_func</strong> &#8211; Unstash states that match this filter. Should be a function that takes a state and returns
True or False. (default: unstash all states)</li>
<li><strong>from_stash</strong> &#8211; take matching states from this stash. (default: &#8216;stashed&#8217;)</li>
<li><strong>to_stash</strong> &#8211; put matching states into this stash. (default: &#8216;active&#8217;)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The resulting SimulationManager.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#angr.manager.SimulationManager" title="angr.manager.SimulationManager">SimulationManager</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.manager.SimulationManager.merge">
<code class="descname">merge</code><span class="sig-paren">(</span><em>merge_func=None</em>, <em>stash=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.manager.SimulationManager.merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge the states in a given stash.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>stash</strong> &#8211; The stash (default: &#8216;active&#8217;)</li>
<li><strong>merge_func</strong> &#8211; If provided, instead of using state.merge, call this function with the states as the argument.
Should return the merged state.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The result SimulationManager.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#angr.manager.SimulationManager" title="angr.manager.SimulationManager">SimulationManager</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.manager.SimulationManager.use_technique">
<code class="descname">use_technique</code><span class="sig-paren">(</span><em>tech</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.manager.SimulationManager.use_technique" title="Permalink to this definition">¶</a></dt>
<dd><p>Use an exploration technique with this SimulationManager.
Techniques can be found in <a class="reference internal" href="#module-angr.exploration_techniques" title="angr.exploration_techniques"><code class="xref py py-mod docutils literal"><span class="pre">angr.exploration_techniques</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>tech</strong> &#8211; An ExplorationTechnique object that contains code to modify this SimulationManager&#8217;s behavior</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.manager.SimulationManager.stash_not_addr">
<code class="descname">stash_not_addr</code><span class="sig-paren">(</span><em>addr</em>, <em>from_stash=None</em>, <em>to_stash=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.manager.SimulationManager.stash_not_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Stash all states not at address addr from stash from_stash to stash to_stash.</p>
</dd></dl>

<dl class="method">
<dt id="angr.manager.SimulationManager.stash_addr">
<code class="descname">stash_addr</code><span class="sig-paren">(</span><em>addr</em>, <em>from_stash=None</em>, <em>to_stash=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.manager.SimulationManager.stash_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Stash all states at address addr from stash from_stash to stash to_stash.</p>
</dd></dl>

<dl class="method">
<dt id="angr.manager.SimulationManager.stash_addr_past">
<code class="descname">stash_addr_past</code><span class="sig-paren">(</span><em>addr</em>, <em>from_stash=None</em>, <em>to_stash=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.manager.SimulationManager.stash_addr_past" title="Permalink to this definition">¶</a></dt>
<dd><p>Stash all states containg address addr in their backtrace from stash from_stash to stash to_stash.</p>
</dd></dl>

<dl class="method">
<dt id="angr.manager.SimulationManager.stash_not_addr_past">
<code class="descname">stash_not_addr_past</code><span class="sig-paren">(</span><em>addr</em>, <em>from_stash=None</em>, <em>to_stash=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.manager.SimulationManager.stash_not_addr_past" title="Permalink to this definition">¶</a></dt>
<dd><p>Stash all states not containg address addr in their backtrace from stash from_stash to stash to_stash.</p>
</dd></dl>

<dl class="method">
<dt id="angr.manager.SimulationManager.stash_all">
<code class="descname">stash_all</code><span class="sig-paren">(</span><em>from_stash=None</em>, <em>to_stash=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.manager.SimulationManager.stash_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Stash all states from stash from_stash to stash to_stash.</p>
</dd></dl>

<dl class="method">
<dt id="angr.manager.SimulationManager.unstash_addr">
<code class="descname">unstash_addr</code><span class="sig-paren">(</span><em>addr</em>, <em>from_stash=None</em>, <em>to_stash=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.manager.SimulationManager.unstash_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Unstash all states at address addr.</p>
</dd></dl>

<dl class="method">
<dt id="angr.manager.SimulationManager.unstash_addr_past">
<code class="descname">unstash_addr_past</code><span class="sig-paren">(</span><em>addr</em>, <em>from_stash=None</em>, <em>to_stash=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.manager.SimulationManager.unstash_addr_past" title="Permalink to this definition">¶</a></dt>
<dd><p>Unstash all states containing address addr in their backtrace.</p>
</dd></dl>

<dl class="method">
<dt id="angr.manager.SimulationManager.unstash_not_addr">
<code class="descname">unstash_not_addr</code><span class="sig-paren">(</span><em>addr</em>, <em>from_stash=None</em>, <em>to_stash=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.manager.SimulationManager.unstash_not_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Unstash all states not at address addr.</p>
</dd></dl>

<dl class="method">
<dt id="angr.manager.SimulationManager.unstash_not_addr_past">
<code class="descname">unstash_not_addr_past</code><span class="sig-paren">(</span><em>addr</em>, <em>from_stash=None</em>, <em>to_stash=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.manager.SimulationManager.unstash_not_addr_past" title="Permalink to this definition">¶</a></dt>
<dd><p>Unstash all states not containing address addr in their backtrace.</p>
</dd></dl>

<dl class="method">
<dt id="angr.manager.SimulationManager.unstash_all">
<code class="descname">unstash_all</code><span class="sig-paren">(</span><em>from_stash=None</em>, <em>to_stash=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.manager.SimulationManager.unstash_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Unstash all states.</p>
</dd></dl>

<dl class="method">
<dt id="angr.manager.SimulationManager.explore">
<code class="descname">explore</code><span class="sig-paren">(</span><em>stash=None</em>, <em>n=None</em>, <em>find=None</em>, <em>avoid=None</em>, <em>find_stash='found'</em>, <em>avoid_stash='avoid'</em>, <em>cfg=None</em>, <em>num_find=1</em>, <em>step_func=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.manager.SimulationManager.explore" title="Permalink to this definition">¶</a></dt>
<dd><p>Tick stash &#8220;stash&#8221; forward (up to &#8220;n&#8221; times or until &#8220;num_find&#8221; states are found), looking for condition &#8220;find&#8221;,
avoiding condition &#8220;avoid&#8221;. Stores found states into &#8220;find_stash&#8217; and avoided states into &#8220;avoid_stash&#8221;.</p>
<p>The &#8220;find&#8221; and &#8220;avoid&#8221; parameters may be any of:</p>
<ul class="simple">
<li>An address to find</li>
<li>A set or list of addresses to find</li>
<li>A function that takes a state and returns whether or not it matches.</li>
</ul>
<p>If an angr CFG is passed in as the &#8220;cfg&#8221; parameter and &#8220;find&#8221; is either a number or a list or a set, then
any states which cannot possibly reach a success state without going through a failure state will be
preemptively avoided.</p>
</dd></dl>

<dl class="method">
<dt id="angr.manager.SimulationManager.run">
<code class="descname">run</code><span class="sig-paren">(</span><em>stash=None</em>, <em>n=None</em>, <em>step_func=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.manager.SimulationManager.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Run until the SimulationManager has reached a completed state, according to
the current exploration techniques.</p>
<p>TODO: step_func doesn&#8217;t work with veritesting, since veritesting replaces
the default step logic.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>stash</strong> &#8211; Operate on this stash</li>
<li><strong>n</strong> &#8211; Step at most this many times</li>
<li><strong>step_func</strong> &#8211; If provided, should be a function that takes a SimulationManager and returns a new SimulationManager. Will
be called with the current SimulationManager at every step.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The resulting SimulationManager.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#angr.manager.SimulationManager" title="angr.manager.SimulationManager">SimulationManager</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="angr.manager.ErrorRecord">
<em class="property">class </em><code class="descclassname">angr.manager.</code><code class="descname">ErrorRecord</code><span class="sig-paren">(</span><em>state</em>, <em>error</em>, <em>traceback</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.manager.ErrorRecord" title="Permalink to this definition">¶</a></dt>
<dd><p>A container class for a state and an error that was thrown during its execution. You can find these in
SimulationManager.errored.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>state</strong> &#8211; The state that encountered an error, at the point in time just before the erroring step began</li>
<li><strong>error</strong> &#8211; The error that was thrown</li>
<li><strong>traceback</strong> &#8211; The traceback for the error that was thrown</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="angr.manager.ErrorRecord.debug">
<code class="descname">debug</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.manager.ErrorRecord.debug" title="Permalink to this definition">¶</a></dt>
<dd><p>Launch a postmortem debug shell at the site of the error</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.exploration_techniques"></span><dl class="class">
<dt id="angr.exploration_techniques.ExplorationTechnique">
<em class="property">class </em><code class="descclassname">angr.exploration_techniques.</code><code class="descname">ExplorationTechnique</code><a class="headerlink" href="#angr.exploration_techniques.ExplorationTechnique" title="Permalink to this definition">¶</a></dt>
<dd><p>An otiegnqwvk is a set of hooks for a simulation manager that assists in the implementation of new techniques in
symbolic exploration.</p>
<p>TODO: choose actual name for the functionality (techniques? strategies?)</p>
<p>Any number of these methods may be overridden by a subclass.
To use an exploration technique, call <code class="docutils literal"><span class="pre">simgr.use_technique</span></code> with an <em>instance</em> of the technique.</p>
<dl class="method">
<dt id="angr.exploration_techniques.ExplorationTechnique.setup">
<code class="descname">setup</code><span class="sig-paren">(</span><em>simgr</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.exploration_techniques.ExplorationTechnique.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform any initialization on this manager you might need to do.</p>
</dd></dl>

<dl class="method">
<dt id="angr.exploration_techniques.ExplorationTechnique.step_state">
<code class="descname">step_state</code><span class="sig-paren">(</span><em>state</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.exploration_techniques.ExplorationTechnique.step_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the process of stepping a state forward.</p>
<p>If the stepping fails, return None to fall back to a default stepping procedure.
Otherwise, return a dict of stashes to merge into the simulation manager. All the states
will be added to the PathGroup&#8217;s stashes based on the mapping in the returned dict.</p>
</dd></dl>

<dl class="method">
<dt id="angr.exploration_techniques.ExplorationTechnique.step">
<code class="descname">step</code><span class="sig-paren">(</span><em>simgr</em>, <em>stash</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.exploration_techniques.ExplorationTechnique.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Step this stash of this manager forward. Should call <code class="docutils literal"><span class="pre">simgr.step(stash,</span> <span class="pre">**kwargs)</span></code> in order to do the actual
processing.</p>
<p>Return the stepped manager.</p>
</dd></dl>

<dl class="method">
<dt id="angr.exploration_techniques.ExplorationTechnique.filter">
<code class="descname">filter</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.exploration_techniques.ExplorationTechnique.filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform filtering on a state.</p>
<p>If the state should not be filtered, return None.
If the state should be filtered, return the name of the stash to move the state to.
If you want to modify the state before filtering it, return a tuple of the stash to move the state to and the
modified state.</p>
</dd></dl>

<dl class="method">
<dt id="angr.exploration_techniques.ExplorationTechnique.complete">
<code class="descname">complete</code><span class="sig-paren">(</span><em>simgr</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.exploration_techniques.ExplorationTechnique.complete" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether or not this manager has reached a &#8220;completed&#8221; state, i.e. <code class="docutils literal"><span class="pre">SimulationManager.run()</span></code> should halt.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.exploration_techniques.dfs"></span><dl class="class">
<dt id="angr.exploration_techniques.dfs.DFS">
<em class="property">class </em><code class="descclassname">angr.exploration_techniques.dfs.</code><code class="descname">DFS</code><a class="headerlink" href="#angr.exploration_techniques.dfs.DFS" title="Permalink to this definition">¶</a></dt>
<dd><p>Depth-first search.</p>
<p>Will only keep one path active at a time, any others will be stashed in the &#8216;deferred&#8217; stash.
When we run out of active paths to step, we take the longest one from deferred and continue.</p>
</dd></dl>

<span class="target" id="module-angr.exploration_techniques.explorer"></span><dl class="class">
<dt id="angr.exploration_techniques.explorer.Explorer">
<em class="property">class </em><code class="descclassname">angr.exploration_techniques.explorer.</code><code class="descname">Explorer</code><span class="sig-paren">(</span><em>find=None</em>, <em>avoid=None</em>, <em>find_stash='found'</em>, <em>avoid_stash='avoid'</em>, <em>cfg=None</em>, <em>num_find=1</em>, <em>avoid_priority=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.exploration_techniques.explorer.Explorer" title="Permalink to this definition">¶</a></dt>
<dd><p>Search for up to &#8220;num_find&#8221; paths that satisfy condition &#8220;find&#8221;, avoiding condition &#8220;avoid&#8221;. Stashes found paths into &#8220;find_stash&#8217; and avoided paths into &#8220;avoid_stash&#8221;.</p>
<p>The &#8220;find&#8221; and &#8220;avoid&#8221; parameters may be any of:</p>
<ul class="simple">
<li>An address to find</li>
<li>A set or list of addresses to find</li>
<li>A function that takes a path and returns whether or not it matches.</li>
</ul>
<p>If an angr CFG is passed in as the &#8220;cfg&#8221; parameter and &#8220;find&#8221; is either a number or a list or a set, then
any paths which cannot possibly reach a success state without going through a failure state will be
preemptively avoided.</p>
<p>If either the &#8220;find&#8221; or &#8220;avoid&#8221; parameter is a function returning a boolean, and a path triggers both conditions, it will be added to the find stash, unless &#8220;avoid_priority&#8221; is set to True.</p>
</dd></dl>

<span class="target" id="module-angr.exploration_techniques.looplimiter"></span><dl class="class">
<dt id="angr.exploration_techniques.looplimiter.LoopLimiter">
<em class="property">class </em><code class="descclassname">angr.exploration_techniques.looplimiter.</code><code class="descname">LoopLimiter</code><span class="sig-paren">(</span><em>count=5</em>, <em>discard_stash='spinning'</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.exploration_techniques.looplimiter.LoopLimiter" title="Permalink to this definition">¶</a></dt>
<dd><p>Limit the number of loops a path may go through.
Paths that exceed the loop limit are moved to a discard stash.</p>
<p>Note that this uses the default detect_loops method from Path, which approximates loop
counts by counting the number of times each basic block is executed in a given stack frame.</p>
</dd></dl>

<span class="target" id="module-angr.exploration_techniques.threading"></span><dl class="class">
<dt id="angr.exploration_techniques.threading.Threading">
<em class="property">class </em><code class="descclassname">angr.exploration_techniques.threading.</code><code class="descname">Threading</code><span class="sig-paren">(</span><em>threads=8</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.exploration_techniques.threading.Threading" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable multithreading.</p>
<p>This is only useful in paths where a lot of time is taken inside z3, doing constraint solving.
This is because of python&#8217;s GIL, which says that only one thread at a time may be executing python code.</p>
</dd></dl>

<span class="target" id="module-angr.exploration_techniques.veritesting"></span><dl class="class">
<dt id="angr.exploration_techniques.veritesting.Veritesting">
<em class="property">class </em><code class="descclassname">angr.exploration_techniques.veritesting.</code><code class="descname">Veritesting</code><span class="sig-paren">(</span><em>**options</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.exploration_techniques.veritesting.Veritesting" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable veritesting. This technique, described in a paper[1] from CMU, attempts to address the problem of state
explosions in loops by performing smart merging.</p>
<p>[1] <a class="reference external" href="https://users.ece.cmu.edu/~aavgerin/papers/veritesting-icse-2014.pdf">https://users.ece.cmu.edu/~aavgerin/papers/veritesting-icse-2014.pdf</a></p>
</dd></dl>

<span class="target" id="module-angr.state_hierarchy"></span><span class="target" id="module-angr.pathprioritizer"></span></div>
<div class="section" id="module-angr.engines">
<span id="simulation-engines"></span><h2>Simulation Engines<a class="headerlink" href="#module-angr.engines" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-angr.engines.engine"></span><dl class="class">
<dt id="angr.engines.engine.SimEngine">
<em class="property">class </em><code class="descclassname">angr.engines.engine.</code><code class="descname">SimEngine</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.engines.engine.SimEngine" title="Permalink to this definition">¶</a></dt>
<dd><p>A SimEngine is a class which understands how to perform execution on a state. This is a base class.</p>
<dl class="method">
<dt id="angr.engines.engine.SimEngine.process">
<code class="descname">process</code><span class="sig-paren">(</span><em>state</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.engines.engine.SimEngine.process" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform execution with a state.</p>
<p>You should only override this method in a subclass in order to provide the correct method signature and
docstring. You should override the <code class="docutils literal"><span class="pre">_process</span></code> method to do your actual execution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>state</strong> &#8211; The state with which to execute. This state will be copied before
modification.</li>
<li><strong>inline</strong> &#8211; This is an inline execution. Do not bother copying the state.</li>
<li><strong>force_addr</strong> &#8211; Force execution to pretend that we&#8217;re working at this concrete address</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A SimSuccessors object categorizing the execution&#8217;s successor states</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.engines.engine.SimEngine.check">
<code class="descname">check</code><span class="sig-paren">(</span><em>state</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.engines.engine.SimEngine.check" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if this engine can be used for execution on the current state. A callback <cite>check_failure</cite> is called upon
failed checks. Note that the execution can still fail even if check() returns True.</p>
<p>You should only override this method in a subclass in order to provide the correct method signature and
docstring. You should override the <code class="docutils literal"><span class="pre">_check</span></code> method to do your actual execution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>state</strong> (<a class="reference internal" href="#angr.sim_state.SimState" title="angr.sim_state.SimState"><em>SimState</em></a>) &#8211; The state with which to execute.</li>
<li><strong>args</strong> &#8211; Positional arguments that will be passed to process().</li>
<li><strong>kwargs</strong> &#8211; Keyword arguments that will be passed to process().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">True if the state can be handled by the current engine, False otherwise.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.engines.successors"></span><dl class="class">
<dt id="angr.engines.successors.SimSuccessors">
<em class="property">class </em><code class="descclassname">angr.engines.successors.</code><code class="descname">SimSuccessors</code><span class="sig-paren">(</span><em>addr</em>, <em>initial_state</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.engines.successors.SimSuccessors" title="Permalink to this definition">¶</a></dt>
<dd><p>This class serves as a categorization of all the kinds of result states that can come from a
SimEngine run.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><a class="reference internal" href="#angr.sim_state.SimState.addr" title="angr.sim_state.SimState.addr"><strong>addr</strong></a> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The address at which execution is taking place, as a python int</li>
<li><strong>initial_state</strong> &#8211; The initial state for which execution produced these successors</li>
<li><a class="reference internal" href="#module-angr.engines.engine" title="angr.engines.engine"><strong>engine</strong></a> &#8211; The engine that produced these successors</li>
<li><strong>sort</strong> &#8211; A string identifying the type of engine that produced these successors</li>
<li><strong>processed</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; Whether or not the processing succeeded</li>
<li><strong>description</strong> (<em>str</em>) &#8211; A textual description of the execution step</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The successor states produced by this run are categorized into several lists:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>artifacts</strong> (<em>dict</em>) &#8211; Any analysis byproducts (for example, an IRSB) that were produced during execution</li>
<li><a class="reference internal" href="#angr.factory.AngrObjectFactory.successors" title="angr.factory.AngrObjectFactory.successors"><strong>successors</strong></a> &#8211; The &#8220;normal&#8221; successors. IP may be symbolic, but must have reasonable number of solutions</li>
<li><strong>unsat_successors</strong> &#8211; Any successor which is unsatisfiable after its guard condition is added.</li>
<li><a class="reference internal" href="#angr.analyses.forward_analysis.GraphVisitor.all_successors" title="angr.analyses.forward_analysis.GraphVisitor.all_successors"><strong>all_successors</strong></a> &#8211; successors + unsat_successors</li>
<li><strong>flat_successors</strong> &#8211; The normal successors, but any symbolic IPs have been concretized. There is one state in
this list for each possible value an IP may be concretized to for each successor state.</li>
<li><strong>unconstrained_successors</strong> &#8211; Any state for which during the flattening process we find too many solutions.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>A more detailed description of the successor lists may be found here: <a class="reference external" href="https://docs.angr.io/docs/simuvex.html">https://docs.angr.io/docs/simuvex.html</a></p>
<dl class="method">
<dt id="angr.engines.successors.SimSuccessors.add_successor">
<code class="descname">add_successor</code><span class="sig-paren">(</span><em>state</em>, <em>target</em>, <em>guard</em>, <em>jumpkind</em>, <em>add_guard=True</em>, <em>exit_stmt_idx=None</em>, <em>exit_ins_addr=None</em>, <em>source=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.engines.successors.SimSuccessors.add_successor" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a successor state of the SimRun.
This procedure stores method parameters into state.scratch, does some housekeeping,
and calls out to helper functions to prepare the state and categorize it into the appropriate
successor lists.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>state</strong> (<a class="reference internal" href="#angr.sim_state.SimState" title="angr.sim_state.SimState"><em>SimState</em></a>) &#8211; The successor state.</li>
<li><strong>target</strong> &#8211; The target (of the jump/call/ret).</li>
<li><strong>guard</strong> &#8211; The guard expression.</li>
<li><strong>jumpkind</strong> (<em>str</em>) &#8211; The jumpkind (call, ret, jump, or whatnot).</li>
<li><strong>add_guard</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; Whether to add the guard constraint (default: True).</li>
<li><strong>exit_stmt_idx</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The ID of the exit statement, an integer by default. &#8216;default&#8217;
stands for the default exit, and None means it&#8217;s not from a
statement (for example, from a SimProcedure).</li>
<li><strong>exit_ins_addr</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The instruction pointer of this exit, which is an integer by default.</li>
<li><strong>source</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The source of the jump (i.e., the address of the basic block).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.engines.vex"></span><span class="target" id="module-angr.engines.vex.engine"></span><dl class="class">
<dt id="angr.engines.vex.engine.SimEngineVEX">
<em class="property">class </em><code class="descclassname">angr.engines.vex.engine.</code><code class="descname">SimEngineVEX</code><span class="sig-paren">(</span><em>stop_points=None</em>, <em>use_cache=True</em>, <em>cache_size=10000</em>, <em>default_opt_level=1</em>, <em>support_selfmodifying_code=False</em>, <em>single_step=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.engines.vex.engine.SimEngineVEX" title="Permalink to this definition">¶</a></dt>
<dd><p>Execution engine based on VEX, Valgrind&#8217;s IR.</p>
<dl class="method">
<dt id="angr.engines.vex.engine.SimEngineVEX.process">
<code class="descname">process</code><span class="sig-paren">(</span><em>state</em>, <em>irsb=None</em>, <em>skip_stmts=0</em>, <em>last_stmt=99999999</em>, <em>whitelist=None</em>, <em>inline=False</em>, <em>force_addr=None</em>, <em>insn_bytes=None</em>, <em>size=None</em>, <em>num_inst=None</em>, <em>traceflags=0</em>, <em>thumb=False</em>, <em>opt_level=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.engines.vex.engine.SimEngineVEX.process" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>state</strong> &#8211; The state with which to execute</li>
<li><strong>irsb</strong> &#8211; The PyVEX IRSB object to use for execution. If not provided one will be lifted.</li>
<li><strong>skip_stmts</strong> &#8211; The number of statements to skip in processing</li>
<li><strong>last_stmt</strong> &#8211; Do not execute any statements after this statement</li>
<li><strong>whitelist</strong> &#8211; Only execute statements in this set</li>
<li><strong>inline</strong> &#8211; This is an inline execution. Do not bother copying the state.</li>
<li><strong>force_addr</strong> &#8211; Force execution to pretend that we&#8217;re working at this concrete address</li>
<li><strong>thumb</strong> &#8211; Whether the block should be lifted in ARM&#8217;s THUMB mode.</li>
<li><strong>opt_level</strong> &#8211; The VEX optimization level to use.</li>
<li><strong>insn_bytes</strong> &#8211; A string of bytes to use for the block instead of the project.</li>
<li><strong>size</strong> &#8211; The maximum size of the block, in bytes.</li>
<li><strong>num_inst</strong> &#8211; The maximum number of instructions.</li>
<li><strong>traceflags</strong> &#8211; traceflags to be passed to VEX. (default: 0)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A SimSuccessors object categorizing the block&#8217;s successors</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.engines.vex.engine.SimEngineVEX.lift">
<code class="descname">lift</code><span class="sig-paren">(</span><em>state=None</em>, <em>clemory=None</em>, <em>insn_bytes=None</em>, <em>arch=None</em>, <em>addr=None</em>, <em>size=None</em>, <em>num_inst=None</em>, <em>traceflags=0</em>, <em>thumb=False</em>, <em>opt_level=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.engines.vex.engine.SimEngineVEX.lift" title="Permalink to this definition">¶</a></dt>
<dd><p>Lift an IRSB.</p>
<p>There are many possible valid sets of parameters. You at the very least must pass some
source of data, some source of an architecture, and some source of an address.</p>
<p>Sources of data in order of priority: insn_bytes, clemory, state</p>
<p>Sources of an address, in order of priority: addr, state</p>
<p>Sources of an architecture, in order of priority: arch, clemory, state</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>state</strong> &#8211; A state to use as a data source.</li>
<li><strong>clemory</strong> &#8211; A cle.memory.Clemory object to use as a data source.</li>
<li><strong>addr</strong> &#8211; The address at which to start the block.</li>
<li><strong>thumb</strong> &#8211; Whether the block should be lifted in ARM&#8217;s THUMB mode.</li>
<li><strong>opt_level</strong> &#8211; The VEX optimization level to use. The final IR optimization level is determined by
(ordered by priority):
- Argument opt_level
- opt_level is set to 1 if OPTIMIZE_IR exists in state options
- self._default_opt_level</li>
<li><strong>insn_bytes</strong> &#8211; A string of bytes to use as a data source.</li>
<li><strong>size</strong> &#8211; The maximum size of the block, in bytes.</li>
<li><strong>num_inst</strong> &#8211; The maximum number of instructions.</li>
<li><strong>traceflags</strong> &#8211; traceflags to be passed to VEX. (default: 0)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.engines.procedure"></span><dl class="class">
<dt id="angr.engines.procedure.SimEngineProcedure">
<em class="property">class </em><code class="descclassname">angr.engines.procedure.</code><code class="descname">SimEngineProcedure</code><a class="headerlink" href="#angr.engines.procedure.SimEngineProcedure" title="Permalink to this definition">¶</a></dt>
<dd><p>An engine for running SimProcedures</p>
<dl class="method">
<dt id="angr.engines.procedure.SimEngineProcedure.process">
<code class="descname">process</code><span class="sig-paren">(</span><em>state</em>, <em>procedure</em>, <em>ret_to=None</em>, <em>inline=None</em>, <em>force_addr=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.engines.procedure.SimEngineProcedure.process" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform execution with a state.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>state</strong> &#8211; The state with which to execute</li>
<li><strong>procedure</strong> &#8211; An instance of a SimProcedure to run</li>
<li><strong>ret_to</strong> &#8211; The address to return to when this procedure is finished</li>
<li><strong>inline</strong> &#8211; This is an inline execution. Do not bother copying the state.</li>
<li><strong>force_addr</strong> &#8211; Force execution to pretend that we&#8217;re working at this concrete address</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A SimSuccessors object categorizing the execution&#8217;s successor states</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.engines.hook"></span><span class="target" id="module-angr.engines.syscall"></span><span class="target" id="module-angr.engines.unicorn"></span><dl class="class">
<dt id="angr.engines.unicorn.SimEngineUnicorn">
<em class="property">class </em><code class="descclassname">angr.engines.unicorn.</code><code class="descname">SimEngineUnicorn</code><span class="sig-paren">(</span><em>base_stop_points=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.engines.unicorn.SimEngineUnicorn" title="Permalink to this definition">¶</a></dt>
<dd><p>Concrete execution in the Unicorn Engine, a fork of qemu.</p>
<dl class="method">
<dt id="angr.engines.unicorn.SimEngineUnicorn.process">
<code class="descname">process</code><span class="sig-paren">(</span><em>state</em>, <em>step=None</em>, <em>extra_stop_points=None</em>, <em>inline=False</em>, <em>force_addr=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.engines.unicorn.SimEngineUnicorn.process" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>state</strong> &#8211; The state with which to execute</li>
<li><strong>step</strong> &#8211; How many basic blocks we want to execute</li>
<li><strong>extra_stop_points</strong> &#8211; A collection of addresses at which execution should halt</li>
<li><strong>inline</strong> &#8211; This is an inline execution. Do not bother copying the state.</li>
<li><strong>force_addr</strong> &#8211; Force execution to pretend that we&#8217;re working at this concrete
address</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A SimSuccessors object categorizing the results of the run and
whether it succeeded.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.engines.failure"></span></div>
<div class="section" id="module-angr.state_plugins.sim_action">
<span id="simulation-logging"></span><h2>Simulation Logging<a class="headerlink" href="#module-angr.state_plugins.sim_action" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="angr.state_plugins.sim_action.SimAction">
<em class="property">class </em><code class="descclassname">angr.state_plugins.sim_action.</code><code class="descname">SimAction</code><span class="sig-paren">(</span><em>state</em>, <em>region_type</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.state_plugins.sim_action.SimAction" title="Permalink to this definition">¶</a></dt>
<dd><p>A SimAction represents a semantic action that an analyzed program performs.</p>
<p>Initializes the SimAction.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>state</strong> &#8211; the state that&#8217;s the SimAction is taking place in.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="angr.state_plugins.sim_action.SimAction.downsize">
<code class="descname">downsize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.state_plugins.sim_action.SimAction.downsize" title="Permalink to this definition">¶</a></dt>
<dd><p>Clears some low-level details (that take up memory) out of the SimAction.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="angr.state_plugins.sim_action.SimActionExit">
<em class="property">class </em><code class="descclassname">angr.state_plugins.sim_action.</code><code class="descname">SimActionExit</code><span class="sig-paren">(</span><em>state</em>, <em>target</em>, <em>condition=None</em>, <em>exit_type=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.state_plugins.sim_action.SimActionExit" title="Permalink to this definition">¶</a></dt>
<dd><p>An Exit action represents a (possibly conditional) jump.</p>
</dd></dl>

<dl class="class">
<dt id="angr.state_plugins.sim_action.SimActionConstraint">
<em class="property">class </em><code class="descclassname">angr.state_plugins.sim_action.</code><code class="descname">SimActionConstraint</code><span class="sig-paren">(</span><em>state</em>, <em>constraint</em>, <em>condition=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.state_plugins.sim_action.SimActionConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>A constraint action represents an extra constraint added during execution of a path.</p>
</dd></dl>

<dl class="class">
<dt id="angr.state_plugins.sim_action.SimActionOperation">
<em class="property">class </em><code class="descclassname">angr.state_plugins.sim_action.</code><code class="descname">SimActionOperation</code><span class="sig-paren">(</span><em>state</em>, <em>op</em>, <em>exprs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.state_plugins.sim_action.SimActionOperation" title="Permalink to this definition">¶</a></dt>
<dd><p>An action representing an operation between variables and/or constants.</p>
</dd></dl>

<dl class="class">
<dt id="angr.state_plugins.sim_action.SimActionData">
<em class="property">class </em><code class="descclassname">angr.state_plugins.sim_action.</code><code class="descname">SimActionData</code><span class="sig-paren">(</span><em>state</em>, <em>region_type</em>, <em>action</em>, <em>tmp=None</em>, <em>addr=None</em>, <em>size=None</em>, <em>data=None</em>, <em>condition=None</em>, <em>fallback=None</em>, <em>fd=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.state_plugins.sim_action.SimActionData" title="Permalink to this definition">¶</a></dt>
<dd><p>A Data action represents a read or a write from memory, registers or a file.</p>
</dd></dl>

<span class="target" id="module-angr.state_plugins.sim_action_object"></span><dl class="class">
<dt id="angr.state_plugins.sim_action_object.SimActionObject">
<em class="property">class </em><code class="descclassname">angr.state_plugins.sim_action_object.</code><code class="descname">SimActionObject</code><span class="sig-paren">(</span><em>ast</em>, <em>reg_deps=None</em>, <em>tmp_deps=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.state_plugins.sim_action_object.SimActionObject" title="Permalink to this definition">¶</a></dt>
<dd><p>A SimActionObject tracks an AST and its dependencies.</p>
</dd></dl>

<span class="target" id="module-angr.state_plugins.sim_event"></span></div>
<div class="section" id="module-angr.sim_procedure">
<span id="procedures"></span><h2>Procedures<a class="headerlink" href="#module-angr.sim_procedure" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="angr.sim_procedure.SimProcedure">
<em class="property">class </em><code class="descclassname">angr.sim_procedure.</code><code class="descname">SimProcedure</code><span class="sig-paren">(</span><em>project=None</em>, <em>cc=None</em>, <em>symbolic_return=None</em>, <em>returns=None</em>, <em>is_syscall=None</em>, <em>is_stub=False</em>, <em>num_args=None</em>, <em>display_name=None</em>, <em>library_name=None</em>, <em>is_function=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_procedure.SimProcedure" title="Permalink to this definition">¶</a></dt>
<dd><p>A SimProcedure is a wonderful object which describes a procedure to run on a state.</p>
<p>You may subclass SimProcedure and override <code class="docutils literal"><span class="pre">run()</span></code>, replacing it with mutating <code class="docutils literal"><span class="pre">self.state</span></code> however you like,
and then either returning a value or jumping away somehow.</p>
<p>A detailed discussion of programming SimProcedures may be found at <a class="reference external" href="https://docs.angr.io/docs/simprocedures.md">https://docs.angr.io/docs/simprocedures.md</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>arch</strong> &#8211; The architecture to use for this procedure</td>
</tr>
</tbody>
</table>
<p>The following parameters are optional:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>symbolic_return</strong> &#8211; Whether the procedure&#8217;s return value should be stubbed into a
single symbolic variable constratined to the real return value</li>
<li><strong>returns</strong> &#8211; Whether the procedure should return to its caller afterwards</li>
<li><strong>is_syscall</strong> &#8211; Whether this procedure is a syscall</li>
<li><strong>num_args</strong> &#8211; The number of arguments this procedure should extract</li>
<li><strong>display_name</strong> &#8211; The name to use when displaying this procedure</li>
<li><strong>cc</strong> &#8211; The SimCC to use for this procedure</li>
<li><strong>sim_kwargs</strong> &#8211; Additional keyword arguments to be passed to run()</li>
<li><strong>is_function</strong> &#8211; Whether this procedure emulates a function</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="angr.sim_procedure.SimProcedure.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>state</em>, <em>successors=None</em>, <em>arguments=None</em>, <em>ret_to=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_procedure.SimProcedure.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Call this method with a SimState and a SimSuccessors to execute the procedure.</p>
<p>Alternately, successors may be none if this is an inline call. In that case, you should
provide arguments to the function.</p>
</dd></dl>

<dl class="method">
<dt id="angr.sim_procedure.SimProcedure.run">
<code class="descname">run</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_procedure.SimProcedure.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement the actual procedure here!</p>
</dd></dl>

<dl class="method">
<dt id="angr.sim_procedure.SimProcedure.static_exits">
<code class="descname">static_exits</code><span class="sig-paren">(</span><em>blocks</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_procedure.SimProcedure.static_exits" title="Permalink to this definition">¶</a></dt>
<dd><p>Get new exits by performing static analysis and heuristics. This is a fast and best-effort approach to get new
exits for scenarios where states are not available (e.g. when building a fast CFG).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>blocks</strong> (<em>list</em>) &#8211; Blocks that are executed before reaching this SimProcedure.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A list of tuples. Each tuple is (address, jumpkind).</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.sim_procedure.SimProcedure.arg">
<code class="descname">arg</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_procedure.SimProcedure.arg" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the ith argument. Raise a SimProcedureArgumentError if we don&#8217;t have such an argument available.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>i</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The index of the argument to get</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The argument</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">object</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.sim_procedure.SimProcedure.inline_call">
<code class="descname">inline_call</code><span class="sig-paren">(</span><em>procedure</em>, <em>*arguments</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_procedure.SimProcedure.inline_call" title="Permalink to this definition">¶</a></dt>
<dd><p>Call another SimProcedure in-line to retrieve its return value.
Returns an instance of the procedure with the ret_expr property set.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>procedure</strong> &#8211; The class of the procedure to execute</li>
<li><strong>arguments</strong> &#8211; Any additional positional args will be used as arguments to the
procedure call</li>
<li><strong>sim_kwargs</strong> &#8211; Any additional keyword args will be passed as sim_kwargs to the
procedure construtor</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.sim_procedure.SimProcedure.ret">
<code class="descname">ret</code><span class="sig-paren">(</span><em>expr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_procedure.SimProcedure.ret" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an exit representing a return from this function.
If this is not an inline call, grab a return address from the state and jump to it.
If this is not an inline call, set a return expression with the calling convention.</p>
</dd></dl>

<dl class="method">
<dt id="angr.sim_procedure.SimProcedure.call">
<code class="descname">call</code><span class="sig-paren">(</span><em>addr</em>, <em>args</em>, <em>continue_at</em>, <em>cc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_procedure.SimProcedure.call" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an exit representing calling another function via pointer.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>addr</strong> &#8211; The address of the function to call</li>
<li><strong>args</strong> &#8211; The list of arguments to call the function with</li>
<li><strong>continue_at</strong> &#8211; Later, when the called function returns, execution of the current
procedure will continue in the named method.</li>
<li><strong>cc</strong> &#8211; Optional: use this calling convention for calling the new function.
Default is to use the current convention.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.sim_procedure.SimProcedure.jump">
<code class="descname">jump</code><span class="sig-paren">(</span><em>addr</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_procedure.SimProcedure.jump" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an exit representing jumping to an address.</p>
</dd></dl>

<dl class="method">
<dt id="angr.sim_procedure.SimProcedure.exit">
<code class="descname">exit</code><span class="sig-paren">(</span><em>exit_code</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_procedure.SimProcedure.exit" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an exit representing terminating the program.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.procedures"></span><span class="target" id="module-angr.procedures.stubs.format_parser"></span><dl class="class">
<dt id="angr.procedures.stubs.format_parser.FormatString">
<em class="property">class </em><code class="descclassname">angr.procedures.stubs.format_parser.</code><code class="descname">FormatString</code><span class="sig-paren">(</span><em>parser</em>, <em>components</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.procedures.stubs.format_parser.FormatString" title="Permalink to this definition">¶</a></dt>
<dd><p>Describes a format string.</p>
<p>Takes a list of components which are either just strings or a FormatSpecifier.</p>
<dl class="method">
<dt id="angr.procedures.stubs.format_parser.FormatString.replace">
<code class="descname">replace</code><span class="sig-paren">(</span><em>startpos</em>, <em>args</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.procedures.stubs.format_parser.FormatString.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Produce a new string based of the format string self with args <cite>args</cite> and return a new string, possibly
symbolic.</p>
</dd></dl>

<dl class="method">
<dt id="angr.procedures.stubs.format_parser.FormatString.interpret">
<code class="descname">interpret</code><span class="sig-paren">(</span><em>addr</em>, <em>startpos</em>, <em>args</em>, <em>region=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.procedures.stubs.format_parser.FormatString.interpret" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret a format string, reading the data at <cite>addr</cite> in <cite>region</cite> into <cite>args</cite> starting at <cite>startpos</cite>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="angr.procedures.stubs.format_parser.FormatSpecifier">
<em class="property">class </em><code class="descclassname">angr.procedures.stubs.format_parser.</code><code class="descname">FormatSpecifier</code><span class="sig-paren">(</span><em>string</em>, <em>length_spec</em>, <em>size</em>, <em>signed</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.procedures.stubs.format_parser.FormatSpecifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Describes a format specifier within a format string.</p>
</dd></dl>

<dl class="class">
<dt id="angr.procedures.stubs.format_parser.FormatParser">
<em class="property">class </em><code class="descclassname">angr.procedures.stubs.format_parser.</code><code class="descname">FormatParser</code><span class="sig-paren">(</span><em>project=None</em>, <em>cc=None</em>, <em>symbolic_return=None</em>, <em>returns=None</em>, <em>is_syscall=None</em>, <em>is_stub=False</em>, <em>num_args=None</em>, <em>display_name=None</em>, <em>library_name=None</em>, <em>is_function=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.procedures.stubs.format_parser.FormatParser" title="Permalink to this definition">¶</a></dt>
<dd><p>For SimProcedures relying on format strings.</p>
</dd></dl>

</div>
<div class="section" id="module-angr.calling_conventions">
<span id="calling-conventions-and-types"></span><h2>Calling Conventions and Types<a class="headerlink" href="#module-angr.calling_conventions" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="angr.calling_conventions.ArgSession">
<em class="property">class </em><code class="descclassname">angr.calling_conventions.</code><code class="descname">ArgSession</code><span class="sig-paren">(</span><em>cc</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.calling_conventions.ArgSession" title="Permalink to this definition">¶</a></dt>
<dd><p>A class to keep track of the state accumulated in laying parameters out into memory</p>
</dd></dl>

<dl class="class">
<dt id="angr.calling_conventions.SimCC">
<em class="property">class </em><code class="descclassname">angr.calling_conventions.</code><code class="descname">SimCC</code><span class="sig-paren">(</span><em>arch</em>, <em>args=None</em>, <em>ret_val=None</em>, <em>sp_delta=None</em>, <em>func_ty=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.calling_conventions.SimCC" title="Permalink to this definition">¶</a></dt>
<dd><p>A calling convention allows you to extract from a state the data passed from function to
function by calls and returns. Most of the methods provided by SimCC that operate on a state
assume that the program is just after a call but just before stack frame allocation, though
this may be overridden with the <cite>stack_base</cite> parameter to each individual method.</p>
<p>This is the base class for all calling conventions.</p>
<p>An instance of this class allows it to be tweaked to the way a specific function should be called.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>arch</strong> &#8211; The Archinfo arch for this CC</li>
<li><strong>args</strong> &#8211; A list of SimFunctionArguments describing where the arguments go</li>
<li><strong>ret_val</strong> &#8211; A SimFunctionArgument describing where the return value goes</li>
<li><strong>sp_delta</strong> &#8211; The amount the stack pointer changes over the course of this function - CURRENTLY UNUSED</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parmm func_ty:</th><td class="field-body"><p class="first last">A SimType for the function itself</p>
</td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="angr.calling_conventions.SimCC.from_arg_kinds">
<em class="property">classmethod </em><code class="descname">from_arg_kinds</code><span class="sig-paren">(</span><em>arch</em>, <em>fp_args</em>, <em>ret_fp=False</em>, <em>sizes=None</em>, <em>sp_delta=None</em>, <em>func_ty=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.calling_conventions.SimCC.from_arg_kinds" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an instance of the class that will extract floating-point/integral args correctly.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>arch</strong> &#8211; The Archinfo arch for this CC</li>
<li><strong>fp_args</strong> &#8211; A list, with one entry for each argument the function can take. True if the argument is fp,
false if it is integral.</li>
<li><strong>ret_fp</strong> &#8211; True if the return value for the function is fp.</li>
<li><strong>sizes</strong> &#8211; Optional: A list, with one entry for each argument the function can take. Each entry is the
size of the corresponding argument in bytes.</li>
<li><strong>sp_delta</strong> &#8211; The amount the stack pointer changes over the course of this function - CURRENTLY UNUSED</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parmm func_ty:</th><td class="field-body"><p class="first last">A SimType for the function itself</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="angr.calling_conventions.SimCC.int_args">
<code class="descname">int_args</code><a class="headerlink" href="#angr.calling_conventions.SimCC.int_args" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate through all the possible arg positions that can only be used to store integer or pointer values
Does not take into account customizations.</p>
<p>Returns an iterator of SimFunctionArguments</p>
</dd></dl>

<dl class="attribute">
<dt id="angr.calling_conventions.SimCC.both_args">
<code class="descname">both_args</code><a class="headerlink" href="#angr.calling_conventions.SimCC.both_args" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate through all the possible arg positions that can be used to store any kind of argument
Does not take into account customizations.</p>
<p>Returns an iterator of SimFunctionArguments</p>
</dd></dl>

<dl class="attribute">
<dt id="angr.calling_conventions.SimCC.fp_args">
<code class="descname">fp_args</code><a class="headerlink" href="#angr.calling_conventions.SimCC.fp_args" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate through all the possible arg positions that can only be used to store floating point values
Does not take into account customizations.</p>
<p>Returns an iterator of SimFunctionArguments</p>
</dd></dl>

<dl class="method">
<dt id="angr.calling_conventions.SimCC.is_fp_arg">
<code class="descname">is_fp_arg</code><span class="sig-paren">(</span><em>arg</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.calling_conventions.SimCC.is_fp_arg" title="Permalink to this definition">¶</a></dt>
<dd><p>This should take a SimFunctionArgument instance and return whether or not that argument is a floating-point
argument.</p>
<dl class="docutils">
<dt>Returns True for MUST be a floating point arg,</dt>
<dd>False for MUST NOT be a floating point arg,
None for when it can be either.</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="angr.calling_conventions.SimCC.ArgSession">
<em class="property">class </em><code class="descname">ArgSession</code><span class="sig-paren">(</span><em>cc</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.calling_conventions.SimCC.ArgSession" title="Permalink to this definition">¶</a></dt>
<dd><p>A class to keep track of the state accumulated in laying parameters out into memory</p>
</dd></dl>

<dl class="attribute">
<dt id="angr.calling_conventions.SimCC.arg_session">
<code class="descclassname">SimCC.</code><code class="descname">arg_session</code><a class="headerlink" href="#angr.calling_conventions.SimCC.arg_session" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an arg session.</p>
<p>A session provides the control interface necessary to describe how integral and floating-point arguments are
laid out into memory. The default behavior is that there are a finite list of int-only and fp-only argument
slots, and an infinite number of generic slots, and when an argument of a given type is requested, the most
slot available is used. If you need different behavior, subclass ArgSession.</p>
</dd></dl>

<dl class="method">
<dt id="angr.calling_conventions.SimCC.stack_space">
<code class="descclassname">SimCC.</code><code class="descname">stack_space</code><span class="sig-paren">(</span><em>args</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.calling_conventions.SimCC.stack_space" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>args</strong> &#8211; A list of SimFunctionArguments</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The number of bytes that should be allocated on the stack to store all these args,
NOT INCLUDING the return address.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="angr.calling_conventions.SimCC.return_val">
<code class="descclassname">SimCC.</code><code class="descname">return_val</code><a class="headerlink" href="#angr.calling_conventions.SimCC.return_val" title="Permalink to this definition">¶</a></dt>
<dd><p>The location the return value is stored.</p>
</dd></dl>

<dl class="attribute">
<dt id="angr.calling_conventions.SimCC.return_addr">
<code class="descclassname">SimCC.</code><code class="descname">return_addr</code><a class="headerlink" href="#angr.calling_conventions.SimCC.return_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>The location the return address is stored.</p>
</dd></dl>

<dl class="method">
<dt id="angr.calling_conventions.SimCC.arg_locs">
<code class="descclassname">SimCC.</code><code class="descname">arg_locs</code><span class="sig-paren">(</span><em>is_fp</em>, <em>sizes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.calling_conventions.SimCC.arg_locs" title="Permalink to this definition">¶</a></dt>
<dd><p>Pass this a list of whether each parameter is floating-point or not, and get back a list of
SimFunctionArguments. Optionally, pass a list of argument sizes (in bytes) as well.</p>
<p>If you&#8217;ve customized this CC, this will sanity-check the provided locations with the given list.</p>
</dd></dl>

<dl class="method">
<dt id="angr.calling_conventions.SimCC.arg">
<code class="descclassname">SimCC.</code><code class="descname">arg</code><span class="sig-paren">(</span><em>state</em>, <em>index</em>, <em>stack_base=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.calling_conventions.SimCC.arg" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a bitvector expression representing the nth argument of a function.</p>
<p><cite>stack_base</cite> is an optional pointer to the top of the stack at the function start. If it is not
specified, use the current stack pointer.</p>
<p>WARNING: this assumes that none of the arguments are floating-point and they&#8217;re all single-word-sized, unless
you&#8217;ve customized this CC.</p>
</dd></dl>

<dl class="method">
<dt id="angr.calling_conventions.SimCC.get_args">
<code class="descclassname">SimCC.</code><code class="descname">get_args</code><span class="sig-paren">(</span><em>state</em>, <em>is_fp=None</em>, <em>sizes=None</em>, <em>stack_base=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.calling_conventions.SimCC.get_args" title="Permalink to this definition">¶</a></dt>
<dd><p><cite>is_fp</cite> should be a list of booleans specifying whether each corresponding argument is floating-point -
True for fp and False for int. For a shorthand to assume that all the parameters are int, pass the number of
parameters as an int.</p>
<p>If you&#8217;ve customized this CC, you may omit this parameter entirely. If it is provided, it is used for
sanity-checking.</p>
<p><cite>sizes</cite> is an optional list of argument sizes, in bytes. Be careful about using this if you&#8217;ve made explicit
the arg locations, since it might decide to combine two locations into one if an arg is too big.</p>
<p><cite>stack_base</cite> is an optional pointer to the top of the stack at the function start. If it is not
specified, use the current stack pointer.</p>
<p>Returns a list of bitvector expressions representing the arguments of a function.</p>
</dd></dl>

<dl class="method">
<dt id="angr.calling_conventions.SimCC.setup_callsite">
<code class="descclassname">SimCC.</code><code class="descname">setup_callsite</code><span class="sig-paren">(</span><em>state</em>, <em>ret_addr</em>, <em>args</em>, <em>stack_base=None</em>, <em>alloc_base=None</em>, <em>grow_like_stack=True</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.calling_conventions.SimCC.setup_callsite" title="Permalink to this definition">¶</a></dt>
<dd><p>This function performs the actions of the caller getting ready to jump into a function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>state</strong> &#8211; The SimState to operate on</li>
<li><strong>ret_addr</strong> &#8211; The address to return to when the called function finishes</li>
<li><strong>args</strong> &#8211; The list of arguments that that the called function will see</li>
<li><strong>stack_base</strong> &#8211; An optional pointer to use as the top of the stack, circa the function entry point</li>
<li><strong>alloc_base</strong> &#8211; An optional pointer to use as the place to put excess argument data</li>
<li><strong>grow_like_stack</strong> &#8211; When allocating data at alloc_base, whether to allocate at decreasing addresses</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The idea here is that you can provide almost any kind of python type in <cite>args</cite> and it&#8217;ll be translated to a
binary format to be placed into simulated memory. Lists (representing arrays) must be entirely elements of the
same type and size, while tuples (representing structs) can be elements of any type and size.
If you&#8217;d like there to be a pointer to a given value, wrap the value in a <cite>PointerWrapper</cite>. Any value
that can&#8217;t fit in a register will be automatically put in a
PointerWrapper.</p>
<p>If stack_base is not provided, the current stack pointer will be used, and it will be updated.
If alloc_base is not provided, the current stack pointer will be used, and it will be updated.
You might not like the results if you provide stack_base but not alloc_base.</p>
<p>grow_like_stack controls the behavior of allocating data at alloc_base. When data from args needs to be wrapped
in a pointer, the pointer needs to point somewhere, so that data is dumped into memory at alloc_base. If you
set alloc_base to point to somewhere other than the stack, set grow_like_stack to False so that sequencial
allocations happen at increasing addresses.</p>
</dd></dl>

<dl class="method">
<dt id="angr.calling_conventions.SimCC.teardown_callsite">
<code class="descclassname">SimCC.</code><code class="descname">teardown_callsite</code><span class="sig-paren">(</span><em>state</em>, <em>return_val=None</em>, <em>arg_types=None</em>, <em>force_callee_cleanup=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.calling_conventions.SimCC.teardown_callsite" title="Permalink to this definition">¶</a></dt>
<dd><p>This function performs the actions of the callee as it&#8217;s getting ready to return.
It returns the address to return to.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>state</strong> &#8211; The state to mutate</li>
<li><strong>return_val</strong> &#8211; The value to return</li>
<li><strong>arg_types</strong> &#8211; The fp-ness of each of the args. Used to calculate sizes to clean up</li>
<li><strong>force_callee_cleanup</strong> &#8211; If we should clean up the stack allocation for the arguments even if it&#8217;s not
the callee&#8217;s job to do so</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>TODO: support the stack_base parameter from setup_callsite...? Does that make sense in this context?
Maybe it could make sense by saying that you pass it in as something like the &#8220;saved base pointer&#8221; value?</p>
</dd></dl>

<dl class="method">
<dt id="angr.calling_conventions.SimCC.get_return_val">
<code class="descclassname">SimCC.</code><code class="descname">get_return_val</code><span class="sig-paren">(</span><em>state</em>, <em>is_fp=None</em>, <em>size=None</em>, <em>stack_base=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.calling_conventions.SimCC.get_return_val" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the return value out of the given state</p>
</dd></dl>

<dl class="method">
<dt id="angr.calling_conventions.SimCC.set_return_val">
<code class="descclassname">SimCC.</code><code class="descname">set_return_val</code><span class="sig-paren">(</span><em>state</em>, <em>val</em>, <em>is_fp=None</em>, <em>size=None</em>, <em>stack_base=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.calling_conventions.SimCC.set_return_val" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the return value into the given state</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="angr.calling_conventions.SimLyingRegArg">
<em class="property">class </em><code class="descclassname">angr.calling_conventions.</code><code class="descname">SimLyingRegArg</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.calling_conventions.SimLyingRegArg" title="Permalink to this definition">¶</a></dt>
<dd><p>A register that LIES about the types it holds</p>
</dd></dl>

<dl class="class">
<dt id="angr.calling_conventions.SimCCUnknown">
<em class="property">class </em><code class="descclassname">angr.calling_conventions.</code><code class="descname">SimCCUnknown</code><span class="sig-paren">(</span><em>arch</em>, <em>args=None</em>, <em>ret_val=None</em>, <em>sp_delta=None</em>, <em>func_ty=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.calling_conventions.SimCCUnknown" title="Permalink to this definition">¶</a></dt>
<dd><p>Represent an unknown calling convention.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>arch</strong> &#8211; The Archinfo arch for this CC</li>
<li><strong>args</strong> &#8211; A list of SimFunctionArguments describing where the arguments go</li>
<li><strong>ret_val</strong> &#8211; A SimFunctionArgument describing where the return value goes</li>
<li><strong>sp_delta</strong> &#8211; The amount the stack pointer changes over the course of this function - CURRENTLY UNUSED</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parmm func_ty:</th><td class="field-body"><p class="first last">A SimType for the function itself</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<span class="target" id="module-angr.sim_variable"></span><dl class="class">
<dt id="angr.sim_variable.SimVariableSet">
<em class="property">class </em><code class="descclassname">angr.sim_variable.</code><code class="descname">SimVariableSet</code><a class="headerlink" href="#angr.sim_variable.SimVariableSet" title="Permalink to this definition">¶</a></dt>
<dd><p>A collection of SimVariables.</p>
<dl class="method">
<dt id="angr.sim_variable.SimVariableSet.complement">
<code class="descname">complement</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_variable.SimVariableSet.complement" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the complement of <cite>self</cite> and <cite>other</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> &#8211; Another SimVariableSet instance.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The complement result.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.sim_type"></span><dl class="class">
<dt id="angr.sim_type.SimType">
<em class="property">class </em><code class="descclassname">angr.sim_type.</code><code class="descname">SimType</code><span class="sig-paren">(</span><em>label=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_type.SimType" title="Permalink to this definition">¶</a></dt>
<dd><p>SimType exists to track type information for SimProcedures.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>label</strong> &#8211; the type label.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="angr.sim_type.SimTypeBottom">
<em class="property">class </em><code class="descclassname">angr.sim_type.</code><code class="descname">SimTypeBottom</code><span class="sig-paren">(</span><em>label=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_type.SimTypeBottom" title="Permalink to this definition">¶</a></dt>
<dd><p>SimTypeBottom basically repesents a type error.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>label</strong> &#8211; the type label.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="angr.sim_type.SimTypeTop">
<em class="property">class </em><code class="descclassname">angr.sim_type.</code><code class="descname">SimTypeTop</code><span class="sig-paren">(</span><em>size=None</em>, <em>label=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_type.SimTypeTop" title="Permalink to this definition">¶</a></dt>
<dd><p>SimTypeTop represents any type (mostly used with a pointer for void*).</p>
</dd></dl>

<dl class="class">
<dt id="angr.sim_type.SimTypeReg">
<em class="property">class </em><code class="descclassname">angr.sim_type.</code><code class="descname">SimTypeReg</code><span class="sig-paren">(</span><em>size</em>, <em>label=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_type.SimTypeReg" title="Permalink to this definition">¶</a></dt>
<dd><p>SimTypeReg is the base type for all types that are register-sized.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>label</strong> &#8211; the type label.</li>
<li><strong>size</strong> &#8211; the size of the type (e.g. 32bit, 8bit, etc.).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="angr.sim_type.SimTypeNum">
<em class="property">class </em><code class="descclassname">angr.sim_type.</code><code class="descname">SimTypeNum</code><span class="sig-paren">(</span><em>size</em>, <em>signed=True</em>, <em>label=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_type.SimTypeNum" title="Permalink to this definition">¶</a></dt>
<dd><p>SimTypeNum is a numeric type of arbitrary length</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>size</strong> &#8211; The size of the integer, in bytes</li>
<li><strong>signed</strong> &#8211; Whether the integer is signed or not</li>
<li><strong>label</strong> &#8211; A label for the type</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="angr.sim_type.SimTypeInt">
<em class="property">class </em><code class="descclassname">angr.sim_type.</code><code class="descname">SimTypeInt</code><span class="sig-paren">(</span><em>signed=True</em>, <em>label=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_type.SimTypeInt" title="Permalink to this definition">¶</a></dt>
<dd><p>SimTypeInt is a type that specifies a signed or unsigned C integer.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>signed</strong> &#8211; True if signed, False if unsigned</li>
<li><strong>label</strong> &#8211; The type label</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="angr.sim_type.SimTypeChar">
<em class="property">class </em><code class="descclassname">angr.sim_type.</code><code class="descname">SimTypeChar</code><span class="sig-paren">(</span><em>label=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_type.SimTypeChar" title="Permalink to this definition">¶</a></dt>
<dd><p>SimTypeChar is a type that specifies a character;
this could be represented by a byte, but this is meant to be interpreted as a character.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>label</strong> &#8211; the type label.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="angr.sim_type.SimTypeFd">
<em class="property">class </em><code class="descclassname">angr.sim_type.</code><code class="descname">SimTypeFd</code><span class="sig-paren">(</span><em>label=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_type.SimTypeFd" title="Permalink to this definition">¶</a></dt>
<dd><p>SimTypeFd is a type that specifies a file descriptor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>label</strong> &#8211; the type label</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="angr.sim_type.SimTypePointer">
<em class="property">class </em><code class="descclassname">angr.sim_type.</code><code class="descname">SimTypePointer</code><span class="sig-paren">(</span><em>pts_to</em>, <em>label=None</em>, <em>offset=0</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_type.SimTypePointer" title="Permalink to this definition">¶</a></dt>
<dd><p>SimTypePointer is a type that specifies a pointer to some other type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>label</strong> &#8211; The type label.</li>
<li><strong>pts_to</strong> &#8211; The type to which this pointer points to.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="angr.sim_type.SimTypeFixedSizeArray">
<em class="property">class </em><code class="descclassname">angr.sim_type.</code><code class="descname">SimTypeFixedSizeArray</code><span class="sig-paren">(</span><em>elem_type</em>, <em>length</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_type.SimTypeFixedSizeArray" title="Permalink to this definition">¶</a></dt>
<dd><p>SimTypeFixedSizeArray is a literal (i.e. not a pointer) fixed-size array.</p>
</dd></dl>

<dl class="class">
<dt id="angr.sim_type.SimTypeArray">
<em class="property">class </em><code class="descclassname">angr.sim_type.</code><code class="descname">SimTypeArray</code><span class="sig-paren">(</span><em>elem_type</em>, <em>length=None</em>, <em>label=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_type.SimTypeArray" title="Permalink to this definition">¶</a></dt>
<dd><p>SimTypeArray is a type that specifies a pointer to an array; while it is a pointer, it has a semantic difference.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>label</strong> &#8211; The type label.</li>
<li><strong>elem_type</strong> &#8211; The type of each element in the array.</li>
<li><strong>length</strong> &#8211; An expression of the length of the array, if known.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="angr.sim_type.SimTypeString">
<em class="property">class </em><code class="descclassname">angr.sim_type.</code><code class="descname">SimTypeString</code><span class="sig-paren">(</span><em>length=None</em>, <em>label=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_type.SimTypeString" title="Permalink to this definition">¶</a></dt>
<dd><p>SimTypeString is a type that represents a C-style string,
i.e. a NUL-terminated array of bytes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>label</strong> &#8211; The type label.</li>
<li><strong>length</strong> &#8211; An expression of the length of the string, if known.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="angr.sim_type.SimTypeWString">
<em class="property">class </em><code class="descclassname">angr.sim_type.</code><code class="descname">SimTypeWString</code><span class="sig-paren">(</span><em>length=None</em>, <em>label=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_type.SimTypeWString" title="Permalink to this definition">¶</a></dt>
<dd><p>A wide-character null-terminated string, where each character is 2 bytes.</p>
</dd></dl>

<dl class="class">
<dt id="angr.sim_type.SimTypeFunction">
<em class="property">class </em><code class="descclassname">angr.sim_type.</code><code class="descname">SimTypeFunction</code><span class="sig-paren">(</span><em>args</em>, <em>returnty</em>, <em>label=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_type.SimTypeFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>SimTypeFunction is a type that specifies an actual function (i.e. not a pointer) with certain types of arguments and
a certain return value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>label</strong> &#8211; The type label</li>
<li><strong>args</strong> &#8211; A tuple of types representing the arguments to the function</li>
<li><strong>returnty</strong> &#8211; The return type of the function, or none for void</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="angr.sim_type.SimTypeLength">
<em class="property">class </em><code class="descclassname">angr.sim_type.</code><code class="descname">SimTypeLength</code><span class="sig-paren">(</span><em>signed=False</em>, <em>addr=None</em>, <em>length=None</em>, <em>label=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_type.SimTypeLength" title="Permalink to this definition">¶</a></dt>
<dd><p>SimTypeLength is a type that specifies the length of some buffer in memory.</p>
<p>...I&#8217;m not really sure what the original design of this class was going for</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>signed</strong> &#8211; Whether the value is signed or not</li>
<li><strong>label</strong> &#8211; The type label.</li>
<li><strong>addr</strong> &#8211; The memory address (expression).</li>
<li><strong>length</strong> &#8211; The length (expression).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="angr.sim_type.SimTypeFloat">
<em class="property">class </em><code class="descclassname">angr.sim_type.</code><code class="descname">SimTypeFloat</code><span class="sig-paren">(</span><em>size=32</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_type.SimTypeFloat" title="Permalink to this definition">¶</a></dt>
<dd><p>An IEEE754 single-precision floating point number</p>
</dd></dl>

<dl class="class">
<dt id="angr.sim_type.SimTypeDouble">
<em class="property">class </em><code class="descclassname">angr.sim_type.</code><code class="descname">SimTypeDouble</code><a class="headerlink" href="#angr.sim_type.SimTypeDouble" title="Permalink to this definition">¶</a></dt>
<dd><p>An IEEE754 double-precision floating point number</p>
</dd></dl>

<dl class="class">
<dt id="angr.sim_type.SimStructValue">
<em class="property">class </em><code class="descclassname">angr.sim_type.</code><code class="descname">SimStructValue</code><span class="sig-paren">(</span><em>struct</em>, <em>values=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_type.SimStructValue" title="Permalink to this definition">¶</a></dt>
<dd><p>A SimStruct type paired with some real values</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>struct</strong> &#8211; A SimStruct instance describing the type of this struct</li>
<li><strong>values</strong> &#8211; A mapping from struct fields to values</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="angr.sim_type.SimUnion">
<em class="property">class </em><code class="descclassname">angr.sim_type.</code><code class="descname">SimUnion</code><span class="sig-paren">(</span><em>members</em>, <em>label=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_type.SimUnion" title="Permalink to this definition">¶</a></dt>
<dd><p>why</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>members</strong> &#8211; The members of the struct, as a mapping name -&gt; type</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="angr.sim_type.define_struct">
<code class="descclassname">angr.sim_type.</code><code class="descname">define_struct</code><span class="sig-paren">(</span><em>defn</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_type.define_struct" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a struct definition globally</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">define_struct</span><span class="p">(</span><span class="s1">&#39;struct abcd {int x; int y;}&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="angr.sim_type.register_types">
<code class="descclassname">angr.sim_type.</code><code class="descname">register_types</code><span class="sig-paren">(</span><em>mapping</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_type.register_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Pass in a mapping from name to SimType and they will be registered to the global type store</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">register_types</span><span class="p">(</span><span class="n">parse_types</span><span class="p">(</span><span class="s2">&quot;typedef int x; typedef float y;&quot;</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="angr.sim_type.do_preprocess">
<code class="descclassname">angr.sim_type.</code><code class="descname">do_preprocess</code><span class="sig-paren">(</span><em>defn</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_type.do_preprocess" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a string through the C preprocessor that ships with pycparser but is weirdly inaccessable?</p>
</dd></dl>

<dl class="function">
<dt id="angr.sim_type.parse_defns">
<code class="descclassname">angr.sim_type.</code><code class="descname">parse_defns</code><span class="sig-paren">(</span><em>defn</em>, <em>preprocess=True</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_type.parse_defns" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse a series of C definitions, returns a mapping from variable name to variable type object</p>
</dd></dl>

<dl class="function">
<dt id="angr.sim_type.parse_types">
<code class="descclassname">angr.sim_type.</code><code class="descname">parse_types</code><span class="sig-paren">(</span><em>defn</em>, <em>preprocess=True</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_type.parse_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse a series of C definitions, returns a mapping from type name to type object</p>
</dd></dl>

<dl class="function">
<dt id="angr.sim_type.parse_file">
<code class="descclassname">angr.sim_type.</code><code class="descname">parse_file</code><span class="sig-paren">(</span><em>defn</em>, <em>preprocess=True</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_type.parse_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse a series of C definitions, returns a tuple of two type mappings, one for variable
definitions and one for type definitions.</p>
</dd></dl>

<dl class="function">
<dt id="angr.sim_type.parse_type">
<code class="descclassname">angr.sim_type.</code><code class="descname">parse_type</code><span class="sig-paren">(</span><em>defn</em>, <em>preprocess=True</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.sim_type.parse_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse a simple type expression into a SimType</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parse_type</span><span class="p">(</span><span class="s1">&#39;int *&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<span class="target" id="module-angr.type_backend"></span></div>
<div class="section" id="module-angr.knowledge_base">
<span id="knowledge-base"></span><h2>Knowledge Base<a class="headerlink" href="#module-angr.knowledge_base" title="Permalink to this headline">¶</a></h2>
<p>Representing the artifacts of a project.</p>
<dl class="class">
<dt id="angr.knowledge_base.KnowledgeBase">
<em class="property">class </em><code class="descclassname">angr.knowledge_base.</code><code class="descname">KnowledgeBase</code><span class="sig-paren">(</span><em>project</em>, <em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.knowledge_base.KnowledgeBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a &#8220;model&#8221; of knowledge about an artifact.</p>
<p>Contains things like a CFG, data references, etc.</p>
</dd></dl>

<span class="target" id="module-angr.knowledge_plugins"></span><span class="target" id="module-angr.knowledge_plugins.plugin"></span><span class="target" id="module-angr.knowledge_plugins.comments"></span><span class="target" id="module-angr.knowledge_plugins.data"></span><span class="target" id="module-angr.knowledge_plugins.indirect_jumps"></span><span class="target" id="module-angr.knowledge_plugins.labels"></span><span class="target" id="module-angr.knowledge_plugins.functions"></span><span class="target" id="module-angr.knowledge_plugins.functions.function_manager"></span><dl class="class">
<dt id="angr.knowledge_plugins.functions.function_manager.FunctionDict">
<em class="property">class </em><code class="descclassname">angr.knowledge_plugins.functions.function_manager.</code><code class="descname">FunctionDict</code><span class="sig-paren">(</span><em>backref</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.knowledge_plugins.functions.function_manager.FunctionDict" title="Permalink to this definition">¶</a></dt>
<dd><p>FunctionDict is a dict where the keys are function starting addresses and
map to the associated <code class="xref py py-class docutils literal"><span class="pre">Function</span></code>.</p>
</dd></dl>

<dl class="class">
<dt id="angr.knowledge_plugins.functions.function_manager.FunctionManager">
<em class="property">class </em><code class="descclassname">angr.knowledge_plugins.functions.function_manager.</code><code class="descname">FunctionManager</code><span class="sig-paren">(</span><em>kb</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.knowledge_plugins.functions.function_manager.FunctionManager" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a function boundaries management tool. It takes in intermediate
results during CFG generation, and manages a function map of the binary.</p>
<dl class="method">
<dt id="angr.knowledge_plugins.functions.function_manager.FunctionManager.contains_addr">
<code class="descname">contains_addr</code><span class="sig-paren">(</span><em>addr</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.knowledge_plugins.functions.function_manager.FunctionManager.contains_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Decide if an address is handled by the function manager.</p>
<p>Note: this function is non-conformant with python programming idioms, but its needed for performance reasons.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>addr</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; Address of the function.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.knowledge_plugins.functions.function_manager.FunctionManager.ceiling_func">
<code class="descname">ceiling_func</code><span class="sig-paren">(</span><em>addr</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.knowledge_plugins.functions.function_manager.FunctionManager.ceiling_func" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the function who has the least address that is greater than or equal to <cite>addr</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>addr</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The address to query.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A Function instance, or None if there is no other function after <cite>addr</cite>.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#angr.knowledge_plugins.functions.function.Function" title="angr.knowledge_plugins.functions.function.Function">Function</a> or None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.knowledge_plugins.functions.function_manager.FunctionManager.floor_func">
<code class="descname">floor_func</code><span class="sig-paren">(</span><em>addr</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.knowledge_plugins.functions.function_manager.FunctionManager.floor_func" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the function who has the greatest address that is less than or equal to <cite>addr</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>addr</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The address to query.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A Function instance, or None if there is no other function before <cite>addr</cite>.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#angr.knowledge_plugins.functions.function.Function" title="angr.knowledge_plugins.functions.function.Function">Function</a> or None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.knowledge_plugins.functions.function_manager.FunctionManager.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>addr=None</em>, <em>name=None</em>, <em>create=False</em>, <em>syscall=False</em>, <em>plt=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.knowledge_plugins.functions.function_manager.FunctionManager.function" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a function object from the function manager.</p>
<p>Pass either <cite>addr</cite> or <cite>name</cite> with the appropriate values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>addr</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; Address of the function.</li>
<li><strong>name</strong> (<em>str</em>) &#8211; Name of the function.</li>
<li><strong>create</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; Whether to create the function or not if the function does not exist.</li>
<li><strong>syscall</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; True to create the function as a syscall, False otherwise.</li>
<li><strong>or None plt</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; True to find the PLT stub, False to find a non-PLT stub, None to disable this
restriction.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The Function instance, or None if the function is not found and create is False.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#angr.knowledge_plugins.functions.function.Function" title="angr.knowledge_plugins.functions.function.Function">Function</a> or None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.knowledge_plugins.functions.function"></span><dl class="class">
<dt id="angr.knowledge_plugins.functions.function.Function">
<em class="property">class </em><code class="descclassname">angr.knowledge_plugins.functions.function.</code><code class="descname">Function</code><span class="sig-paren">(</span><em>function_manager</em>, <em>addr</em>, <em>name=None</em>, <em>syscall=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.knowledge_plugins.functions.function.Function" title="Permalink to this definition">¶</a></dt>
<dd><p>A representation of a function and various information about it.</p>
<p>Function constructor</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>addr</strong> &#8211; The address of the function.</li>
<li><strong>name</strong> &#8211; (Optional) The name of the function.</li>
<li><strong>syscall</strong> &#8211; (Optional) Whether this function is a syscall or not.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="angr.knowledge_plugins.functions.function.Function.blocks">
<code class="descname">blocks</code><a class="headerlink" href="#angr.knowledge_plugins.functions.function.Function.blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>An iterator of all local blocks in the current function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">angr.lifter.Block instances.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="angr.knowledge_plugins.functions.function.Function.block_addrs">
<code class="descname">block_addrs</code><a class="headerlink" href="#angr.knowledge_plugins.functions.function.Function.block_addrs" title="Permalink to this definition">¶</a></dt>
<dd><p>An iterator of all local block addresses in the current function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">block addresses.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="angr.knowledge_plugins.functions.function.Function.block_addrs_set">
<code class="descname">block_addrs_set</code><a class="headerlink" href="#angr.knowledge_plugins.functions.function.Function.block_addrs_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a set of block addresses for a better performance of inclusion tests.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A set of block addresses.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">set</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="angr.knowledge_plugins.functions.function.Function.operations">
<code class="descname">operations</code><a class="headerlink" href="#angr.knowledge_plugins.functions.function.Function.operations" title="Permalink to this definition">¶</a></dt>
<dd><p>All of the operations that are done by this functions.</p>
</dd></dl>

<dl class="attribute">
<dt id="angr.knowledge_plugins.functions.function.Function.code_constants">
<code class="descname">code_constants</code><a class="headerlink" href="#angr.knowledge_plugins.functions.function.Function.code_constants" title="Permalink to this definition">¶</a></dt>
<dd><p>All of the constants that are used by this functions&#8217;s code.</p>
</dd></dl>

<dl class="method">
<dt id="angr.knowledge_plugins.functions.function.Function.string_references">
<code class="descname">string_references</code><span class="sig-paren">(</span><em>minimum_length=2</em>, <em>vex_only=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.knowledge_plugins.functions.function.Function.string_references" title="Permalink to this definition">¶</a></dt>
<dd><p>All of the constant string references used by this function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>minimum_length</strong> &#8211; The minimum length of strings to find (default is 1)</li>
<li><strong>vex_only</strong> &#8211; Only analyze VEX IR, don&#8217;t interpret the entry state to detect additional constants.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A list of tuples of (address, string) where is address is the location of the string in
memory.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="angr.knowledge_plugins.functions.function.Function.local_runtime_values">
<code class="descname">local_runtime_values</code><a class="headerlink" href="#angr.knowledge_plugins.functions.function.Function.local_runtime_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Tries to find all runtime values of this function which do not come from inputs.
These values are generated by starting from a blank state and reanalyzing the basic blocks once each.
Function calls are skipped, and back edges are never taken so these values are often unreliable,
This function is good at finding simple constant addresses which the function will use or calculate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a set of constants</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="angr.knowledge_plugins.functions.function.Function.runtime_values">
<code class="descname">runtime_values</code><a class="headerlink" href="#angr.knowledge_plugins.functions.function.Function.runtime_values" title="Permalink to this definition">¶</a></dt>
<dd><p>All of the concrete values used by this function at runtime (i.e., including passed-in arguments and global
values).</p>
</dd></dl>

<dl class="attribute">
<dt id="angr.knowledge_plugins.functions.function.Function.binary">
<code class="descname">binary</code><a class="headerlink" href="#angr.knowledge_plugins.functions.function.Function.binary" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the object this function belongs to.
:return: The object this function belongs to.</p>
</dd></dl>

<dl class="method">
<dt id="angr.knowledge_plugins.functions.function.Function.add_jumpout_site">
<code class="descname">add_jumpout_site</code><span class="sig-paren">(</span><em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.knowledge_plugins.functions.function.Function.add_jumpout_site" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a custom jumpout site.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>node</strong> &#8211; The address of the basic block that control flow leaves during this transition.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.knowledge_plugins.functions.function.Function.add_retout_site">
<code class="descname">add_retout_site</code><span class="sig-paren">(</span><em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.knowledge_plugins.functions.function.Function.add_retout_site" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a custom retout site.</p>
<p>Retout (returning to outside of the function) sites are very rare. It mostly occurs during CFG recovery when we
incorrectly identify the beginning of a function in the first iteration, and then correctly identify that
function later in the same iteration (function alignments can lead to this bizarre case). We will mark all edges
going out of the header of that function as a outside edge, because all successors now belong to the
incorrectly-identified function. This identification error will be fixed in the second iteration of CFG
recovery. However, we still want to keep track of jumpouts/retouts during the first iteration so other logic in
CFG recovery still work.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>node</strong> &#8211; The address of the basic block that control flow leaves the current function after a call.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.knowledge_plugins.functions.function.Function.mark_nonreturning_calls_endpoints">
<code class="descname">mark_nonreturning_calls_endpoints</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.knowledge_plugins.functions.function.Function.mark_nonreturning_calls_endpoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate through all call edges in transition graph. For each call a non-returning function, mark the source
basic block as an endpoint.</p>
<p>This method should only be executed once all functions are recovered and analyzed by CFG recovery, so we know
whether each function returns or not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.knowledge_plugins.functions.function.Function.get_call_sites">
<code class="descname">get_call_sites</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.knowledge_plugins.functions.function.Function.get_call_sites" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a list of all the basic blocks that end in calls.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A list of the addresses of the blocks that end in calls.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.knowledge_plugins.functions.function.Function.get_call_target">
<code class="descname">get_call_target</code><span class="sig-paren">(</span><em>callsite_addr</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.knowledge_plugins.functions.function.Function.get_call_target" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the target of a call.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>callsite_addr</strong> &#8211; The address of a basic block that ends in a call.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The target of said call, or None if callsite_addr is not a
callsite.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.knowledge_plugins.functions.function.Function.get_call_return">
<code class="descname">get_call_return</code><span class="sig-paren">(</span><em>callsite_addr</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.knowledge_plugins.functions.function.Function.get_call_return" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the hypothetical return address of a call.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>callsite_addr</strong> &#8211; The address of the basic block that ends in a call.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The likely return target of said call, or None if callsite_addr
is not a callsite.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="angr.knowledge_plugins.functions.function.Function.graph">
<code class="descname">graph</code><a class="headerlink" href="#angr.knowledge_plugins.functions.function.Function.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a local transition graph that only contain nodes in current function.</p>
</dd></dl>

<dl class="method">
<dt id="angr.knowledge_plugins.functions.function.Function.subgraph">
<code class="descname">subgraph</code><span class="sig-paren">(</span><em>ins_addrs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.knowledge_plugins.functions.function.Function.subgraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a sub control flow graph of instruction addresses based on self.graph</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>ins_addrs</strong> (<em>iterable</em>) &#8211; A collection of instruction addresses that should be included in the subgraph.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A subgraph.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">networkx.DiGraph</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.knowledge_plugins.functions.function.Function.instruction_size">
<code class="descname">instruction_size</code><span class="sig-paren">(</span><em>insn_addr</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.knowledge_plugins.functions.function.Function.instruction_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the size of the instruction specified by <cite>insn_addr</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>insn_addr</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; Address of the instruction</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Size of the instruction in bytes, or None if the instruction is not found.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int">int</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.knowledge_plugins.functions.function.Function.dbg_print">
<code class="descname">dbg_print</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.knowledge_plugins.functions.function.Function.dbg_print" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a representation of the list of basic blocks in this function.</p>
</dd></dl>

<dl class="method">
<dt id="angr.knowledge_plugins.functions.function.Function.dbg_draw">
<code class="descname">dbg_draw</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.knowledge_plugins.functions.function.Function.dbg_draw" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw the graph and save it to a PNG file.</p>
</dd></dl>

<dl class="method">
<dt id="angr.knowledge_plugins.functions.function.Function.normalize">
<code class="descname">normalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.knowledge_plugins.functions.function.Function.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Make sure all basic blocks in the transition graph of this function do not overlap. You will end up with a CFG
that IDA Pro generates.</p>
<p>This method does not touch the CFG result. You may call CFG{Accurate, Fast}.normalize() for that matter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.knowledge_plugins.variables"></span><span class="target" id="module-angr.knowledge_plugins.variables.variable_access"></span><span class="target" id="module-angr.knowledge_plugins.variables.variable_manager"></span><dl class="class">
<dt id="angr.knowledge_plugins.variables.variable_manager.LiveVariables">
<em class="property">class </em><code class="descclassname">angr.knowledge_plugins.variables.variable_manager.</code><code class="descname">LiveVariables</code><span class="sig-paren">(</span><em>register_region</em>, <em>stack_region</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.knowledge_plugins.variables.variable_manager.LiveVariables" title="Permalink to this definition">¶</a></dt>
<dd><p>A collection of live variables at a program point.</p>
</dd></dl>

<dl class="class">
<dt id="angr.knowledge_plugins.variables.variable_manager.VariableManagerInternal">
<em class="property">class </em><code class="descclassname">angr.knowledge_plugins.variables.variable_manager.</code><code class="descname">VariableManagerInternal</code><span class="sig-paren">(</span><em>manager</em>, <em>func_addr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.knowledge_plugins.variables.variable_manager.VariableManagerInternal" title="Permalink to this definition">¶</a></dt>
<dd><p>Manage variables for a function. It is meant to be used internally by VariableManager.</p>
<dl class="method">
<dt id="angr.knowledge_plugins.variables.variable_manager.VariableManagerInternal.get_variables">
<code class="descname">get_variables</code><span class="sig-paren">(</span><em>sort=None</em>, <em>collapse_same_ident=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.knowledge_plugins.variables.variable_manager.VariableManagerInternal.get_variables" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a list of variables.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>or None sort</strong> (<em>str</em>) &#8211; Sort of the variable to get.</li>
<li><strong>collapse_same_ident</strong> &#8211; Whether variables of the same identifier should be collapsed or not.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A list of variables.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.knowledge_plugins.variables.variable_manager.VariableManagerInternal.input_variables">
<code class="descname">input_variables</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.knowledge_plugins.variables.variable_manager.VariableManagerInternal.input_variables" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all variables that have never been written to.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A list of variables that are never written to.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.knowledge_plugins.variables.variable_manager.VariableManagerInternal.assign_variable_names">
<code class="descname">assign_variable_names</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.knowledge_plugins.variables.variable_manager.VariableManagerInternal.assign_variable_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Assign default names to all variables.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="angr.knowledge_plugins.variables.variable_manager.VariableManager">
<em class="property">class </em><code class="descclassname">angr.knowledge_plugins.variables.variable_manager.</code><code class="descname">VariableManager</code><span class="sig-paren">(</span><em>kb</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.knowledge_plugins.variables.variable_manager.VariableManager" title="Permalink to this definition">¶</a></dt>
<dd><p>Manage variables.</p>
<dl class="method">
<dt id="angr.knowledge_plugins.variables.variable_manager.VariableManager.get_variable_accesses">
<code class="descname">get_variable_accesses</code><span class="sig-paren">(</span><em>variable</em>, <em>same_name=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.knowledge_plugins.variables.variable_manager.VariableManager.get_variable_accesses" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a list of all references to the given variable.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> (<em>SimVariable</em>) &#8211; The variable.</li>
<li><strong>same_name</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; Whether to include all variables with the same variable name, or just
based on the variable identifier.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">All references to the variable.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-angr.analyses">
<span id="analysis"></span><h2>Analysis<a class="headerlink" href="#module-angr.analyses" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-angr.analyses.analysis"></span><dl class="class">
<dt id="angr.analyses.analysis.Analyses">
<em class="property">class </em><code class="descclassname">angr.analyses.analysis.</code><code class="descname">Analyses</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.analysis.Analyses" title="Permalink to this definition">¶</a></dt>
<dd><p>This class contains functions for all the registered and runnable analyses,</p>
<p>Creates an Analyses object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><strong>p</strong> &#8211; A project</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="angr.analyses.analysis.Analysis">
<em class="property">class </em><code class="descclassname">angr.analyses.analysis.</code><code class="descname">Analysis</code><a class="headerlink" href="#angr.analyses.analysis.Analysis" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents an analysis on the program.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><a class="reference internal" href="#module-angr.project" title="angr.project"><strong>project</strong></a> &#8211; The project for this analysis.</li>
<li><strong>kb</strong> (<a class="reference internal" href="#angr.knowledge_base.KnowledgeBase" title="angr.knowledge_base.KnowledgeBase"><em>KnowledgeBase</em></a>) &#8211; The knowledgebase object.</li>
<li><strong>_progress_callback</strong> (<a class="reference internal" href="#angr.factory.AngrObjectFactory.callable" title="angr.factory.AngrObjectFactory.callable"><em>callable</em></a>) &#8211; A callback function for receiving the progress of this analysis. It only takes
one argument, which is a float number from 0.0 to 100.0 indicating the current
progress.</li>
<li><strong>_show_progressbar</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; If a progressbar should be shown during the analysis. It&#8217;s independent from
_progress_callback.</li>
<li><strong>_progressbar</strong> (<em>progressbar.ProgressBar</em>) &#8211; The progress bar object.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<span class="target" id="module-angr.analyses.backward_slice"></span><dl class="class">
<dt id="angr.analyses.backward_slice.BackwardSlice">
<em class="property">class </em><code class="descclassname">angr.analyses.backward_slice.</code><code class="descname">BackwardSlice</code><span class="sig-paren">(</span><em>cfg</em>, <em>cdg</em>, <em>ddg</em>, <em>targets=None</em>, <em>cfg_node=None</em>, <em>stmt_id=None</em>, <em>control_flow_slice=False</em>, <em>same_function=False</em>, <em>no_construct=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.backward_slice.BackwardSlice" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a backward slice of the program.</p>
<p>Create a backward slice from a specific statement based on provided control flow graph (CFG), control
dependence graph (CDG), and data dependence graph (DDG).</p>
<p>The data dependence graph can be either CFG-based, or Value-set analysis based. A CFG-based DDG is much faster
to generate, but it only reflects those states while generating the CFG, and it is neither sound nor accurate.
The VSA based DDG (called VSA_DDG) is based on static analysis, which gives you a much better result.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cfg</strong> &#8211; The control flow graph.</li>
<li><strong>cdg</strong> &#8211; The control dependence graph.</li>
<li><strong>ddg</strong> &#8211; The data dependence graph.</li>
<li><strong>targets</strong> &#8211; A list of &#8220;target&#8221; that specify targets of the backward slices. Each target can be a
tuple in form of (cfg_node, stmt_idx), or a CodeLocation instance.</li>
<li><strong>cfg_node</strong> &#8211; Deprecated. The target CFGNode to reach. It should exist in the CFG.</li>
<li><strong>stmt_id</strong> &#8211; Deprecated. The target statement to reach.</li>
<li><strong>control_flow_slice</strong> &#8211; True/False, indicates whether we should slice only based on CFG. Sometimes when
acquiring DDG is difficult or impossible, you can just create a slice on your CFG.
Well, if you don&#8217;t even have a CFG, then...</li>
<li><strong>no_construct</strong> &#8211; Only used for testing and debugging to easily create a BackwardSlice object.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="angr.analyses.backward_slice.BackwardSlice.dbg_repr">
<code class="descname">dbg_repr</code><span class="sig-paren">(</span><em>max_display=10</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.backward_slice.BackwardSlice.dbg_repr" title="Permalink to this definition">¶</a></dt>
<dd><p>Debugging output of this slice.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>max_display</strong> &#8211; The maximum number of SimRun slices to show.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A string representation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.backward_slice.BackwardSlice.dbg_repr_run">
<code class="descname">dbg_repr_run</code><span class="sig-paren">(</span><em>run_addr</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.backward_slice.BackwardSlice.dbg_repr_run" title="Permalink to this definition">¶</a></dt>
<dd><p>Debugging output of a single SimRun slice.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>run_addr</strong> &#8211; Address of the SimRun.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A string representation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.backward_slice.BackwardSlice.annotated_cfg">
<code class="descname">annotated_cfg</code><span class="sig-paren">(</span><em>start_point=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.backward_slice.BackwardSlice.annotated_cfg" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an AnnotatedCFG based on slicing result.</p>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.backward_slice.BackwardSlice.is_taint_related_to_ip">
<code class="descname">is_taint_related_to_ip</code><span class="sig-paren">(</span><em>simrun_addr</em>, <em>stmt_idx</em>, <em>taint_type</em>, <em>simrun_whitelist=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.backward_slice.BackwardSlice.is_taint_related_to_ip" title="Permalink to this definition">¶</a></dt>
<dd><p>Query in taint graph to check if a specific taint will taint the IP in the future or not.
The taint is specified with the tuple (simrun_addr, stmt_idx, taint_type).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>simrun_addr</strong> &#8211; Address of the SimRun.</li>
<li><strong>stmt_idx</strong> &#8211; Statement ID.</li>
<li><strong>taint_type</strong> &#8211; Type of the taint, might be one of the following: &#8216;reg&#8217;, &#8216;tmp&#8217;, &#8216;mem&#8217;.</li>
<li><strong>simrun_whitelist</strong> &#8211; A list of SimRun addresses that are whitelisted, i.e. the tainted exit will be
ignored if it is in those SimRuns.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">True/False</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.backward_slice.BackwardSlice.is_taint_impacting_stack_pointers">
<code class="descname">is_taint_impacting_stack_pointers</code><span class="sig-paren">(</span><em>simrun_addr</em>, <em>stmt_idx</em>, <em>taint_type</em>, <em>simrun_whitelist=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.backward_slice.BackwardSlice.is_taint_impacting_stack_pointers" title="Permalink to this definition">¶</a></dt>
<dd><p>Query in taint graph to check if a specific taint will taint the stack pointer in the future or not.
The taint is specified with the tuple (simrun_addr, stmt_idx, taint_type).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>simrun_addr</strong> &#8211; Address of the SimRun.</li>
<li><strong>stmt_idx</strong> &#8211; Statement ID.</li>
<li><strong>taint_type</strong> &#8211; Type of the taint, might be one of the following: &#8216;reg&#8217;, &#8216;tmp&#8217;, &#8216;mem&#8217;.</li>
<li><strong>simrun_whitelist</strong> &#8211; A list of SimRun addresses that are whitelisted.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">True/False.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.analyses.bindiff"></span><dl class="function">
<dt id="angr.analyses.bindiff.differing_constants">
<code class="descclassname">angr.analyses.bindiff.</code><code class="descname">differing_constants</code><span class="sig-paren">(</span><em>block_a</em>, <em>block_b</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.bindiff.differing_constants" title="Permalink to this definition">¶</a></dt>
<dd><p>Compares two basic blocks and finds all the constants that differ from the first block to the second.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>block_a</strong> &#8211; The first block to compare.</li>
<li><strong>block_b</strong> &#8211; The second block to compare.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Returns a list of differing constants in the form of ConstantChange, which has the offset in the
block and the respective constants.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="angr.analyses.bindiff.FunctionDiff">
<em class="property">class </em><code class="descclassname">angr.analyses.bindiff.</code><code class="descname">FunctionDiff</code><span class="sig-paren">(</span><em>function_a</em>, <em>function_b</em>, <em>bindiff=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.bindiff.FunctionDiff" title="Permalink to this definition">¶</a></dt>
<dd><p>This class computes the a diff between two functions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>function_a</strong> &#8211; The first angr Function object to diff.</li>
<li><strong>function_b</strong> &#8211; The second angr Function object.</li>
<li><strong>bindiff</strong> &#8211; An optional Bindiff object. Used for some extra normalization during basic block comparison.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="angr.analyses.bindiff.FunctionDiff.probably_identical">
<code class="descname">probably_identical</code><a class="headerlink" href="#angr.analyses.bindiff.FunctionDiff.probably_identical" title="Permalink to this definition">¶</a></dt>
<dd><p><em>returns</em> &#8211; Whether or not these two functions are identical.</p>
</dd></dl>

<dl class="attribute">
<dt id="angr.analyses.bindiff.FunctionDiff.identical_blocks">
<code class="descname">identical_blocks</code><a class="headerlink" href="#angr.analyses.bindiff.FunctionDiff.identical_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p><em>returns</em> &#8211; A list of block matches which appear to be identical</p>
</dd></dl>

<dl class="attribute">
<dt id="angr.analyses.bindiff.FunctionDiff.differing_blocks">
<code class="descname">differing_blocks</code><a class="headerlink" href="#angr.analyses.bindiff.FunctionDiff.differing_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p><em>returns</em> &#8211; A list of block matches which appear to differ</p>
</dd></dl>

<dl class="attribute">
<dt id="angr.analyses.bindiff.FunctionDiff.blocks_with_differing_constants">
<code class="descname">blocks_with_differing_constants</code><a class="headerlink" href="#angr.analyses.bindiff.FunctionDiff.blocks_with_differing_constants" title="Permalink to this definition">¶</a></dt>
<dd><p><em>return</em> &#8211; A list of block matches which appear to differ</p>
</dd></dl>

<dl class="staticmethod">
<dt id="angr.analyses.bindiff.FunctionDiff.get_normalized_block">
<em class="property">static </em><code class="descname">get_normalized_block</code><span class="sig-paren">(</span><em>addr</em>, <em>function</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.bindiff.FunctionDiff.get_normalized_block" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>addr</strong> &#8211; Where to start the normalized block.</li>
<li><strong>function</strong> &#8211; A function containing the block address.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A normalized basic block.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.bindiff.FunctionDiff.block_similarity">
<code class="descname">block_similarity</code><span class="sig-paren">(</span><em>block_a</em>, <em>block_b</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.bindiff.FunctionDiff.block_similarity" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>block_a</strong> &#8211; The first block address.</li>
<li><strong>block_b</strong> &#8211; The second block address.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The similarity of the basic blocks, normalized for the base address of the block and function
call addresses.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.bindiff.FunctionDiff.blocks_probably_identical">
<code class="descname">blocks_probably_identical</code><span class="sig-paren">(</span><em>block_a</em>, <em>block_b</em>, <em>check_constants=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.bindiff.FunctionDiff.blocks_probably_identical" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>block_a</strong> &#8211; The first block address.</li>
<li><strong>block_b</strong> &#8211; The second block address.</li>
<li><strong>check_constants</strong> &#8211; Whether or not to require matching constants in blocks.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Whether or not the blocks appear to be identical.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="angr.analyses.bindiff.BinDiff">
<em class="property">class </em><code class="descclassname">angr.analyses.bindiff.</code><code class="descname">BinDiff</code><span class="sig-paren">(</span><em>other_project</em>, <em>enable_advanced_backward_slicing=False</em>, <em>cfg_a=None</em>, <em>cfg_b=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.bindiff.BinDiff" title="Permalink to this definition">¶</a></dt>
<dd><p>This class computes the a diff between two binaries represented by angr Projects</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other_project</strong> &#8211; The second project to diff</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="angr.analyses.bindiff.BinDiff.functions_probably_identical">
<code class="descname">functions_probably_identical</code><span class="sig-paren">(</span><em>func_a_addr</em>, <em>func_b_addr</em>, <em>check_consts=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.bindiff.BinDiff.functions_probably_identical" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two functions and return True if they appear identical.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>func_a_addr</strong> &#8211; The address of the first function (in the first binary).</li>
<li><strong>func_b_addr</strong> &#8211; The address of the second function (in the second binary).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Whether or not the functions appear to be identical.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="angr.analyses.bindiff.BinDiff.identical_functions">
<code class="descname">identical_functions</code><a class="headerlink" href="#angr.analyses.bindiff.BinDiff.identical_functions" title="Permalink to this definition">¶</a></dt>
<dd><p><em>returns</em> &#8211; A list of function matches that appear to be identical</p>
</dd></dl>

<dl class="attribute">
<dt id="angr.analyses.bindiff.BinDiff.differing_functions">
<code class="descname">differing_functions</code><a class="headerlink" href="#angr.analyses.bindiff.BinDiff.differing_functions" title="Permalink to this definition">¶</a></dt>
<dd><p><em>returns</em> &#8211; A list of function matches that appear to differ</p>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.bindiff.BinDiff.differing_functions_with_consts">
<code class="descname">differing_functions_with_consts</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.bindiff.BinDiff.differing_functions_with_consts" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A list of function matches that appear to differ including just by constants</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="angr.analyses.bindiff.BinDiff.differing_blocks">
<code class="descname">differing_blocks</code><a class="headerlink" href="#angr.analyses.bindiff.BinDiff.differing_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p><em>returns</em> &#8211; A list of block matches that appear to differ</p>
</dd></dl>

<dl class="attribute">
<dt id="angr.analyses.bindiff.BinDiff.identical_blocks">
<code class="descname">identical_blocks</code><a class="headerlink" href="#angr.analyses.bindiff.BinDiff.identical_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>return A list of all block matches that appear to be identical</p>
</dd></dl>

<dl class="attribute">
<dt id="angr.analyses.bindiff.BinDiff.blocks_with_differing_constants">
<code class="descname">blocks_with_differing_constants</code><a class="headerlink" href="#angr.analyses.bindiff.BinDiff.blocks_with_differing_constants" title="Permalink to this definition">¶</a></dt>
<dd><p><em>return</em> &#8211; A dict of block matches with differing constants to the tuple of constants</p>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.bindiff.BinDiff.get_function_diff">
<code class="descname">get_function_diff</code><span class="sig-paren">(</span><em>function_addr_a</em>, <em>function_addr_b</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.bindiff.BinDiff.get_function_diff" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>function_addr_a</strong> &#8211; The address of the first function (in the first binary)</li>
<li><strong>function_addr_b</strong> &#8211; The address of the second function (in the second binary)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the FunctionDiff of the two functions</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.analyses.boyscout"></span><dl class="class">
<dt id="angr.analyses.boyscout.BoyScout">
<em class="property">class </em><code class="descclassname">angr.analyses.boyscout.</code><code class="descname">BoyScout</code><span class="sig-paren">(</span><em>cookiesize=1</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.boyscout.BoyScout" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to determine the architecture and endieness of a binary blob</p>
</dd></dl>

<span class="target" id="module-angr.analyses.cdg"></span><dl class="class">
<dt id="angr.analyses.cdg.TemporaryNode">
<em class="property">class </em><code class="descclassname">angr.analyses.cdg.</code><code class="descname">TemporaryNode</code><span class="sig-paren">(</span><em>label</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cdg.TemporaryNode" title="Permalink to this definition">¶</a></dt>
<dd><p>A temporary node.</p>
<p>Used as the start node and end node in post-dominator tree generation. Also used in some test cases.</p>
</dd></dl>

<dl class="class">
<dt id="angr.analyses.cdg.ContainerNode">
<em class="property">class </em><code class="descclassname">angr.analyses.cdg.</code><code class="descname">ContainerNode</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cdg.ContainerNode" title="Permalink to this definition">¶</a></dt>
<dd><p>A container node.</p>
<p>Only used in post-dominator tree generation. We did this so we can set the index property without modifying the
original object.</p>
</dd></dl>

<dl class="class">
<dt id="angr.analyses.cdg.CDG">
<em class="property">class </em><code class="descclassname">angr.analyses.cdg.</code><code class="descname">CDG</code><span class="sig-paren">(</span><em>cfg</em>, <em>start=None</em>, <em>no_construct=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cdg.CDG" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements a control dependence graph.</p>
<p>Constructor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cfg</strong> &#8211; The control flow graph upon which this control dependence graph will build</li>
<li><strong>start</strong> &#8211; The starting point to begin constructing the control dependence graph</li>
<li><strong>no_construct</strong> &#8211; Skip the construction step. Only used in unit-testing.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="angr.analyses.cdg.CDG.get_post_dominators">
<code class="descname">get_post_dominators</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cdg.CDG.get_post_dominators" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the post-dom tree</p>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cdg.CDG.get_dependants">
<code class="descname">get_dependants</code><span class="sig-paren">(</span><em>run</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cdg.CDG.get_dependants" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of nodes that are control dependent on the given node in the control dependence graph</p>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cdg.CDG.get_guardians">
<code class="descname">get_guardians</code><span class="sig-paren">(</span><em>run</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cdg.CDG.get_guardians" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of nodes on whom the specific node is control dependent in the control dependence graph</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.analyses.cfg.cfg_accurate"></span><dl class="class">
<dt id="angr.analyses.cfg.cfg_accurate.CFGAccurate">
<em class="property">class </em><code class="descclassname">angr.analyses.cfg.cfg_accurate.</code><code class="descname">CFGAccurate</code><span class="sig-paren">(</span><em>context_sensitivity_level=1</em>, <em>start=None</em>, <em>avoid_runs=None</em>, <em>enable_function_hints=False</em>, <em>call_depth=None</em>, <em>call_tracing_filter=None</em>, <em>initial_state=None</em>, <em>starts=None</em>, <em>keep_state=False</em>, <em>enable_advanced_backward_slicing=False</em>, <em>enable_symbolic_back_traversal=False</em>, <em>additional_edges=None</em>, <em>no_construct=False</em>, <em>normalize=False</em>, <em>max_iterations=1</em>, <em>address_whitelist=None</em>, <em>base_graph=None</em>, <em>iropt_level=None</em>, <em>max_steps=None</em>, <em>state_add_options=None</em>, <em>state_remove_options=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_accurate.CFGAccurate" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents a control-flow graph.</p>
<p>All parameters are optional.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>context_sensitivity_level</strong> &#8211; The level of context-sensitivity of this CFG (see documentation for
further details). It ranges from 0 to infinity. Default 1.</li>
<li><strong>avoid_runs</strong> &#8211; A list of runs to avoid.</li>
<li><strong>enable_function_hints</strong> &#8211; Whether to use function hints (constants that might be used as exit
targets) or not.</li>
<li><strong>call_depth</strong> &#8211; How deep in the call stack to trace.</li>
<li><strong>call_tracing_filter</strong> &#8211; Filter to apply on a given path and jumpkind to determine if it
should be skipped when call_depth is reached.</li>
<li><strong>initial_state</strong> &#8211; An initial state to use to begin analysis.</li>
<li><strong>starts</strong> (<em>iterable</em>) &#8211; A collection of starting points to begin analysis. It can contain
the following three different types of entries: an address specified
as an integer, a 2-tuple that includes an integer address and a
jumpkind, or a SimState instance. Unsupported entries in starts will
lead to an AngrCFGError being raised.</li>
<li><strong>keep_state</strong> &#8211; Whether to keep the SimStates for each CFGNode.</li>
<li><strong>enable_advanced_backward_slicing</strong> &#8211; Whether to enable an intensive technique for resolving direct jumps</li>
<li><strong>enable_symbolic_back_traversal</strong> &#8211; Whether to enable an intensive technique for resolving indirect jumps</li>
<li><strong>additional_edges</strong> &#8211; A dict mapping addresses of basic blocks to addresses of
successors to manually include and analyze forward from.</li>
<li><strong>no_construct</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; Skip the construction procedure. Only used in unit-testing.</li>
<li><strong>normalize</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; If the CFG as well as all Function graphs should be normalized or
not.</li>
<li><strong>max_iterations</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The maximum number of iterations that each basic block should be
&#8220;executed&#8221;. 1 by default. Larger numbers of iterations are usually
required for complex analyses like loop analysis.</li>
<li><strong>address_whitelist</strong> (<em>iterable</em>) &#8211; A list of allowed addresses. Any basic blocks outside of this
collection of addresses will be ignored.</li>
<li><strong>base_graph</strong> (<em>networkx.DiGraph</em>) &#8211; A basic control flow graph to follow. Each node inside this graph
must have the following properties: <cite>addr</cite> and <cite>size</cite>. CFG recovery
will strictly follow nodes and edges shown in the graph, and discard
any contorl flow that does not follow an existing edge in the base
graph. For example, you can pass in a Function local transition
graph as the base graph, and CFGAccurate will traverse nodes and
edges and extract useful information.</li>
<li><strong>iropt_level</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The optimization level of VEX IR (0, 1, 2). The default level will
be used if <cite>iropt_level</cite> is None.</li>
<li><strong>max_steps</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The maximum number of basic blocks to recover forthe longest path
from each start before pausing the recovery procedure.</li>
<li><strong>state_add_options</strong> &#8211; State options that will be added to the initial state.</li>
<li><strong>state_remove_options</strong> &#8211; State options that will be removed from the initial state.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="angr.analyses.cfg.cfg_accurate.CFGAccurate.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_accurate.CFGAccurate.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a copy of the CFG.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A copy of the CFG instance.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">angr.analyses.CFG</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg.cfg_accurate.CFGAccurate.resume">
<code class="descname">resume</code><span class="sig-paren">(</span><em>starts=None</em>, <em>max_steps=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_accurate.CFGAccurate.resume" title="Permalink to this definition">¶</a></dt>
<dd><p>Resume a paused or terminated control flow graph recovery.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>starts</strong> (<em>iterable</em>) &#8211; A collection of new starts to resume from. If <cite>starts</cite> is None, we will resume CFG
recovery from where it was paused before.</li>
<li><strong>max_steps</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The maximum number of blocks on the longest path starting from each start before pausing
the recovery.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg.cfg_accurate.CFGAccurate.remove_cycles">
<code class="descname">remove_cycles</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_accurate.CFGAccurate.remove_cycles" title="Permalink to this definition">¶</a></dt>
<dd><p>Forces graph to become acyclic, removes all loop back edges and edges between overlapped loop headers and their
successors.</p>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg.cfg_accurate.CFGAccurate.downsize">
<code class="descname">downsize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_accurate.CFGAccurate.downsize" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove saved states from all CFGNodes to reduce memory usage.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg.cfg_accurate.CFGAccurate.unroll_loops">
<code class="descname">unroll_loops</code><span class="sig-paren">(</span><em>max_loop_unrolling_times</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_accurate.CFGAccurate.unroll_loops" title="Permalink to this definition">¶</a></dt>
<dd><p>Unroll loops for each function. The resulting CFG may still contain loops due to recursion, function calls, etc.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>max_loop_unrolling_times</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The maximum iterations of unrolling.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg.cfg_accurate.CFGAccurate.force_unroll_loops">
<code class="descname">force_unroll_loops</code><span class="sig-paren">(</span><em>max_loop_unrolling_times</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_accurate.CFGAccurate.force_unroll_loops" title="Permalink to this definition">¶</a></dt>
<dd><p>Unroll loops globally. The resulting CFG does not contain any loop, but this method is slow on large graphs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>max_loop_unrolling_times</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The maximum iterations of unrolling.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg.cfg_accurate.CFGAccurate.immediate_dominators">
<code class="descname">immediate_dominators</code><span class="sig-paren">(</span><em>start</em>, <em>target_graph=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_accurate.CFGAccurate.immediate_dominators" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all immediate dominators of sub graph from given node upwards.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>start</strong> (<em>str</em>) &#8211; id of the node to navigate forwards from.</li>
<li><strong>target_graph</strong> (<em>networkx.classes.digraph.DiGraph</em>) &#8211; graph to analyse, default is self.graph.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">each node of graph as index values, with element as respective node&#8217;s immediate dominator.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">dict</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg.cfg_accurate.CFGAccurate.immediate_postdominators">
<code class="descname">immediate_postdominators</code><span class="sig-paren">(</span><em>end</em>, <em>target_graph=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_accurate.CFGAccurate.immediate_postdominators" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all immediate postdominators of sub graph from given node upwards.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>start</strong> (<em>str</em>) &#8211; id of the node to navigate forwards from.</li>
<li><strong>target_graph</strong> (<em>networkx.classes.digraph.DiGraph</em>) &#8211; graph to analyse, default is self.graph.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">each node of graph as index values, with element as respective node&#8217;s immediate dominator.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">dict</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg.cfg_accurate.CFGAccurate.remove_fakerets">
<code class="descname">remove_fakerets</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_accurate.CFGAccurate.remove_fakerets" title="Permalink to this definition">¶</a></dt>
<dd><p>Get rid of fake returns (i.e., Ijk_FakeRet edges) from this CFG</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg.cfg_accurate.CFGAccurate.get_topological_order">
<code class="descname">get_topological_order</code><span class="sig-paren">(</span><em>cfg_node</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_accurate.CFGAccurate.get_topological_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the topological order of a CFG Node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cfg_node</strong> &#8211; A CFGNode instance.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">An integer representing its order, or None if the CFGNode does not exist in the graph.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg.cfg_accurate.CFGAccurate.get_subgraph">
<code class="descname">get_subgraph</code><span class="sig-paren">(</span><em>starting_node</em>, <em>block_addresses</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_accurate.CFGAccurate.get_subgraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a sub-graph out of a bunch of basic block addresses.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>starting_node</strong> (<a class="reference internal" href="#angr.analyses.cfg.cfg_node.CFGNode" title="angr.analyses.cfg.cfg_node.CFGNode"><em>CFGNode</em></a>) &#8211; The beginning of the subgraph</li>
<li><strong>block_addresses</strong> (<em>iterable</em>) &#8211; A collection of block addresses that should be included in the subgraph if
there is a path between <cite>starting_node</cite> and a CFGNode with the specified
address, and all nodes on the path should also be included in the subgraph.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A new CFG that only contain the specific subgraph.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#angr.analyses.cfg.cfg_accurate.CFGAccurate" title="angr.analyses.cfg.cfg_accurate.CFGAccurate">CFGAccurate</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg.cfg_accurate.CFGAccurate.get_function_subgraph">
<code class="descname">get_function_subgraph</code><span class="sig-paren">(</span><em>start</em>, <em>max_call_depth=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_accurate.CFGAccurate.get_function_subgraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a sub-graph of a certain function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>start</strong> &#8211; The function start. Currently it should be an integer.</li>
<li><strong>max_call_depth</strong> &#8211; Call depth limit. None indicates no limit.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A CFG instance which is a sub-graph of self.graph</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="angr.analyses.cfg.cfg_accurate.CFGAccurate.unresolvables">
<code class="descname">unresolvables</code><a class="headerlink" href="#angr.analyses.cfg.cfg_accurate.CFGAccurate.unresolvables" title="Permalink to this definition">¶</a></dt>
<dd><p>Get those SimRuns that have non-resolvable exits.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A set of SimRuns</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">set</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="angr.analyses.cfg.cfg_accurate.CFGAccurate.deadends">
<code class="descname">deadends</code><a class="headerlink" href="#angr.analyses.cfg.cfg_accurate.CFGAccurate.deadends" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all CFGNodes that has an out-degree of 0</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A list of CFGNode instances</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.analyses.cfg.cfg_base"></span><dl class="class">
<dt id="angr.analyses.cfg.cfg_base.CFGBase">
<em class="property">class </em><code class="descclassname">angr.analyses.cfg.cfg_base.</code><code class="descname">CFGBase</code><span class="sig-paren">(</span><em>sort</em>, <em>context_sensitivity_level</em>, <em>normalize=False</em>, <em>binary=None</em>, <em>force_segment=False</em>, <em>iropt_level=None</em>, <em>base_state=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_base.CFGBase" title="Permalink to this definition">¶</a></dt>
<dd><p>The base class for control flow graphs.</p>
<dl class="attribute">
<dt id="angr.analyses.cfg.cfg_base.CFGBase.functions">
<code class="descname">functions</code><a class="headerlink" href="#angr.analyses.cfg.cfg_base.CFGBase.functions" title="Permalink to this definition">¶</a></dt>
<dd><p>A reference to the FunctionManager in the current knowledge base.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">FunctionManager with all functions</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">angr.knowledge_plugins.FunctionManager</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg.cfg_base.CFGBase.make_copy">
<code class="descname">make_copy</code><span class="sig-paren">(</span><em>copy_to</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_base.CFGBase.make_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy self attributes to the new object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>copy_to</strong> (<a class="reference internal" href="#angr.analyses.cfg.cfg_base.CFGBase" title="angr.analyses.cfg.cfg_base.CFGBase"><em>CFGBase</em></a>) &#8211; The target to copy to.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg.cfg_base.CFGBase.generate_index">
<code class="descname">generate_index</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_base.CFGBase.generate_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an index of all nodes in the graph in order to speed up get_any_node() with anyaddr=True.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg.cfg_base.CFGBase.get_predecessors">
<code class="descname">get_predecessors</code><span class="sig-paren">(</span><em>cfgnode</em>, <em>excluding_fakeret=True</em>, <em>jumpkind=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_base.CFGBase.get_predecessors" title="Permalink to this definition">¶</a></dt>
<dd><p>Get predecessors of a node in the control flow graph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>cfgnode</strong> (<a class="reference internal" href="#angr.analyses.cfg.cfg_node.CFGNode" title="angr.analyses.cfg.cfg_node.CFGNode"><em>CFGNode</em></a>) &#8211; The node.</li>
<li><strong>excluding_fakeret</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; True if you want to exclude all predecessors that is connected to the node
with a fakeret edge.</li>
<li><strong>or None jumpkind</strong> (<em>str</em>) &#8211; Only return predecessors with the specified jumpkind. This argument will be
ignored if set to None.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A list of predecessors</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg.cfg_base.CFGBase.get_successors">
<code class="descname">get_successors</code><span class="sig-paren">(</span><em>basic_block</em>, <em>excluding_fakeret=True</em>, <em>jumpkind=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_base.CFGBase.get_successors" title="Permalink to this definition">¶</a></dt>
<dd><p>Get successors of a node in the control flow graph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>basic_block</strong> (<a class="reference internal" href="#angr.analyses.cfg.cfg_node.CFGNode" title="angr.analyses.cfg.cfg_node.CFGNode"><em>CFGNode</em></a>) &#8211; The node.</li>
<li><strong>excluding_fakeret</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; True if you want to exclude all successors that is connected to the node
with a fakeret edge.</li>
<li><strong>or None jumpkind</strong> (<em>str</em>) &#8211; Only return successors with the specified jumpkind. This argument will be
ignored if set to None.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A list of successors</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg.cfg_base.CFGBase.get_all_predecessors">
<code class="descname">get_all_predecessors</code><span class="sig-paren">(</span><em>cfgnode</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_base.CFGBase.get_all_predecessors" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all predecessors of a specific node on the control flow graph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cfgnode</strong> (<a class="reference internal" href="#angr.analyses.cfg.cfg_node.CFGNode" title="angr.analyses.cfg.cfg_node.CFGNode"><em>CFGNode</em></a>) &#8211; The CFGNode object</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A list of predecessors in the CFG</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg.cfg_base.CFGBase.get_node">
<code class="descname">get_node</code><span class="sig-paren">(</span><em>block_id</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_base.CFGBase.get_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a single node from node key.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>block_id</strong> (<em>BlockID</em>) &#8211; Block ID of the node.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The CFGNode</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#angr.analyses.cfg.cfg_node.CFGNode" title="angr.analyses.cfg.cfg_node.CFGNode">CFGNode</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg.cfg_base.CFGBase.get_any_node">
<code class="descname">get_any_node</code><span class="sig-paren">(</span><em>addr</em>, <em>is_syscall=None</em>, <em>anyaddr=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_base.CFGBase.get_any_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an arbitrary CFGNode (without considering their contexts) from our graph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>addr</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; Address of the beginning of the basic block. Set anyaddr to True to support arbitrary
address.</li>
<li><strong>is_syscall</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; Whether you want to get the syscall node or any other node. This is due to the fact that
syscall SimProcedures have the same address as the targer it returns to.
None means get either, True means get a syscall node, False means get something that isn&#8217;t
a syscall node.</li>
<li><strong>anyaddr</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; If anyaddr is True, then addr doesn&#8217;t have to be the beginning address of a basic
block. By default the entire graph.nodes() will be iterated, and the first node
containing the specific address is returned, which is slow. If you need to do many such
queries, you may first call <cite>generate_index()</cite> to create some indices that may speed up the
query.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A CFGNode if there is any that satisfies given conditions, or None otherwise</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg.cfg_base.CFGBase.irsb_from_node">
<code class="descname">irsb_from_node</code><span class="sig-paren">(</span><em>cfg_node</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_base.CFGBase.irsb_from_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an IRSB from a CFGNode object.</p>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg.cfg_base.CFGBase.get_any_irsb">
<code class="descname">get_any_irsb</code><span class="sig-paren">(</span><em>addr</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_base.CFGBase.get_any_irsb" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an IRSB of a certain address. If there are many IRSBs with the same address in CFG, return an arbitrary
one.
You should never assume this method returns a specific IRSB.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>addr</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; Address of the IRSB to get.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">An arbitrary IRSB located at <cite>addr</cite>.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="pyvex.html#pyvex.block.IRSB" title="pyvex.block.IRSB">IRSB</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg.cfg_base.CFGBase.get_all_nodes">
<code class="descname">get_all_nodes</code><span class="sig-paren">(</span><em>addr</em>, <em>is_syscall=None</em>, <em>anyaddr=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_base.CFGBase.get_all_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all CFGNodes whose address is the specified one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>addr</strong> &#8211; Address of the node</li>
<li><strong>is_syscall</strong> &#8211; True returns the syscall node, False returns the normal CFGNode, None returns both</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">all CFGNodes</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg.cfg_base.CFGBase.nodes">
<code class="descname">nodes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_base.CFGBase.nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>An iterator of all nodes in the graph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The iterator.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">iterator</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg.cfg_base.CFGBase.get_all_irsbs">
<code class="descname">get_all_irsbs</code><span class="sig-paren">(</span><em>addr</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_base.CFGBase.get_all_irsbs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns all IRSBs of a certain address, without considering contexts.</p>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg.cfg_base.CFGBase.get_branching_nodes">
<code class="descname">get_branching_nodes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_base.CFGBase.get_branching_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns all nodes that has an out degree &gt;= 2</p>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg.cfg_base.CFGBase.get_exit_stmt_idx">
<code class="descname">get_exit_stmt_idx</code><span class="sig-paren">(</span><em>src_block</em>, <em>dst_block</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_base.CFGBase.get_exit_stmt_idx" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the corresponding exit statement ID for control flow to reach destination block from source block. The exit
statement ID was put on the edge when creating the CFG.
Note that there must be a direct edge between the two blocks, otherwise an exception will be raised.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The exit statement ID</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg.cfg_base.CFGBase.normalize">
<code class="descname">normalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_base.CFGBase.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalize the CFG, making sure that there are no overlapping basic blocks.</p>
<p>Note that this method will not alter transition graphs of each function in self.kb.functions. You may call
normalize() on each Function object to normalize their transition graphs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg.cfg_base.CFGBase.remove_function_alignments">
<code class="descname">remove_function_alignments</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_base.CFGBase.remove_function_alignments" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all function alignments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg.cfg_base.CFGBase.make_functions">
<code class="descname">make_functions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_base.CFGBase.make_functions" title="Permalink to this definition">¶</a></dt>
<dd><p>Revisit the entire control flow graph, create Function instances accordingly, and correctly put blocks into
each function.</p>
<p>Although Function objects are crated during the CFG recovery, they are neither sound nor accurate. With a
pre-constructed CFG, this method rebuilds all functions bearing the following rules:</p>
<blockquote>
<div><ul class="simple">
<li>A block may only belong to one function.</li>
<li>Small functions lying inside the startpoint and the endpoint of another function will be merged with the
other function</li>
<li>Tail call optimizations are detected.</li>
<li>PLT stubs are aligned by 16.</li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.analyses.cfg.cfg_fast"></span><dl class="class">
<dt id="angr.analyses.cfg.cfg_fast.Segment">
<em class="property">class </em><code class="descclassname">angr.analyses.cfg.cfg_fast.</code><code class="descname">Segment</code><span class="sig-paren">(</span><em>start</em>, <em>end</em>, <em>sort</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_fast.Segment" title="Permalink to this definition">¶</a></dt>
<dd><p>Representing a memory block. This is not the &#8220;Segment&#8221; in ELF memory model</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>start</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; Start address.</li>
<li><strong>end</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; End address.</li>
<li><strong>sort</strong> (<em>str</em>) &#8211; Type of the segment, can be code, data, etc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="angr.analyses.cfg.cfg_fast.Segment.size">
<code class="descname">size</code><a class="headerlink" href="#angr.analyses.cfg.cfg_fast.Segment.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the size of the Segment.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Size of the Segment.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int">int</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg.cfg_fast.Segment.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_fast.Segment.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a copy of the Segment.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A copy of the Segment instance.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">angr.analyses.cfg_fast.Segment</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="angr.analyses.cfg.cfg_fast.SegmentList">
<em class="property">class </em><code class="descclassname">angr.analyses.cfg.cfg_fast.</code><code class="descname">SegmentList</code><a class="headerlink" href="#angr.analyses.cfg.cfg_fast.SegmentList" title="Permalink to this definition">¶</a></dt>
<dd><p>SegmentList describes a series of segmented memory blocks. You may query whether an address belongs to any of the
blocks or not, and obtain the exact block(segment) that the address belongs to.</p>
<dl class="method">
<dt id="angr.analyses.cfg.cfg_fast.SegmentList.next_free_pos">
<code class="descname">next_free_pos</code><span class="sig-paren">(</span><em>address</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_fast.SegmentList.next_free_pos" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the next free position with respect to an address, including that address itself</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>address</strong> &#8211; The address to begin the search with (including itself)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The next free position</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg.cfg_fast.SegmentList.is_occupied">
<code class="descname">is_occupied</code><span class="sig-paren">(</span><em>address</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_fast.SegmentList.is_occupied" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if an address belongs to any segment</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>address</strong> &#8211; The address to check</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if this address belongs to a segment, False otherwise</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg.cfg_fast.SegmentList.occupied_by_sort">
<code class="descname">occupied_by_sort</code><span class="sig-paren">(</span><em>address</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_fast.SegmentList.occupied_by_sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if an address belongs to any segment, and if yes, returns the sort of the segment</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>address</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The address to check</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Sort of the segment that occupies this address</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg.cfg_fast.SegmentList.occupy">
<code class="descname">occupy</code><span class="sig-paren">(</span><em>address</em>, <em>size</em>, <em>sort</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_fast.SegmentList.occupy" title="Permalink to this definition">¶</a></dt>
<dd><p>Include a block, specified by (address, size), in this segment list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>address</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The starting address of the block.</li>
<li><strong>size</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; Size of the block.</li>
<li><strong>sort</strong> (<em>str</em>) &#8211; Type of the block.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg.cfg_fast.SegmentList.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_fast.SegmentList.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a copy of the SegmentList.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A copy of the SegmentList instance.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">angr.analyses.cfg_fast.SegmentList</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="angr.analyses.cfg.cfg_fast.SegmentList.occupied_size">
<code class="descname">occupied_size</code><a class="headerlink" href="#angr.analyses.cfg.cfg_fast.SegmentList.occupied_size" title="Permalink to this definition">¶</a></dt>
<dd><p>The sum of sizes of all blocks</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">An integer</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="angr.analyses.cfg.cfg_fast.SegmentList.has_blocks">
<code class="descname">has_blocks</code><a class="headerlink" href="#angr.analyses.cfg.cfg_fast.SegmentList.has_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns if this segment list has any block or not. !is_empty</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">True if it&#8217;s not empty, False otherwise</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="angr.analyses.cfg.cfg_fast.FunctionReturn">
<em class="property">class </em><code class="descclassname">angr.analyses.cfg.cfg_fast.</code><code class="descname">FunctionReturn</code><span class="sig-paren">(</span><em>callee_func_addr</em>, <em>caller_func_addr</em>, <em>call_site_addr</em>, <em>return_to</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_fast.FunctionReturn" title="Permalink to this definition">¶</a></dt>
<dd><p>FunctionReturn describes a function call in a specific location and its return location. Hashable and equatable</p>
</dd></dl>

<dl class="class">
<dt id="angr.analyses.cfg.cfg_fast.MemoryData">
<em class="property">class </em><code class="descclassname">angr.analyses.cfg.cfg_fast.</code><code class="descname">MemoryData</code><span class="sig-paren">(</span><em>address</em>, <em>size</em>, <em>sort</em>, <em>irsb</em>, <em>irsb_addr</em>, <em>stmt</em>, <em>stmt_idx</em>, <em>pointer_addr=None</em>, <em>max_size=None</em>, <em>insn_addr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_fast.MemoryData" title="Permalink to this definition">¶</a></dt>
<dd><p>MemoryData describes the syntactic contents of single address of memory along with a set of references to this
address (when not from previous instruction).</p>
<dl class="method">
<dt id="angr.analyses.cfg.cfg_fast.MemoryData.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_fast.MemoryData.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a copy of the MemoryData.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A copy of the MemoryData instance.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">angr.analyses.cfg_fast.MemoryData</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.cfg.cfg_fast.MemoryData.add_ref">
<code class="descname">add_ref</code><span class="sig-paren">(</span><em>irsb_addr</em>, <em>stmt_idx</em>, <em>insn_addr</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_fast.MemoryData.add_ref" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a reference from code to this memory data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>irsb_addr</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; Address of the basic block.</li>
<li><strong>stmt_idx</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; ID of the statement referencing this data entry.</li>
<li><strong>insn_addr</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; Address of the instruction referencing this data entry.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="angr.analyses.cfg.cfg_fast.CFGJob">
<em class="property">class </em><code class="descclassname">angr.analyses.cfg.cfg_fast.</code><code class="descname">CFGJob</code><span class="sig-paren">(</span><em>addr</em>, <em>func_addr</em>, <em>jumpkind</em>, <em>ret_target=None</em>, <em>last_addr=None</em>, <em>src_node=None</em>, <em>src_ins_addr=None</em>, <em>src_stmt_idx=None</em>, <em>returning_source=None</em>, <em>syscall=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_fast.CFGJob" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a job to work on during the CFG recovery</p>
</dd></dl>

<dl class="class">
<dt id="angr.analyses.cfg.cfg_fast.CFGFast">
<em class="property">class </em><code class="descclassname">angr.analyses.cfg.cfg_fast.</code><code class="descname">CFGFast</code><span class="sig-paren">(</span><em>binary=None</em>, <em>regions=None</em>, <em>pickle_intermediate_results=False</em>, <em>symbols=True</em>, <em>function_prologues=True</em>, <em>resolve_indirect_jumps=True</em>, <em>force_segment=False</em>, <em>force_complete_scan=True</em>, <em>indirect_jump_target_limit=100000</em>, <em>collect_data_references=False</em>, <em>extra_cross_references=False</em>, <em>normalize=False</em>, <em>start_at_entry=True</em>, <em>function_starts=None</em>, <em>extra_memory_regions=None</em>, <em>data_type_guessing_handlers=None</em>, <em>arch_options=None</em>, <em>indirect_jump_resolvers=None</em>, <em>base_state=None</em>, <em>exclude_sparse_regions=True</em>, <em>skip_specific_regions=True</em>, <em>heuristic_plt_resolving=None</em>, <em>start=None</em>, <em>end=None</em>, <em>**extra_arch_options</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_fast.CFGFast" title="Permalink to this definition">¶</a></dt>
<dd><p>We find functions inside the given binary, and build a control-flow graph in very fast manners: instead of
simulating program executions, keeping track of states, and performing expensive data-flow analysis, CFGFast will
only perform light-weight analyses combined with some heuristics, and with some strong assumptions.</p>
<p>In order to identify as many functions as possible, and as accurate as possible, the following operation sequence
is followed:</p>
<p># Active scanning</p>
<blockquote>
<div><ul class="simple">
<li><dl class="first docutils">
<dt>If the binary has &#8220;function symbols&#8221; (TODO: this term is not accurate enough), they are starting points of</dt>
<dd>the code scanning</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>If the binary does not have any &#8220;function symbol&#8221;, we will first perform a function prologue scanning on the</dt>
<dd>entire binary, and start from those places that look like function beginnings</dd>
</dl>
</li>
<li>Otherwise, the binary&#8217;s entry point will be the starting point for scanning</li>
</ul>
</div></blockquote>
<p># Passive scanning</p>
<blockquote>
<div><ul class="simple">
<li>After all active scans are done, we will go through the whole image and scan all code pieces</li>
</ul>
</div></blockquote>
<p>Due to the nature of those techniques that are used here, a base address is often not required to use this analysis
routine. However, with a correct base address, CFG recovery will almost always yield a much better result. A custom
analysis, called GirlScout, is specifically made to recover the base address of a binary blob. After the base
address is determined, you may want to reload the binary with the new base address by creating a new Project object,
and then re-recover the CFG.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>binary</strong> &#8211; The binary to recover CFG on. By default the main binary is used.</li>
<li><strong>regions</strong> (<em>iterable</em>) &#8211; A list of tuples in the form of (start address, end address) describing memory
regions that the CFG should cover.</li>
<li><strong>pickle_intermediate_results</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; If we want to store the intermediate results or not.</li>
<li><strong>symbols</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; Get function beginnings from symbols in the binary.</li>
<li><strong>function_prologues</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; Scan the binary for function prologues, and use those positions as function
beginnings</li>
<li><strong>resolve_indirect_jumps</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; Try to resolve indirect jumps. This is necessary to resolve jump targets
from jump tables, etc.</li>
<li><strong>force_segment</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; Force CFGFast to rely on binary segments instead of sections.</li>
<li><strong>force_complete_scan</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; Perform a complete scan on the binary and maximize the number of identified
code blocks.</li>
<li><strong>collect_data_references</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; If CFGFast should collect data references from individual basic blocks or
not.</li>
<li><strong>extra_cross_references</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; True if we should collect data references for all places in the program
that access each memory data entry, which requires more memory, and is
noticeably slower. Setting it to False means each memory data entry has at
most one reference (which is the initial one).</li>
<li><strong>normalize</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; Normalize the CFG as well as all function graphs after CFG recovery.</li>
<li><strong>start_at_entry</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; Begin CFG recovery at the entry point of this project. Setting it to False
prevents CFGFast from viewing the entry point as one of the starting points of
code scanning.</li>
<li><strong>function_starts</strong> (<em>list</em>) &#8211; A list of extra function starting points. CFGFast will try to resume scanning
from each address in the list.</li>
<li><strong>extra_memory_regions</strong> (<em>list</em>) &#8211; A list of 2-tuple (start-address, end-address) that shows extra memory
regions. Integers falling inside will be considered as pointers.</li>
<li><strong>indirect_jump_resolvers</strong> (<em>list</em>) &#8211; A custom list of indirect jump resolvers. If this list is None or empty,
default indirect jump resolvers specific to this architecture and binary
types will be loaded.</li>
<li><strong>base_state</strong> &#8211; A state to use as a backer for all memory loads</li>
<li><strong>start</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; (Deprecated) The beginning address of CFG recovery.</li>
<li><strong>end</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; (Deprecated) The end address of CFG recovery.</li>
<li><strong>arch_options</strong> (<em>CFGArchOptions</em>) &#8211; Architecture-specific options.</li>
<li><strong>extra_arch_options</strong> (<em>dict</em>) &#8211; Any key-value pair in kwargs will be seen as an arch-specific option and will
be used to set the option value in self._arch_options.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Extra parameters that angr.Analysis takes:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>progress_callback</strong> &#8211; Specify a callback function to get the progress during CFG recovery.</li>
<li><strong>show_progressbar</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; Should CFGFast show a progressbar during CFG recovery or not.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="angr.analyses.cfg.cfg_fast.CFGFast.generate_code_cover">
<code class="descname">generate_code_cover</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_fast.CFGFast.generate_code_cover" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a list of all recovered basic blocks.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.analyses.cfg.cfg_node"></span><dl class="class">
<dt id="angr.analyses.cfg.cfg_node.CFGNodeCreationFailure">
<em class="property">class </em><code class="descclassname">angr.analyses.cfg.cfg_node.</code><code class="descname">CFGNodeCreationFailure</code><span class="sig-paren">(</span><em>exc_info=None</em>, <em>to_copy=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_node.CFGNodeCreationFailure" title="Permalink to this definition">¶</a></dt>
<dd><p>This class contains additional information for whenever creating a CFGNode failed. It includes a full traceback
and the exception messages.</p>
</dd></dl>

<dl class="class">
<dt id="angr.analyses.cfg.cfg_node.CFGNode">
<em class="property">class </em><code class="descclassname">angr.analyses.cfg.cfg_node.</code><code class="descname">CFGNode</code><span class="sig-paren">(</span><em>addr</em>, <em>size</em>, <em>cfg</em>, <em>callstack=None</em>, <em>input_state=None</em>, <em>simprocedure_name=None</em>, <em>syscall_name=None</em>, <em>looping_times=0</em>, <em>no_ret=False</em>, <em>is_syscall=False</em>, <em>syscall=None</em>, <em>function_address=None</em>, <em>final_states=None</em>, <em>block_id=None</em>, <em>irsb=None</em>, <em>instruction_addrs=None</em>, <em>depth=None</em>, <em>callstack_key=None</em>, <em>creation_failure_info=None</em>, <em>thumb=False</em>, <em>byte_string=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_node.CFGNode" title="Permalink to this definition">¶</a></dt>
<dd><p>This class stands for each single node in CFG.</p>
<p>Note: simprocedure_name is not used to recreate the SimProcedure object. It&#8217;s only there for better
__repr__.</p>
<dl class="method">
<dt id="angr.analyses.cfg.cfg_node.CFGNode.downsize">
<code class="descname">downsize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.cfg.cfg_node.CFGNode.downsize" title="Permalink to this definition">¶</a></dt>
<dd><p>Drop saved states.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.analyses.code_location"></span><dl class="class">
<dt id="angr.analyses.code_location.CodeLocation">
<em class="property">class </em><code class="descclassname">angr.analyses.code_location.</code><code class="descname">CodeLocation</code><span class="sig-paren">(</span><em>block_addr</em>, <em>stmt_idx</em>, <em>sim_procedure=None</em>, <em>ins_addr=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.code_location.CodeLocation" title="Permalink to this definition">¶</a></dt>
<dd><p>Stands for a specific program point by specifying basic block address and statement ID (for IRSBs), or SimProcedure
name (for SimProcedures).</p>
<p>Constructor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>block_addr</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; Address of the block</li>
<li><strong>stmt_idx</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; Statement ID. None for SimProcedures</li>
<li><strong>sim_procedure</strong> (<em>class</em>) &#8211; The corresponding SimProcedure class.</li>
<li><strong>ins_addr</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The instruction address. Optional.</li>
<li><strong>kwargs</strong> &#8211; Optional arguments, will be stored, but not used in __eq__ or __hash__.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<span class="target" id="module-angr.analyses.datagraph_meta"></span><span class="target" id="module-angr.analyses.ddg"></span><dl class="class">
<dt id="angr.analyses.ddg.AST">
<em class="property">class </em><code class="descclassname">angr.analyses.ddg.</code><code class="descname">AST</code><span class="sig-paren">(</span><em>op</em>, <em>*operands</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.ddg.AST" title="Permalink to this definition">¶</a></dt>
<dd><p>A mini implementation for AST</p>
</dd></dl>

<dl class="class">
<dt id="angr.analyses.ddg.ProgramVariable">
<em class="property">class </em><code class="descclassname">angr.analyses.ddg.</code><code class="descname">ProgramVariable</code><span class="sig-paren">(</span><em>variable</em>, <em>location</em>, <em>initial=False</em>, <em>arch=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.ddg.ProgramVariable" title="Permalink to this definition">¶</a></dt>
<dd><p>Describes a variable in the program at a specific location.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>variable</strong> (<em>SimVariable</em>) &#8211; The variable.</li>
<li><strong>location</strong> (<a class="reference internal" href="#angr.analyses.code_location.CodeLocation" title="angr.analyses.code_location.CodeLocation"><em>CodeLocation</em></a>) &#8211; Location of the variable.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="angr.analyses.ddg.LiveDefinitions">
<em class="property">class </em><code class="descclassname">angr.analyses.ddg.</code><code class="descname">LiveDefinitions</code><a class="headerlink" href="#angr.analyses.ddg.LiveDefinitions" title="Permalink to this definition">¶</a></dt>
<dd><p>A collection of live definitions with some handy interfaces for definition killing and lookups.</p>
<p>Constructor.</p>
<dl class="method">
<dt id="angr.analyses.ddg.LiveDefinitions.branch">
<code class="descname">branch</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.ddg.LiveDefinitions.branch" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a branch of the current live definition collection.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A new LiveDefinition instance.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#angr.analyses.ddg.LiveDefinitions" title="angr.analyses.ddg.LiveDefinitions">LiveDefinitions</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.ddg.LiveDefinitions.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.ddg.LiveDefinitions.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a hard copy of <cite>self</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A new LiveDefinition instance.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#angr.analyses.ddg.LiveDefinitions" title="angr.analyses.ddg.LiveDefinitions">LiveDefinitions</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.ddg.LiveDefinitions.add_def">
<code class="descname">add_def</code><span class="sig-paren">(</span><em>variable</em>, <em>location</em>, <em>size_threshold=32</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.ddg.LiveDefinitions.add_def" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a new definition of variable.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> (<em>SimVariable</em>) &#8211; The variable being defined.</li>
<li><strong>location</strong> (<a class="reference internal" href="#angr.analyses.code_location.CodeLocation" title="angr.analyses.code_location.CodeLocation"><em>CodeLocation</em></a>) &#8211; Location of the varaible being defined.</li>
<li><strong>size_threshold</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The maximum bytes to consider for the variable.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">True if the definition was new, False otherwise</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool">bool</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.ddg.LiveDefinitions.add_defs">
<code class="descname">add_defs</code><span class="sig-paren">(</span><em>variable</em>, <em>locations</em>, <em>size_threshold=32</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.ddg.LiveDefinitions.add_defs" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a collection of new definitions of a variable.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> (<em>SimVariable</em>) &#8211; The variable being defined.</li>
<li><strong>locations</strong> (<em>iterable</em>) &#8211; A collection of locations where the variable was defined.</li>
<li><strong>size_threshold</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The maximum bytes to consider for the variable.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">True if any of the definition was new, False otherwise</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool">bool</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.ddg.LiveDefinitions.kill_def">
<code class="descname">kill_def</code><span class="sig-paren">(</span><em>variable</em>, <em>location</em>, <em>size_threshold=32</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.ddg.LiveDefinitions.kill_def" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a new definition for variable and kill all previous definitions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> (<em>SimVariable</em>) &#8211; The variable to kill.</li>
<li><strong>location</strong> (<a class="reference internal" href="#angr.analyses.code_location.CodeLocation" title="angr.analyses.code_location.CodeLocation"><em>CodeLocation</em></a>) &#8211; The location where this variable is defined.</li>
<li><strong>size_threshold</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The maximum bytes to consider for the variable.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.ddg.LiveDefinitions.lookup_defs">
<code class="descname">lookup_defs</code><span class="sig-paren">(</span><em>variable</em>, <em>size_threshold=32</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.ddg.LiveDefinitions.lookup_defs" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all definitions of the varaible</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> (<em>SimVariable</em>) &#8211; The variable to lookup for.</li>
<li><strong>size_threshold</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The maximum bytes to consider for the variable. For example, if the variable is 100
byte long, only the first <cite>size_threshold</cite> bytes are considered.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A set of code locations where the variable is defined.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">set</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.ddg.LiveDefinitions.iteritems">
<code class="descname">iteritems</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.ddg.LiveDefinitions.iteritems" title="Permalink to this definition">¶</a></dt>
<dd><p>An iterator that returns all live definitions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The iterator.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">iter</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.ddg.LiveDefinitions.itervariables">
<code class="descname">itervariables</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.ddg.LiveDefinitions.itervariables" title="Permalink to this definition">¶</a></dt>
<dd><p>An iterator that returns all live variables.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The iterator.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">iter</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="angr.analyses.ddg.DDGView">
<em class="property">class </em><code class="descclassname">angr.analyses.ddg.</code><code class="descname">DDGView</code><span class="sig-paren">(</span><em>cfg</em>, <em>ddg</em>, <em>simplified=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.ddg.DDGView" title="Permalink to this definition">¶</a></dt>
<dd><p>A view of the data dependence graph.</p>
</dd></dl>

<dl class="class">
<dt id="angr.analyses.ddg.DDG">
<em class="property">class </em><code class="descclassname">angr.analyses.ddg.</code><code class="descname">DDG</code><span class="sig-paren">(</span><em>cfg</em>, <em>start=None</em>, <em>call_depth=None</em>, <em>block_addrs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.ddg.DDG" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a fast data dependence graph directly generated from our CFG analysis result. The only reason for its
existence is the speed. There is zero guarantee for being sound or accurate. You are supposed to use it only when
you want to track the simplest data dependence, and you do not care about soundness or accuracy.</p>
<p>For a better data dependence graph, please consider performing a better static analysis first (like Value-set
Analysis), and then construct a dependence graph on top of the analysis result (for example, the VFG in angr).</p>
<p>Also note that since we are using states from CFG, any improvement in analysis performed on CFG (like a points-to
analysis) will directly benefit the DDG.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cfg</strong> &#8211; Control flow graph. Please make sure each node has an associated <cite>state</cite> with it. You may
want to generate your CFG with <cite>keep_state=True</cite>.</li>
<li><strong>start</strong> &#8211; An address, Specifies where we start the generation of this data dependence graph.</li>
<li><strong>call_depth</strong> &#8211; None or integers. A non-negative integer specifies how deep we would like to track in the
call tree. None disables call_depth limit.</li>
<li><strong>or None block_addrs</strong> (<em>iterable</em>) &#8211; A collection of block addresses that the DDG analysis should be performed
on.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="angr.analyses.ddg.DDG.graph">
<code class="descname">graph</code><a class="headerlink" href="#angr.analyses.ddg.DDG.graph" title="Permalink to this definition">¶</a></dt>
<dd><p><em>returns</em> &#8211; A networkx DiGraph instance representing the dependence relations between statements.
:rtype: networkx.DiGraph</p>
</dd></dl>

<dl class="attribute">
<dt id="angr.analyses.ddg.DDG.data_graph">
<code class="descname">data_graph</code><a class="headerlink" href="#angr.analyses.ddg.DDG.data_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the data dependence graph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A networkx DiGraph instance representing data dependence.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">networkx.DiGraph</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="angr.analyses.ddg.DDG.simplified_data_graph">
<code class="descname">simplified_data_graph</code><a class="headerlink" href="#angr.analyses.ddg.DDG.simplified_data_graph" title="Permalink to this definition">¶</a></dt>
<dd><p><em>return</em></p>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.ddg.DDG.pp">
<code class="descname">pp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.ddg.DDG.pp" title="Permalink to this definition">¶</a></dt>
<dd><p>Pretty printing.</p>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.ddg.DDG.dbg_repr">
<code class="descname">dbg_repr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.ddg.DDG.dbg_repr" title="Permalink to this definition">¶</a></dt>
<dd><p>Representation for debugging.</p>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.ddg.DDG.get_predecessors">
<code class="descname">get_predecessors</code><span class="sig-paren">(</span><em>code_location</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.ddg.DDG.get_predecessors" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns all predecessors of the code location.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>code_location</strong> &#8211; A CodeLocation instance.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A list of all predecessors.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.ddg.DDG.function_dependency_graph">
<code class="descname">function_dependency_graph</code><span class="sig-paren">(</span><em>func</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.ddg.DDG.function_dependency_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dependency graph for the function <cite>func</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>func</strong> &#8211; The Function object in CFG.function_manager.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A networkx.DiGraph instance.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.ddg.DDG.data_sub_graph">
<code class="descname">data_sub_graph</code><span class="sig-paren">(</span><em>pv</em>, <em>simplified=True</em>, <em>killing_edges=False</em>, <em>excluding_types=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.ddg.DDG.data_sub_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a subgraph from the data graph or the simplified data graph that starts from node pv.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>pv</strong> (<a class="reference internal" href="#angr.analyses.ddg.ProgramVariable" title="angr.analyses.ddg.ProgramVariable"><em>ProgramVariable</em></a>) &#8211; The starting point of the subgraph.</li>
<li><strong>simplified</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; When True, the simplified data graph is used, otherwise the data graph is used.</li>
<li><strong>killing_edges</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; Are killing edges included or not.</li>
<li><strong>excluding_types</strong> (<em>iterable</em>) &#8211; Excluding edges whose types are among those excluded types.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A subgraph.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">networkx.MultiDiGraph</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.ddg.DDG.find_definitions">
<code class="descname">find_definitions</code><span class="sig-paren">(</span><em>variable</em>, <em>location=None</em>, <em>simplified_graph=True</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.ddg.DDG.find_definitions" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all definitions of the given variable.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> (<em>SimVariable</em>) &#8211; </li>
<li><strong>simplified_graph</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; True if you just want to search in the simplified graph instead of the normal
graph. Usually the simplified graph suffices for finding definitions of register
or memory variables.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A collection of all variable definitions to the specific variable.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.ddg.DDG.find_consumers">
<code class="descname">find_consumers</code><span class="sig-paren">(</span><em>var_def</em>, <em>simplified_graph=True</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.ddg.DDG.find_consumers" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all consumers to the specified variable definition.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>var_def</strong> (<a class="reference internal" href="#angr.analyses.ddg.ProgramVariable" title="angr.analyses.ddg.ProgramVariable"><em>ProgramVariable</em></a>) &#8211; The variable definition.</li>
<li><strong>simplified_graph</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; True if we want to search in the simplified graph, False otherwise.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A collection of all consumers to the specified variable definition.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.ddg.DDG.find_killers">
<code class="descname">find_killers</code><span class="sig-paren">(</span><em>var_def</em>, <em>simplified_graph=True</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.ddg.DDG.find_killers" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all killers to the specified variable definition.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>var_def</strong> (<a class="reference internal" href="#angr.analyses.ddg.ProgramVariable" title="angr.analyses.ddg.ProgramVariable"><em>ProgramVariable</em></a>) &#8211; The variable definition.</li>
<li><strong>simplified_graph</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; True if we want to search in the simplified graph, False otherwise.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A collection of all killers to the specified variable definition.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.ddg.DDG.find_sources">
<code class="descname">find_sources</code><span class="sig-paren">(</span><em>var_def</em>, <em>simplified_graph=True</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.ddg.DDG.find_sources" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all sources to the specified variable definition.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>var_def</strong> (<a class="reference internal" href="#angr.analyses.ddg.ProgramVariable" title="angr.analyses.ddg.ProgramVariable"><em>ProgramVariable</em></a>) &#8211; The variable definition.</li>
<li><strong>simplified_graph</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; True if we want to search in the simplified graph, False otherwise.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A collection of all sources to the specified variable definition.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.analyses.dfg"></span><span class="target" id="module-angr.analyses.forward_analysis"></span><dl class="class">
<dt id="angr.analyses.forward_analysis.GraphVisitor">
<em class="property">class </em><code class="descclassname">angr.analyses.forward_analysis.</code><code class="descname">GraphVisitor</code><a class="headerlink" href="#angr.analyses.forward_analysis.GraphVisitor" title="Permalink to this definition">¶</a></dt>
<dd><p>A graph visitor takes a node in the graph and returns its successors. Typically it visits a control flow graph, and
returns successors of a CFGNode each time. This is the base class of all graph visitors.</p>
<dl class="method">
<dt id="angr.analyses.forward_analysis.GraphVisitor.startpoints">
<code class="descname">startpoints</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.forward_analysis.GraphVisitor.startpoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all start points to begin the traversal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A list of startpoints that the traversal should begin with.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.forward_analysis.GraphVisitor.successors">
<code class="descname">successors</code><span class="sig-paren">(</span><em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.forward_analysis.GraphVisitor.successors" title="Permalink to this definition">¶</a></dt>
<dd><p>Get successors of a node. The node should be in the graph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>node</strong> &#8211; The node to work with.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A list of successors.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.forward_analysis.GraphVisitor.predecessors">
<code class="descname">predecessors</code><span class="sig-paren">(</span><em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.forward_analysis.GraphVisitor.predecessors" title="Permalink to this definition">¶</a></dt>
<dd><p>Get predecessors of a node. The node should be in the graph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>node</strong> &#8211; The node to work with.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A list of predecessors.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.forward_analysis.GraphVisitor.sort_nodes">
<code class="descname">sort_nodes</code><span class="sig-paren">(</span><em>nodes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.forward_analysis.GraphVisitor.sort_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a list of all nodes sorted in an optimal traversal order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>nodes</strong> (<em>iterable</em>) &#8211; A collection of nodes to sort. If none, all nodes in the graph will be used to sort.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A list of sorted nodes.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.forward_analysis.GraphVisitor.nodes">
<code class="descname">nodes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.forward_analysis.GraphVisitor.nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator of nodes following an optimal traversal order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.forward_analysis.GraphVisitor.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.forward_analysis.GraphVisitor.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the internal node traversal state. Must be called prior to visiting future nodes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.forward_analysis.GraphVisitor.next_node">
<code class="descname">next_node</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.forward_analysis.GraphVisitor.next_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the next node to visit.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A node in the graph.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.forward_analysis.GraphVisitor.all_successors">
<code class="descname">all_successors</code><span class="sig-paren">(</span><em>node</em>, <em>skip_reached_fixedpoint=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.forward_analysis.GraphVisitor.all_successors" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns all successors to the specific node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>node</strong> &#8211; A node in the graph.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A set of nodes that are all successors to the given node.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">set</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.forward_analysis.GraphVisitor.revisit">
<code class="descname">revisit</code><span class="sig-paren">(</span><em>node</em>, <em>include_self=True</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.forward_analysis.GraphVisitor.revisit" title="Permalink to this definition">¶</a></dt>
<dd><p>Revisit a node in the future. As a result, the successors to this node will be revisited as well.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>node</strong> &#8211; The node to revisit in the future.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.forward_analysis.GraphVisitor.reached_fixedpoint">
<code class="descname">reached_fixedpoint</code><span class="sig-paren">(</span><em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.forward_analysis.GraphVisitor.reached_fixedpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark a node as reached fixed-point. This node as well as all its successors will not be visited in the future.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>node</strong> &#8211; The node to mark as reached fixed-point.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="angr.analyses.forward_analysis.JobInfo">
<em class="property">class </em><code class="descclassname">angr.analyses.forward_analysis.</code><code class="descname">JobInfo</code><span class="sig-paren">(</span><em>key</em>, <em>job</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.forward_analysis.JobInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Stores information of each job.</p>
<dl class="attribute">
<dt id="angr.analyses.forward_analysis.JobInfo.job">
<code class="descname">job</code><a class="headerlink" href="#angr.analyses.forward_analysis.JobInfo.job" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the latest available job.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The latest available job.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.forward_analysis.JobInfo.add_job">
<code class="descname">add_job</code><span class="sig-paren">(</span><em>job</em>, <em>merged=False</em>, <em>widened=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.forward_analysis.JobInfo.add_job" title="Permalink to this definition">¶</a></dt>
<dd><p>Appended a new job to this JobInfo node.
:param job: The new job to append.
:param bool merged: Whether it is a merged job or not.
:param bool widened: Whether it is a widened job or not.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="angr.analyses.forward_analysis.ForwardAnalysis">
<em class="property">class </em><code class="descclassname">angr.analyses.forward_analysis.</code><code class="descname">ForwardAnalysis</code><span class="sig-paren">(</span><em>order_jobs=False</em>, <em>allow_merging=False</em>, <em>allow_widening=False</em>, <em>status_callback=None</em>, <em>graph_visitor=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.forward_analysis.ForwardAnalysis" title="Permalink to this definition">¶</a></dt>
<dd><p>This is my very first attempt to build a static forward analysis framework that can serve as the base of multiple
static analyses in angr, including CFG analysis, VFG analysis, DDG, etc.</p>
<p>In short, ForwardAnalysis performs a forward data-flow analysis by traversing a graph, compute on abstract values,
and store results in abstract states. The user can specify what graph to traverse, how a graph should be traversed,
how abstract values and abstract states are defined, etc.</p>
<p>ForwardAnalysis has a few options to toggle, making it suitable to be the base class of several different styles of
forward data-flow analysis implementations.</p>
<p>ForwardAnalysis supports a special mode when no graph is available for traversal (for example, when a CFG is being
initialized and constructed, no other graph can be used). In that case, the graph traversal functionality is
disabled, and the optimal graph traversal order is not guaranteed. The user can provide a job sorting method to
sort the jobs in queue and optimize traversal order.</p>
<p>Feel free to discuss with me (Fish) if you have any suggestions or complaints.</p>
<p>Constructor</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>order_jobs</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; If all jobs should be ordered or not.</li>
<li><strong>allow_merging</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; If job merging is allowed.</li>
<li><strong>allow_widening</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; If job widening is allowed.</li>
<li><strong>graph_visitor</strong> (<a class="reference internal" href="#angr.analyses.forward_analysis.GraphVisitor" title="angr.analyses.forward_analysis.GraphVisitor"><em>GraphVisitor</em></a><em> or </em><em>None</em>) &#8211; A graph visitor to provide successors.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="angr.analyses.forward_analysis.ForwardAnalysis.should_abort">
<code class="descname">should_abort</code><a class="headerlink" href="#angr.analyses.forward_analysis.ForwardAnalysis.should_abort" title="Permalink to this definition">¶</a></dt>
<dd><p>Should the analysis be terminated.
:return: True/False</p>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.forward_analysis.ForwardAnalysis.abort">
<code class="descname">abort</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.forward_analysis.ForwardAnalysis.abort" title="Permalink to this definition">¶</a></dt>
<dd><p>Abort the analysis
:return: None</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.analyses.girlscout"></span><dl class="class">
<dt id="angr.analyses.girlscout.GirlScout">
<em class="property">class </em><code class="descclassname">angr.analyses.girlscout.</code><code class="descname">GirlScout</code><span class="sig-paren">(</span><em>binary=None</em>, <em>start=None</em>, <em>end=None</em>, <em>pickle_intermediate_results=False</em>, <em>perform_full_code_scan=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.girlscout.GirlScout" title="Permalink to this definition">¶</a></dt>
<dd><p>We find functions inside the given binary, try to decide the base address if needed, and build a control-flow
graph on top of that to see if there is an entry or not. Obviously if the binary is not loaded as a blob (not
using Blob as its backend), GirlScout will not try to determine the base address.</p>
<p>It&#8217;s also optional to perform a full code scan of the binary to show where all codes are. By default we don&#8217;t scan
the entire binary since it&#8217;s time consuming.</p>
<p>You probably need a BoyScout to determine the possible architecture and endianess of your binary blob.</p>
<dl class="method">
<dt id="angr.analyses.girlscout.GirlScout.genenare_callmap_sif">
<code class="descname">genenare_callmap_sif</code><span class="sig-paren">(</span><em>filepath</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.girlscout.GirlScout.genenare_callmap_sif" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a sif file from the call map</p>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.girlscout.GirlScout.generate_code_cover">
<code class="descname">generate_code_cover</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.girlscout.GirlScout.generate_code_cover" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a list of all recovered basic blocks.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.analyses.loopfinder"></span><dl class="class">
<dt id="angr.analyses.loopfinder.LoopFinder">
<em class="property">class </em><code class="descclassname">angr.analyses.loopfinder.</code><code class="descname">LoopFinder</code><span class="sig-paren">(</span><em>functions=None</em>, <em>normalize=True</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.loopfinder.LoopFinder" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts all the loops from all the functions in a binary.</p>
</dd></dl>

<span class="target" id="module-angr.analyses.veritesting"></span><dl class="class">
<dt id="angr.analyses.veritesting.CallTracingFilter">
<em class="property">class </em><code class="descclassname">angr.analyses.veritesting.</code><code class="descname">CallTracingFilter</code><span class="sig-paren">(</span><em>project</em>, <em>depth</em>, <em>blacklist=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.veritesting.CallTracingFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter to apply during CFG creation on a given state and jumpkind to determine if it should be skipped at a certain
depth</p>
<dl class="method">
<dt id="angr.analyses.veritesting.CallTracingFilter.filter">
<code class="descname">filter</code><span class="sig-paren">(</span><em>call_target_state</em>, <em>jumpkind</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.veritesting.CallTracingFilter.filter" title="Permalink to this definition">¶</a></dt>
<dd><p>The call will be skipped if it returns True.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>call_target_state</strong> &#8211; The new state of the call target.</li>
<li><strong>jumpkind</strong> &#8211; The Jumpkind of this call.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">True if we want to skip this call, False otherwise.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="angr.analyses.veritesting.Veritesting">
<em class="property">class </em><code class="descclassname">angr.analyses.veritesting.</code><code class="descname">Veritesting</code><span class="sig-paren">(</span><em>input_state</em>, <em>boundaries=None</em>, <em>loop_unrolling_limit=10</em>, <em>enable_function_inlining=False</em>, <em>terminator=None</em>, <em>deviation_filter=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.veritesting.Veritesting" title="Permalink to this definition">¶</a></dt>
<dd><p>An exploration technique made for condensing chunks of code to single (nested) if-then-else constraints via CFG
accurate to conduct Static Symbolic Execution SSE (conversion to single constraint)</p>
<p>SSE stands for Static Symbolic Execution, and we also implemented an extended version of Veritesting (Avgerinos,
Thanassis, et al, ICSE 2014).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>input_state</strong> &#8211; The initial state to begin the execution with.</li>
<li><strong>boundaries</strong> &#8211; Addresses where execution should stop.</li>
<li><strong>loop_unrolling_limit</strong> &#8211; The maximum times that Veritesting should unroll a loop for.</li>
<li><strong>enable_function_inlining</strong> &#8211; Whether we should enable function inlining and syscall inlining.</li>
<li><strong>terminator</strong> &#8211; A callback function that takes a state as parameter. Veritesting will terminate
if this function returns True.</li>
<li><strong>deviation_filter</strong> &#8211; A callback function that takes a state as parameter. Veritesting will put the
state into &#8220;deviated&#8221; stash if this function returns True.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="angr.analyses.veritesting.Veritesting.is_not_in_cfg">
<code class="descname">is_not_in_cfg</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.veritesting.Veritesting.is_not_in_cfg" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns if s.addr is not a proper node in our CFG.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>s</strong> (<a class="reference internal" href="#angr.sim_state.SimState" title="angr.sim_state.SimState"><em>SimState</em></a>) &#8211; The SimState instance to test.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns bool:</th><td class="field-body">False if our CFG contains p.addr, True otherwise.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.veritesting.Veritesting.is_overbound">
<code class="descname">is_overbound</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.veritesting.Veritesting.is_overbound" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter out all states that run out of boundaries or loop too many times.</p>
<p>param SimState state: SimState instance to check
returns bool:    True if outside of mem/loop_ctr boundary</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.analyses.vfg"></span><dl class="class">
<dt id="angr.analyses.vfg.VFGJob">
<em class="property">class </em><code class="descclassname">angr.analyses.vfg.</code><code class="descname">VFGJob</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.vfg.VFGJob" title="Permalink to this definition">¶</a></dt>
<dd><p>A job descriptor that contains local variables used during VFG analysis.</p>
</dd></dl>

<dl class="class">
<dt id="angr.analyses.vfg.AnalysisTask">
<em class="property">class </em><code class="descclassname">angr.analyses.vfg.</code><code class="descname">AnalysisTask</code><a class="headerlink" href="#angr.analyses.vfg.AnalysisTask" title="Permalink to this definition">¶</a></dt>
<dd><p>An analysis task describes a task that should be done before popping this task out of the task stack and discard it.</p>
</dd></dl>

<dl class="class">
<dt id="angr.analyses.vfg.FunctionAnalysis">
<em class="property">class </em><code class="descclassname">angr.analyses.vfg.</code><code class="descname">FunctionAnalysis</code><span class="sig-paren">(</span><em>function_address</em>, <em>return_address</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.vfg.FunctionAnalysis" title="Permalink to this definition">¶</a></dt>
<dd><p>Analyze a function, generate fix-point states from all endpoints of that function, and then merge them to one state.</p>
</dd></dl>

<dl class="class">
<dt id="angr.analyses.vfg.CallAnalysis">
<em class="property">class </em><code class="descclassname">angr.analyses.vfg.</code><code class="descname">CallAnalysis</code><span class="sig-paren">(</span><em>address</em>, <em>return_address</em>, <em>function_analysis_tasks=None</em>, <em>mergeable_plugins=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.vfg.CallAnalysis" title="Permalink to this definition">¶</a></dt>
<dd><p>Analyze a call by analyze all functions this call might be calling, collect all final states generated by analyzing
those functions, and merge them into one state.</p>
</dd></dl>

<dl class="class">
<dt id="angr.analyses.vfg.VFGNode">
<em class="property">class </em><code class="descclassname">angr.analyses.vfg.</code><code class="descname">VFGNode</code><span class="sig-paren">(</span><em>addr</em>, <em>key</em>, <em>state=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.vfg.VFGNode" title="Permalink to this definition">¶</a></dt>
<dd><p>A descriptor of nodes in a Value-Flow Graph</p>
<p>Constructor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>addr</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; </li>
<li><strong>key</strong> (<em>BlockID</em>) &#8211; </li>
<li><strong>state</strong> (<a class="reference internal" href="#angr.sim_state.SimState" title="angr.sim_state.SimState"><em>SimState</em></a>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="angr.analyses.vfg.VFGNode.append_state">
<code class="descname">append_state</code><span class="sig-paren">(</span><em>s</em>, <em>is_widened_state=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.vfg.VFGNode.append_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Appended a new state to this VFGNode.
:param s: The new state to append
:param is_widened_state: Whether it is a widened state or not.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="angr.analyses.vfg.VFG">
<em class="property">class </em><code class="descclassname">angr.analyses.vfg.</code><code class="descname">VFG</code><span class="sig-paren">(</span><em>cfg=None</em>, <em>context_sensitivity_level=2</em>, <em>start=None</em>, <em>function_start=None</em>, <em>interfunction_level=0</em>, <em>initial_state=None</em>, <em>avoid_runs=None</em>, <em>remove_options=None</em>, <em>timeout=None</em>, <em>max_iterations_before_widening=8</em>, <em>max_iterations=40</em>, <em>widening_interval=3</em>, <em>final_state_callback=None</em>, <em>status_callback=None</em>, <em>record_function_final_states=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.vfg.VFG" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents a control-flow graph with static analysis result.</p>
<p>Perform abstract interpretation analysis starting from the given function address. The output is an invariant at
the beginning (or the end) of each basic block.</p>
<p>Steps:</p>
<blockquote>
<div><ul class="simple">
<li>Generate a CFG first if CFG is not provided.</li>
<li>Identify all merge points (denote the set of merge points as Pw) in the CFG.</li>
<li>Cut those loop back edges (can be derived from Pw) so that we gain an acyclic CFG.</li>
<li><dl class="first docutils">
<dt>Identify all variables that are 1) from memory loading 2) from initial values, or 3) phi functions. Denote</dt>
<dd>the set of those variables as S_{var}.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Start real AI analysis and try to compute a fix point of each merge point. Perform widening/narrowing only on</dt>
<dd>variables in S_{var}.</dd>
</dl>
</li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cfg</strong> &#8211; The control-flow graph to base this analysis on. If none is provided, we will
construct a CFGAccurate.</li>
<li><strong>context_sensitivity_level</strong> &#8211; The level of context-sensitivity of this VFG.
It ranges from 0 to infinity. Default 2.</li>
<li><strong>function_start</strong> &#8211; The address of the function to analyze.</li>
<li><strong>interfunction_level</strong> &#8211; The level of interfunction-ness to be</li>
<li><strong>initial_state</strong> &#8211; A state to use as the initial one</li>
<li><strong>avoid_runs</strong> &#8211; A list of runs to avoid</li>
<li><strong>remove_options</strong> &#8211; State options to remove from the initial state. It only works when <cite>initial_state</cite> is
None</li>
<li><strong>timeout</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="angr.analyses.vfg.VFG.get_any_node">
<code class="descname">get_any_node</code><span class="sig-paren">(</span><em>addr</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.vfg.VFG.get_any_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Get any VFG node corresponding to the basic block at &#64;addr.
Note that depending on the context sensitivity level, there might be
multiple nodes corresponding to different contexts. This function will
return the first one it encounters, which might not be what you want.</p>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.vfg.VFG.get_paths">
<code class="descname">get_paths</code><span class="sig-paren">(</span><em>begin</em>, <em>end</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.vfg.VFG.get_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all the simple paths between &#64;begin and &#64;end.
Returns: a list of angr.Path instances.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.analyses.vsa_ddg"></span><dl class="class">
<dt id="angr.analyses.vsa_ddg.DefUseChain">
<em class="property">class </em><code class="descclassname">angr.analyses.vsa_ddg.</code><code class="descname">DefUseChain</code><span class="sig-paren">(</span><em>def_loc</em>, <em>use_loc</em>, <em>variable</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.vsa_ddg.DefUseChain" title="Permalink to this definition">¶</a></dt>
<dd><p>Stand for a def-use chain. it is generated by the DDG itself.</p>
<p>Constructor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>def_loc</strong> &#8211; </li>
<li><strong>use_loc</strong> &#8211; </li>
<li><strong>variable</strong> &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="angr.analyses.vsa_ddg.VSA_DDG">
<em class="property">class </em><code class="descclassname">angr.analyses.vsa_ddg.</code><code class="descname">VSA_DDG</code><span class="sig-paren">(</span><em>vfg=None</em>, <em>start_addr=None</em>, <em>interfunction_level=0</em>, <em>context_sensitivity_level=2</em>, <em>keep_data=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.vsa_ddg.VSA_DDG" title="Permalink to this definition">¶</a></dt>
<dd><p>A Data dependency graph based on VSA states.
That means we don&#8217;t (and shouldn&#8217;t) expect any symbolic expressions.</p>
<p>Constructor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>vfg</strong> &#8211; An already constructed VFG. If not specified, a new VFG will be created with other
specified parameters. <cite>vfg</cite> and <cite>start_addr</cite> cannot both be unspecified.</li>
<li><strong>start_addr</strong> &#8211; The address where to start the analysis (typically, a function&#8217;s entry point).</li>
<li><strong>interfunction_level</strong> &#8211; See VFG analysis.</li>
<li><strong>context_sensitivity_level</strong> &#8211; See VFG analysis.</li>
<li><strong>keep_data</strong> &#8211; Whether we keep set of addresses as edges in the graph, or just the cardinality of
the sets, which can be used as a &#8220;weight&#8221;.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="angr.analyses.vsa_ddg.VSA_DDG.get_predecessors">
<code class="descname">get_predecessors</code><span class="sig-paren">(</span><em>code_location</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.vsa_ddg.VSA_DDG.get_predecessors" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns all predecessors of <cite>code_location</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>code_location</strong> &#8211; A CodeLocation instance.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A list of all predecessors.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.analyses.vsa_ddg.VSA_DDG.get_all_nodes">
<code class="descname">get_all_nodes</code><span class="sig-paren">(</span><em>simrun_addr</em>, <em>stmt_idx</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.analyses.vsa_ddg.VSA_DDG.get_all_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all DDG nodes matching the given basic block address and statement index.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-angr.blade"></span><dl class="class">
<dt id="angr.blade.Blade">
<em class="property">class </em><code class="descclassname">angr.blade.</code><code class="descname">Blade</code><span class="sig-paren">(</span><em>graph</em>, <em>dst_run</em>, <em>dst_stmt_idx</em>, <em>direction='backward'</em>, <em>project=None</em>, <em>cfg=None</em>, <em>ignore_sp=False</em>, <em>ignore_bp=False</em>, <em>ignored_regs=None</em>, <em>max_level=3</em>, <em>base_state=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.blade.Blade" title="Permalink to this definition">¶</a></dt>
<dd><p>Blade is a light-weight program slicer that works with networkx DiGraph containing CFGNodes.
It is meant to be used in angr for small or on-the-fly analyses.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>graph</strong> (<em>networkx.DiGraph</em>) &#8211; A graph representing the control flow graph. Note that it does not take
angr.analyses.CFGAccurate or angr.analyses.CFGFast.</li>
<li><strong>dst_run</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; An address specifying the target SimRun.</li>
<li><strong>dst_stmt_idx</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The target statement index. -1 means executing until the last statement.</li>
<li><strong>direction</strong> (<em>str</em>) &#8211; &#8216;backward&#8217; or &#8216;forward&#8217; slicing. Forward slicing is not yet supported.</li>
<li><strong>project</strong> (<em>angr.Project</em>) &#8211; The project instance.</li>
<li><strong>cfg</strong> (<em>angr.analyses.CFGBase</em>) &#8211; the CFG instance. It will be made mandatory later.</li>
<li><strong>ignore_sp</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; Whether the stack pointer should be ignored in dependency tracking. Any
dependency from/to stack pointers will be ignored if this options is True.</li>
<li><strong>ignore_bp</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.bool" title="claripy.ast.bool"><em>bool</em></a>) &#8211; Whether the base pointer should be ignored or not.</li>
<li><strong>max_level</strong> (<a class="reference internal" href="claripy.html#module-claripy.ast.int" title="claripy.ast.int"><em>int</em></a>) &#8211; The maximum number of blocks that we trace back for.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<span class="target" id="module-angr.slicer"></span><dl class="class">
<dt id="angr.slicer.SimSlicer">
<em class="property">class </em><code class="descclassname">angr.slicer.</code><code class="descname">SimSlicer</code><span class="sig-paren">(</span><em>arch</em>, <em>statements</em>, <em>target_tmps=None</em>, <em>target_regs=None</em>, <em>target_stack_offsets=None</em>, <em>inslice_callback=None</em>, <em>inslice_callback_infodict=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.slicer.SimSlicer" title="Permalink to this definition">¶</a></dt>
<dd><p>A super lightweight intra-IRSB slicing class.</p>
</dd></dl>

<span class="target" id="module-angr.annocfg"></span><dl class="class">
<dt id="angr.annocfg.AnnotatedCFG">
<em class="property">class </em><code class="descclassname">angr.annocfg.</code><code class="descname">AnnotatedCFG</code><span class="sig-paren">(</span><em>project</em>, <em>cfg=None</em>, <em>detect_loops=False</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.annocfg.AnnotatedCFG" title="Permalink to this definition">¶</a></dt>
<dd><p>AnnotatedCFG is a control flow graph with statement whitelists and exit whitelists to describe a slice of the
program.</p>
<p>Constructor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>project</strong> &#8211; The angr Project instance</li>
<li><strong>cfg</strong> &#8211; Control flow graph. Only used when path prioritizer is used.</li>
<li><strong>detect_loops</strong> &#8211; Only used when path prioritizer is used.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="angr.annocfg.AnnotatedCFG.from_digraph">
<code class="descname">from_digraph</code><span class="sig-paren">(</span><em>digraph</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.annocfg.AnnotatedCFG.from_digraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize this AnnotatedCFG object with a networkx.DiGraph consisting of the following
form of nodes:</p>
<p>Tuples like (block address, statement ID)</p>
<p>Those nodes are connected by edges indicating the execution flow.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>digraph</strong> (<em>networkx.DiGraph</em>) &#8211; A networkx.DiGraph object</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.annocfg.AnnotatedCFG.add_loop">
<code class="descname">add_loop</code><span class="sig-paren">(</span><em>loop_tuple</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.annocfg.AnnotatedCFG.add_loop" title="Permalink to this definition">¶</a></dt>
<dd><p>A loop tuple contains a series of IRSB addresses that form a loop. Ideally
it always starts with the first IRSB that we meet during the execution.</p>
</dd></dl>

<dl class="method">
<dt id="angr.annocfg.AnnotatedCFG.get_whitelisted_statements">
<code class="descname">get_whitelisted_statements</code><span class="sig-paren">(</span><em>addr</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.annocfg.AnnotatedCFG.get_whitelisted_statements" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">True if all statements are whitelisted</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.annocfg.AnnotatedCFG.dbg_print_irsb">
<code class="descname">dbg_print_irsb</code><span class="sig-paren">(</span><em>irsb_addr</em>, <em>project=None</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.annocfg.AnnotatedCFG.dbg_print_irsb" title="Permalink to this definition">¶</a></dt>
<dd><p>Pretty-print an IRSB with whitelist information</p>
</dd></dl>

<dl class="method">
<dt id="angr.annocfg.AnnotatedCFG.keep_path">
<code class="descname">keep_path</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.annocfg.AnnotatedCFG.keep_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a path, returns True if the path should be kept, False if it should be cut.</p>
</dd></dl>

<dl class="method">
<dt id="angr.annocfg.AnnotatedCFG.filter_path">
<code class="descname">filter_path</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.annocfg.AnnotatedCFG.filter_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Used for debugging.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path</strong> &#8211; A Path instance</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True/False</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="angr.annocfg.AnnotatedCFG.path_priority">
<code class="descname">path_priority</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.annocfg.AnnotatedCFG.path_priority" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a path, returns the path priority. A lower number means a higher priority.</p>
</dd></dl>

<dl class="method">
<dt id="angr.annocfg.AnnotatedCFG.successor_func">
<code class="descname">successor_func</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#angr.annocfg.AnnotatedCFG.successor_func" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback routine that takes in a path, and returns all feasible successors to path group. This callback routine
should be passed to the keyword argument &#8220;successor_func&#8221; of PathGroup.step().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path</strong> &#8211; A Path instance.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A list of all feasible Path successors.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-angr.simos">
<span id="simos"></span><h2>SimOS<a class="headerlink" href="#module-angr.simos" title="Permalink to this headline">¶</a></h2>
<p>Manage OS-level configuration.</p>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="claripy.html" class="btn btn-neutral float-right" title="claripy — Solver Engine" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral" title="angr API documentation" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, The angr project.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'7.7.12.16',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>